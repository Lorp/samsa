<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="utf-8">
<title>Samsa: Variable Font Inspector</title>

<script src="samsa-core.js"></script>

<link rel = "stylesheet" type = "text/css" href = "samsa-gui.css" />
</head>

<body>

<div id="container">

<div id="title"><h1>Samsa</h1>
	<div class="subtitle">
		variable font inspector<br>
		<a href="https://github.com/Lorp/samsa" title="Samsa on GitHub"><img width="15" height="15" src="images/GitHub-Mark-64px.svg"></a>
	</div>
	<div class="subtitle"></div>
</div>

<div id="font-file" class="inactive">
	&lt;drop a variable font here&gt;
</div>

<div id="controls">

	<div id="info" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Info</h2>
		<div></div>
	</div>

	<div id="ui" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> UI</h2>
		<div></div>
	</div>

	<div id="axes" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Axes</h2>
		<div></div>
	</div>

	<div id="instances" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Instances
			<!--
			<span class="icon" id="instances-as-grid">&#xf00a;</span>
			<span class="icon" id="instances-as-list">&#xf0c9;</span>
			-->
		</h2>
		<div></div>
	</div>

	<div id="tvts" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Tuple Variations</h2>
		<div style="overflow-x: scroll;"></div>
	</div>

	<div id="designspace" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Designspace</h2>
		<div></div>
	</div>

<!--
	<div id="stat" class="panel">
		<h2>STAT</h2>
		<div></div>
	</div>
-->

	<div id="glyphs" class="panel open">
		<h2><span class="icon bold reveal open">&#xf04b;</span> Glyphs
			<!-- <span class="icon bold" id="glyphs-rewind">&#xf04a;</span> -->
			<span class="icon bold" id="glyphs-stepback" title="Step back">&#xf048;</span>
			<span class="icon bold" id="glyphs-stop" title="Stop playing">&#xf04d;</span>
			<span class="icon bold" id="glyphs-play" title="Play">&#xf04b;</span>
			<span class="icon bold" id="glyphs-stepforward" title="Step forward">&#xf051;</span>
			<!-- <span class="icon bold" id="glyphs-fastforward">&#xf04e;</span> -->
		</h2>
		<div></div>
	<br clear="all">

	</div>

	<div id="font-list" class="panel open">
		<h2><span class="icon bold reveal open">&#xf04b;</span> Fonts ready to load</h2>
		<div></div>
	</div>

</div>

<div id="drawing"></div>

</div>


<script>


let GLOBAL = {
	vf: null, // maybe allow an array of fonts... select them with a drop down in info panel
	currentGlyphId: null,
	fontList: [],
};

CONFIG.visualization = true;
CONFIG.uiModes = {

	light: {
		name: "light",

		cartesianAxes: {
			stroke: "#31b8e7",
			strokeWidth: 1,
		},

		arrow: {
			strokeWidth: 3,
			tipLength: 20,
			tipWidth: 15,
			color: "#0044ee",
		},

		designspace: {
			colors: ["blue", "red"],
		},

		tuple: {
			colors: ["#f57670", "#c39921","#57b21f","#1ebf95","#1fb7e9","#a58efc","#f966d5"], // "ggplot2 hue" palette from https://serialmentor.com/dataviz/color-basics.html
		},

		tupleNeedle: {
			stroke: "red",
		},

		tupleScalar: {
			fill: "black",
		},

		point: {
			size: 10,
			shape: "■", // one of ■●▲+x
			shapeOffCurve: "●",
			opacity: 1,
		},		

		glyphDefault: {
			fill: "#ddd",
			stroke: "none",
			strokeWidth: 0,
			backgroundColor: "transparent",
			point: {
				stroke: "#888",
				strokeWidth: 3,
				fill: "none",
				shape: "+",
				shapeOffCurve: "+",
			},
		},

		glyphCurrent: {
			fill: "none",
			stroke: "black",
			strokeWidth: 2,
			opacity: 1,
			point: {
				size: 15,
				strokeWidth: 0,
				fill: "blue",
				opacity: 0.7,
			},
		},

		glyphThumb: {
			fill: "black",
			stroke: "none",
			strokeWidth: 0,
		},

		text: {
			font: "IBM Plex",
			size: 18,
		},

		label: {
			font: "IBM Plex",
			size: 12,
		},
	},

	dark: {
		name: "dark",

		cartesianAxes: {
			stroke: "lightblue",
			strokeWidth: 1,
		},

		arrow: {
			strokeWidth: 3,
			tipLength: 20,
			tipWidth: 15,
			//color: "#0044ee",
			color: "orange",
		},

		designspace: {
			colors: ["blue", "red"],
		},

		tuple: {
			//colors: ["#269d78", "#d7601c","#7571b1","#e5318a","#68a42c","#e5aa27","#a57528"], // "ColorBrewer Dark2" palette from https://serialmentor.com/dataviz/color-basics.html
			colors: ["#f57670", "#c39921","#57b21f","#1ebf95","#1fb7e9","#a58efc","#f966d5"], // "ggplot2 hue" palette from https://serialmentor.com/dataviz/color-basics.html
		},

		tupleNeedle: {
			stroke: "red",
		},

		tupleScalar: {
			fill: "black",
		},

		point: {
			size: 7,
			shape: "+",
			shapeOffCurve: "+",
			stroke: "yellow",
			strokeWidth: 2,
		},

		glyphDefault: {
			fill: "#555",
			stroke: "none",
			strokeWidth: 0,
			backgroundColor: "black",
		},

		glyphCurrent: {
			fill: "white",
			strokeWidth: 2,
			opacity: 0.8,
			point: {
				size: 17,
				fill: "blue",
				stroke: "none",
				opacity: 0.7,
				shape: "■", // one of ⯅●■
				shapeOffCurve: "●", // ⯅●■
			}
		},

		glyphThumb: {
			fill: "black",
			stroke: "none",
			strokeWidth: 0,
		},

		// ?better as CSS, so we can add italic, weight, border, background-color etc?
		text: {
			font: "IBM Plex",
			size: 18,
		},

		label: {
			font: "IBM Plex",
			size: 12,
		},
	},

	loci: {
		name: "loci",

		cartesianAxes: {
			stroke: "#31b8e7",
			strokeWidth: 1,
		},

		arrow: {
			strokeWidth: 0,
		},

		designspace: {
			colors: ["royalblue", "crimson"],
		},

		tuple: {
			colors: ["#f57670", "#c39921","#57b21f","#1ebf95","#1fb7e9","#a58efc","#f966d5"], // "ggplot2 hue" palette from https://serialmentor.com/dataviz/color-basics.html
		},

		tupleNeedle: {
			stroke: "red",
		},

		tupleScalar: {
			fill: "black",
		},

		loci: {
			steps: 40,
			strokeWidth: 6,
			style: "railway", // "railway" or "line"
			opacity: 0.7,
		},

		point: {
			size: 10,
			shape: "●", // one of ■●▲+x
			shapeOffCurve: "●",
			opacity: 1,
		},		

		glyphDefault: {
			fill: "none",
			stroke: "none",
			strokeWidth: 0,
			backgroundColor: "transparent",
			point: {
				stroke: "#888",
				strokeWidth: 0,
				fill: "none",
				shape: "+",
				shapeOffCurve: "+",
			},
		},

		glyphCurrent: {
			fill: "none",
			stroke: "#aaa",
			strokeWidth: 2,
			opacity: 1,
			point: {
				size: 15,
				strokeWidth: 0,
				fill: "green",
				opacity: 0.75,
			},
		},

		glyphThumb: {
			fill: "black",
			stroke: "none",
			strokeWidth: 0,
		},

		text: {
			font: "IBM Plex",
			size: 18,
		},

		label: {
			font: "IBM Plex",
			size: 12,
		},
	},

	preview: {
		name: "preview",

		cartesianAxes: {
			stroke: "lightblue",
			strokeWidth: 1,
		},

		arrow: {
			strokeWidth: 0,
			tipLength: 0,
			tipWidth: 0,
			color: "transparent",
		},

		designspace: {
			colors: ["blue", "red"],
		},

		tuple: {
			colors: ["#f57670", "#c39921","#57b21f","#1ebf95","#1fb7e9","#a58efc","#f966d5"], // "ggplot2 hue" palette from https://serialmentor.com/dataviz/color-basics.html
		},

		tupleNeedle: {
			stroke: "red",
		},

		tupleScalar: {
			fill: "black",
		},

		point: {
			size: 0, // disable points
		},		

		glyphDefault: {
			fill: "none", // disable the default glyph
			stroke: "none",
			strokeWidth: 0,
			backgroundColor: "white",
		},

		glyphCurrent: {
			fill: "black",
			stroke: "none",
			opacity: 1,
		},

		glyphThumb: {
			fill: "black",
			stroke: "none",
			strokeWidth: 0,
		},

		text: {
			font: "IBM Plex",
			size: 18,
		},

		label: {
			font: "IBM Plex",
			size: 12,
		},
	},
}

CONFIG.ui = CONFIG.uiModes["light"];

CONFIG.docs = {
	axes: {
		wght: "regex:microsoft",
		wdth: "regex:microsoft",
		opsz: "regex:microsoft",
		ital: "regex:microsoft",
		slnt: "regex:microsoft",
		xtra: "regex:typenetwork",
		xopq: "regex:typenetwork",
		ytra: "regex:typenetwork",
		yopq: "regex:typenetwork",
		ytlc: "regex:typenetwork",
		ytuc: "regex:typenetwork",
		ytde: "regex:typenetwork",
		ytas: "regex:typenetwork",
		xtab: "regex:typenetwork",
		vrot: "regex:typenetwork",
		udln: "regex:typenetwork",
		shdw: "regex:typenetwork",
		refl: "regex:typenetwork",
		otln: "regex:typenetwork",
		engr: "regex:typenetwork",
		embo: "regex:typenetwork",
		ytch: "regex:typenetwork",
		xtch: "regex:typenetwork",
		rxad: "regex:typenetwork",
		ryad: "regex:typenetwork",
		rsec: "regex:typenetwork",
		vuid: "regex:typenetwork",
		votf: "regex:typenetwork",
		gext: "https://github.com/microsoft/OpenTypeDesignVariationAxisTags/blob/master/Proposals/Glyph_Extension_Axis/ProposalSummary.md",
		hght: "https://github.com/microsoft/OpenTypeDesignVariationAxisTags/blob/master/Proposals/Height_Axis/ProposalSummary.md",
		spac: "https://github.com/Microsoft/OpenTypeDesignVariationAxisTags/blob/master/Proposals/Spacing_Axis/ProposalSummary.md",
	},
	regex: {
		microsoft: "https://docs.microsoft.com/en-us/typography/opentype/spec/dvaraxistag_$1",
		typenetwork: "https://variationsguide.typenetwork.com/#$1",
	},
	hoi: "http://underware.nl/case-studies/hoi/",
};



// shorthands
function Q (selector) {
	return document.querySelector(selector);
}

function Qall (selector) {
	return document.querySelectorAll(selector);
}


// TODO: specify that this gets the current fvs from sliders
function getCurrentFvs() {

	// TODO: store the current values separately from the axes’ value to avoid conversions

	let fvs = {};
	Qall(".slider").forEach(slider => {
		let axis = slider.data.axis;
		fvs[axis.tag] = axis.min + slider.value * (axis.max - axis.min);
	});
	return fvs;
}


// TODO: this is needless duplication of what SamsaVF.addInstance() already does
// - we can assign the ui object in the options argument
function appendInstanceEl(instance, select) {

	let font = GLOBAL.vf;
	let panel = Q("#instances>div");

	// create the instance DOM element
	let li = document.createElement("div"); // not li?
	let icon = "-", title;

	// initialize instance if necessary
	if (instance === undefined) {
		instance = font.addInstance(getCurrentFvs(), { name: "Custom", ui: li }); // { name: "Custom", tuple: [] };
	}

	// list view
	// - items are: bookmark icon, name, n axis settings
	panel.style.minWidth = "100%";
	panel.style.overflowX = "scroll";


	li.classList.add("instance");
	li.style.display = "grid";
	li.style.gridTemplateColumns = `30px 30px 100px 30px 30px repeat(${GLOBAL.vf.axisCount}, 70px)`;

	// instance type
	switch (instance.type) {
		case "default": icon = "&#xf015;"; title = "Default"; break; // FontAwesome home
		case "named": icon = "&#xf02e;"; title = "Named instance"; break; // FontAwesome bookmark
		case "custom": icon = "&#xf1de;"; title = "Custom instance"; break; // FontAwesome sliders
	}
	let cell0 = document.createElement("div");
	cell0.style.cursor = "pointer";
	cell0.style.textAlign = "center";
	cell0.style.fontFamily = "FontAwesome";
	cell0.innerHTML = `<strong title="${title}">${icon}</strong>`;

	// SVG of the A glyph
	// - would current glyph be better? ... the image serves as a kind of visual label, but...
	let cell1 = document.createElement("div");
	let svg = SVG("svg");

	let glyph = font.glyphs[getDefaultGlyphId(font)];
	let iglyph = glyphApplyVariations(glyph, instance.tuple); // TODO: make composite-ready

	if (iglyph && iglyph.numContours > 0) {

		// simple glyph
		let svgPath = SVG("path");
		let svgg = SVG("g");
		let scale = 0.02 * 1000 / font.unitsPerEm;
		svg.setAttributeNS(null, "width","30");
		svg.setAttributeNS(null, "height","30");
		svgg.setAttributeNS(null, "transform", `translate(4,20) scale(${scale},-${scale})`);
		
		//svgMarker.attr({markerWidth:20,markerHeight:20);

 		svgPath.setAttributeNS(null, "d", getGlyphSVGpath(iglyph));

		svg.appendChild(svgg);

		// glyph
		svgg.appendChild(svgPath);

		// x and y axes

		//glyphThumb.appendChild(svg);

	}
	else if (glyph && glyph.numContours < 0) {


	}


	cell1.appendChild(svg);

	// instance name
	let cell2 = document.createElement("div");
	cell2.style.textAlign = "center";
	cell2.innerHTML = `<input value="${instance.name}" ${instance.type == "default" ? "readonly " : ""}style="width: 85px">`;

	// visibility
	let cell3 = document.createElement("div");
	cell3.setAttribute("title", "Visibility");
	cell3.style.textAlign = "center";
	cell3.style.fontFamily = "FontAwesome";
	cell3.style.cursor = "pointer";
	cell3.innerHTML = "&#xf06e"; // eye open f070 eye closed

	// instantiate button
	let cell4 = document.createElement("div");
	cell4.classList.add("instantiate");
	cell4.setAttribute("title", "Download TTF");
	cell4.style.textAlign = "center";
	cell4.style.fontFamily = "FontAwesome";
	cell4.style.cursor = "pointer";
	cell4.innerHTML = "&#xf358;"; //"&#xf56d;" // download

	// append all the elements so far
	li.appendChild(cell0);
	li.appendChild(cell1);
	li.appendChild(cell2);
	li.appendChild(cell3);
	li.appendChild(cell4);

	// all the axis settings
	GLOBAL.vf.axes.forEach((axis, a) => {
		let axisCell = document.createElement("div");
		axisCell.style.fontSize = "75%";
		axisCell.style.textAlign = "right";
		axisCell.innerText = instance.fvs[axis.tag];
		li.appendChild(axisCell);
	});

	// bind instance data to instance element
	li.data = { instance: instance };

	// append the instance DOM element
	panel.appendChild(li);

	// make it active
	if (select) {
		setActiveInstance (GLOBAL.vf, li);
	}
}


function exportImage (format) {
	if (GLOBAL.frameIndex === undefined)
		GLOBAL.frameIndex = 0;
	else
		GLOBAL.frameIndex++;

	let svgCode = Q("#drawing").innerHTML;
	svgCode = svgCode.replace(`<svg `, `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" `);

	if (format == "svg") {
		let fauxLink = document.createElement("a");
		fauxLink.download = "samsa-drawing.svg";
		fauxLink.href = "data:image/svg+xml;base64," + btoa(svgCode);
		document.body.appendChild(fauxLink); // needed for Firefox, not Chrome or Safari
		fauxLink.click();
		fauxLink.remove();
	}
	else if (format == "png") {
		// make a canvas to export the bitmap
		let canvas = document.createElement("canvas");
		let img = new Image();
		canvas.setAttribute("width", 1080);
		canvas.setAttribute("height", 720);
		canvas.id = "samsa-drawing-canvas";
		canvas.style.border = "1px solid red";
		document.body.appendChild(canvas);
		img.onload = function () {
			//alert ("loaded");
			let canvas = Q("#samsa-drawing-canvas");
			let filename = "samsa-drawing";
			let frameIndexStr = GLOBAL.frameIndex.toString();
			for ( ; frameIndexStr.length<3; frameIndexStr = `0${frameIndexStr}`) {
			}
			filename = filename + frameIndexStr + ".png";
			let ctx = canvas.getContext("2d");
			ctx.drawImage(img, 0, 0);
			let png = canvas.toDataURL('image/png'); // get pixels from canvas
			let fauxLink = document.createElement("a");
			fauxLink.download = filename;
			//fauxLink.href = "data:image/svg+xml;base64," + btoa(svgCode);
			fauxLink.href = png;
			document.body.appendChild(fauxLink); // needed for Firefox, not Chrome or Safari
			fauxLink.click();
			fauxLink.remove();

			//canvas.parentNode.removeChild(canvas);
			canvas.remove(); // better to just blank it each time?
		}
		img.width = 800;
		img.height = 800;
		img.src = "data:image/svg+xml," + encodeURIComponent(svgCode);	

		// ffmpeg command to export the animation bash script
		// - when exporting multiple images is working, we’ll save this in a file too
		// #!/bin/bash
		// ffmpeg -r 10 -i samsa-drawing%03d.png -pix_fmt yuv420p -loglevel error samsa-drawing.mp4
	}

}



function vfLoaded (font) {

	GLOBAL.vf = font;
	let panel;

	// set up initial global tuple, the default designspace location
	GLOBAL.tuple = [];
	font.axes.forEach(() => {
		GLOBAL.tuple.push(0);
	});


	///////////////////////////////////////////////////////
	// Filename box
	///////////////////////////////////////////////////////
	Q("#font-file").innerText = font.filename; // or font.names[6];



	///////////////////////////////////////////////////////
	// Info panel
	///////////////////////////////////////////////////////
	panel = Q("#info>div");
	panel.innerText = "";
	panel.innerHTML += `${font.filename} (${font.filesize || "<em>n</em>"} bytes)<br>`;
	panel.innerHTML += `Full name: ${font.names[4]}<br>`;
	//panel.innerHTML += `Date: ${Date(font.date).toString()}<br>`;



	///////////////////////////////////////////////////////
	// UI Panel
	///////////////////////////////////////////////////////
	panel = Q("#ui>div");
	if (!Q("#ui-mode")) { // only build once
		panel.innerText = "";

		// ui options select
		let uiModeHTML = "";
		uiModeHTML += `<select id="ui-mode">`;
		Object.keys(font.config.uiModes).forEach(mode => {
			uiModeHTML += `<option value="${mode}">${mode}</option>`;
		});
		uiModeHTML += `</select><br>`;
		panel.innerHTML += uiModeHTML;
		panel.innerHTML += "<label>Deltas</label>&nbsp;";
		panel.innerHTML += `<input id="arrows-split" class="ui-arrows" type="checkbox" checked><label for="arrows-split">split</label>&nbsp;`;
		panel.innerHTML += `<input id="arrows-total" class="ui-arrows" type="checkbox"><label for="arrows-total">total</label><br>`;

		/*
		panel.innerHTML += "<label>Delta colours</label>&nbsp;";
		panel.innerHTML += `<input id="arrows-colours" name="arrows-colours" class="ui-arrows-colours" type="radio" checked><label for="arrows-split">by tuple</label>&nbsp;`;
		panel.innerHTML += `<input id="arrows-colours" name="arrows-colours" class="ui-arrows-colours" type="radio"><label for="arrows-total">by order</label><br>`;
		*/

		// SVG export
		panel.innerHTML += `<button id="export-svg">Export SVG</button>`;
		panel.innerHTML += `<button id="export-png">Export PNG</button>`;

		// set the value for the select (for some reason it doesn’t work if this code comes any earlier)
		Q("#ui-mode").value = font.config.ui.name;

		// UI checkbox click
		Qall(".ui-arrows").forEach(el => {
			el.addEventListener("change", e => {
				let instance = font.addInstance(null, {tuple: GLOBAL.tuple});
				let glyph = font.glyphs[GLOBAL.currentGlyphId];
				let iglyph = glyphApplyVariations(glyph, null, instance);
				setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
				font.instances.pop();
			});
		});

		// SVG export click
		Q("#export-svg").addEventListener("click", () => {
			exportImage ("svg");
		});
		Q("#export-png").addEventListener("click", () => {
			exportImage ("png");
		});
	}


	///////////////////////////////////////////////////////
	// Axes panel
	///////////////////////////////////////////////////////
	panel = Q("#axes>div");
	panel.innerText = "";


	let liH = document.createElement("li");
	liH.classList.add("header");
	liH.style.display = "grid";
	liH.style.gridTemplateColumns = `35px 20px 45px 45px 45px 45px 45px 1fr`;
	liH.innerHTML = `<label>Tag</label><label class="icon bold">&#xf129;</label><label>Name</label><label class="min icon bold" style="text-align:right;">&#xf13a;</label><label class="default icon bold" style="text-align:right;">&#xf015;</label><label class="max icon bold" style="text-align:right;">&#xf139;</label><label class="icon bold" style="text-align:right;">&#xf007;</label>`;

	liH.innerHTML += `<select id="axis-value-format"><option>user</option><option>userhex</option><option>norm</option><option>normhex</option></select>`;
	//GLOBAL.vf.axes.forEach(axis => {
	//	liH.innerHTML += `<label style="width:100%; text-align:right;"><tt>${axis.tag}</tt></label>`;
	//});
	panel.appendChild(liH);

	// add each axis
	font.axes.forEach((axis, a) => {

		let li = document.createElement("li");
		li.id = `axis-${a}`;
		li.style.display = "grid";
		li.style.gridTemplateColumns = `35px 20px 45px 45px 45px 45px 45px 1fr`;
		li.style.listStyleType = "none";

		li.innerHTML = `<label><tt>${axis.tag}</tt></label>`;

		let docStr = "", docUrl = font.config.docs.axes[axis.tag.toLowerCase()];
		if (docUrl) {
			let docParts = docUrl.split(/:(.+)/)
			if (docUrl && docParts[0] == "regex") {
				docUrl = font.config.docs.regex[docParts[1]].replace("$1", axis.tag.toLowerCase()); // handles microsoft and typenetwork
			}
			docStr = `<a href="${docUrl}" class="icon bold" title="‘${axis.tag}’ axis specification" target="_blank">&#xf05a;</a>`; // book icon, links to the specification of this axis
		}
		li.innerHTML += `<div>${docStr}</div>`;

		li.innerHTML += `<label>${axis.name}</label>`;

		li.innerHTML += `<input class="axis-min" value="${axis.min}" readonly style="text-align:right;">`;
		li.innerHTML += `<input class="axis-default" value="${axis.default}" readonly style="text-align:right;">`;
		li.innerHTML += `<input class="axis-max" value="${axis.max}" readonly style="text-align:right;">`;
		li.innerHTML += `<input class="axis-current active" value="${axis.default}" style="text-align:right; font-weight: bold;">`; // current

		panel.appendChild(li);

		/*
		let label =  document.createElement("label");

		//label.innerHTML = `<span style="font-weight: bold; font-family: monospace;">${axis.tag}</span> ${axis.name}`;
		label.innerHTML = `<tt>${axis.tag}</tt> ${axis.name}`;
		let docUrl = font.config.docs.axes[axis.tag.toLowerCase()];
		if (docUrl) {
			let docParts = docUrl.split(/:(.+)/)
			if (docUrl && docParts[0] == "regex") {
				docUrl = font.config.docs.regex[docParts[1]].replace("$1", axis.tag.toLowerCase()); // handles microsoft and typenetwork
			}
			label.innerHTML += ` <a href="${docUrl}" class="icon bold" title="‘${axis.tag}’ axis specification" target="_blank">&#xf02d;</a>`; // book icon, links to the specification of this axis
		}
		panel.appendChild(label);
		*/

		let slider = document.createElement("input");
		slider.classList.add("slider");
		slider.setAttribute("type", "range");
		slider.setAttribute("min", 0.0);
		slider.setAttribute("max", 1.0);
		slider.setAttribute("step", 0.001);

		slider.data = {axis: axis};

		//let boxes = document.createElement("label");

		panel.appendChild(slider);
		slider.addEventListener("input", axisInput);

	});

	// add button
	let addInstanceEl = document.createElement("button");
	addInstanceEl.innerText = "Add instance";
	addInstanceEl.id = "instance-add";
	panel.appendChild(addInstanceEl);
	//addInstanceEl.onclick = addInstance;

	addInstanceEl.addEventListener("click", ()=>{
		appendInstanceEl(undefined, true);
	});

	Q("#axis-value-format").addEventListener("change", ()=>{

		let fvs = font.tupleToFvs(GLOBAL.tuple);
		font.axes.forEach((axis,a) => {
			Q(`#axis-${a}>.axis-min`).value = numberFormat(axis.min, axis);
			Q(`#axis-${a}>.axis-default`).value = numberFormat(axis.default, axis);
			Q(`#axis-${a}>.axis-max`).value = numberFormat(axis.max, axis);
			let currentVal = fvs[axis.tag] === undefined ? axis.default : fvs[axis.tag];
			Q(`#axis-${a}>.axis-current`).value = numberFormat(currentVal, axis);
		});

	});


	///////////////////////////////////////////////////////
	// Instances panel
	///////////////////////////////////////////////////////
	panel = Q("#instances>div");
	panel.innerText = "";
	panel.style.backgroundClip = "border-box";
	panel.style.padding = "1px 0"; // necessary so the padding of the contents uses the panel’s background-color 

	let li = Q("div");
	let fvsString = "";

	// add each instance
	font.instances.forEach((instance, i) => {
		appendInstanceEl(instance);
	});
	setActiveInstance(GLOBAL.vf); // without an instance parameter, it sets it to the default



	///////////////////////////////////////////////////////
	// Designspace panel
	///////////////////////////////////////////////////////
	panel = Q("#designspace>div");
	panel.innerText = "";
	panel.style.backgroundColor = "white";

	// build cartesian area
	let cartesian = document.createElement("div");
	cartesian.id = "ds-cartesian";
	cartesian.setAttribute("style", "width: 100%; height: 360px;");
	panel.appendChild(cartesian);

	// checkboxes for X and Y axis assignment
	let htmlX, htmlY;
	htmlX = `<div id="xSelect" class="ds-axis-group">`;
	htmlY = `<div id="ySelect" class="ds-axis-group">`;
	GLOBAL.vf.axes.forEach((axis,a) => {
		htmlX += `<div><input type="checkbox" id="x-${axis.tag}" value="${axis.tag}"${a==0 ? " checked" : ""}><label for="x-${axis.tag}">${axis.tag}</label></div>`;
		htmlY += `<div><input type="checkbox" id="y-${axis.tag}" value="${axis.tag}"${a==1 ? " checked" : ""}><label for="y-${axis.tag}">${axis.tag}</label></div>`;
	});
	htmlX += `</div>`;
	htmlY += `</div>`;
	panel.innerHTML += `<div class="cartesian-axis-row"><div>X=<span id="xValue">0</span></div>${htmlX}</div>`;
	panel.innerHTML += `<div class="cartesian-axis-row"><div>Y=<span id="yValue">0</span></div>${htmlY}</div>`;
	
	// attach change events to each checkbox
	Qall(".ds-axis-group input").forEach(el => {
		el.addEventListener("change", () => {
			// validate new state of checkboxes
			let valid = true, foundAxes = [];
			Qall(".ds-axis-group input:checked").forEach(el => {
				if (foundAxes.includes(el.value))
					valid = false;
				else
					foundAxes.push(el.value);
			});

			// if invalid, set red background
			xSelect.style.backgroundColor = ySelect.style.backgroundColor = valid ? "inherit" : "red";
		});
	});

	// TODO: consider user/normalized option

	updateDesignspace();


	// TODO: .designspace export - is this useful?
	if (false) {

		let exportEl = document.createElement("button");
		exportEl.innerText = "Export as .designspace";
		exportEl.id = "instance-add";
		panel.appendChild(exportEl);

		/*
		<designspace format="3">
			<axes>
				<!-- define axes here -->
				<axis../>
				</axes>
			<sources>
				<!-- define masters here -->
				<source../>
			</sources>
			<instances>
				<!-- define instances here -->
				<instance../>
			</instances>
		</designspace>
		*/

		let designspace = document.createElement("designspace");
		designspace.setAttribute("format", 3);
		let dsAxes = document.createElement("axes");
		let dsSources = document.createElement("sources");
		let dsInstances = document.createElement("instances");
		GLOBAL.vf.axes.forEach(axis => {
			let dsAxis = document.createElement("axis");
			dsAxis.setAttribute("name", axis.name);
			dsAxis.setAttribute("tag", axis.tag);
			dsAxis.setAttribute("minimum", axis.min);
			dsAxis.setAttribute("default", axis.default);
			dsAxis.setAttribute("maximum", axis.max);
			dsAxes.appendChild(dsAxis);
		})
		// what to do about sources?
		GLOBAL.vf.instances.forEach(instance => {
			let dsInst = document.createElement("instance");
			//dsInstances.appendChild(dsInst);
		})
		designspace.appendChild(dsAxes);
		designspace.appendChild(dsSources);
		designspace.appendChild(dsInstances);
		console.log ("<?xml version='1.0' encoding='utf-8'?>\n" + designspace.outerHTML);
	}



	if (!panel.parentNode.classList.contains("open"))
		panel.style.display = "none";


	///////////////////////////////////////////////////////
	// Glyphs panel
	///////////////////////////////////////////////////////
	GLOBAL.currentGlyphId = getDefaultGlyphId(font);
	updateGlyphsPanel (font.instances[0]); // instances[0] is always the default instance


	Q("body").style.cursor = "default";


	///////////////////////////////////////////////////////
	// late event handlers and assignments
	///////////////////////////////////////////////////////

	// ui: handle change of mode
	Q("#ui-mode").addEventListener("change", () => {
		console.log(Q("#ui-mode").value);
		font.config.ui = font.config.uiModes[Q("#ui-mode").value];

		let instance = font.addInstance(null, {tuple: GLOBAL.tuple});
		setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
		font.instances.pop();
	});

	// designspace: handle mousemove (late event handler)
	Q("#ds-cartesian").addEventListener("mousemove", e => {
		// requires pointer-events:none on all grid lines

		//console.log(e.target.id);
		let rect = e.target.getBoundingClientRect();
		let x = e.clientX - rect.left;
		let y = e.clientY - rect.top;
		x = x/180-1;
		y = 1-y/180;

		// update the visual designspace location
		Q("#svgXVal").setAttributeNS(null, "d", `M${x} -1 L${x} 1`);
		Q("#svgYVal").setAttributeNS(null, "d", `M-1 ${y} L1 ${y}`);

		// initialize tuple
		let tuple = [];
		for (let a=0; a < GLOBAL.vf.axes.length; a++) {
			tuple.push(0); // default is 0 by definition
		}
		
		// what VF axes are attached to the X axis?
		Qall("#xSelect input:checked").forEach(el => {
			GLOBAL.vf.axisIndices(el.value).forEach(i => tuple[i]=x );
		});

		// what VF axes are attached to the Y axis?
		Qall("#ySelect input:checked").forEach(el => {
			GLOBAL.vf.axisIndices(el.value).forEach(i => tuple[i]=y );
		});

		// update the text fields
		Q("#xValue").innerText = x.toFixed(5);
		Q("#yValue").innerText = y.toFixed(5);

		// set the axes in the Axes panel
		let fvs = GLOBAL.vf.tupleToFvs(tuple);
		setAxes (GLOBAL.vf, fvs);

		// now update the glyph in the drawing
		// - should we do this simply by setting the axes in the Axes panel
		let instance = font.addInstance(null, {tuple: tuple});
		let glyph = font.glyphs[GLOBAL.currentGlyphId];
		let iglyph = glyphApplyVariations(glyph, null, instance);
		setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
		font.instances.pop();

		axesUpdateValues();

	});

}


function numberFormat(val, axis) {

	let V;
	switch (Q("#axis-value-format").value) {

		case "user":
			V = val;
			break;

		case "userhex":
			V = Math.round(val * 0x10000);
			if (V<0)
				V += 0x100000000;
			V = V.toString(16);
			for (let p=V.length; p<8; p++)
				V = `0${V}`;
			break;

		case "norm":
			V = GLOBAL.vf.axisNormalize(axis, val);
			break;

		case "normhex":
			V = GLOBAL.vf.axisNormalize(axis, val);
			V = Math.round(V * 0x4000);
			if (V<0)
				V += 0x10000;
			V = V.toString(16);
			for (let p=V.length; p<4; p++)
				V = `0${V}`;
			break;

	}
	return V;
}


function axesUpdateValues () {
	// update axis values
	let fvs = GLOBAL.vf.tupleToFvs(GLOBAL.tuple);
	GLOBAL.vf.axes.forEach((axis,a) => {
		let currentVal = fvs[axis.tag] === undefined ? axis.default : fvs[axis.tag];
		Q(`#axis-${a}>.axis-current`).value = numberFormat(currentVal, axis);
	});
}


function axisInput() {

	let font = GLOBAL.vf;

	// create instance
	let instance = font.addInstance(getCurrentFvs()); // { name: "Custom", tuple: [] };

	let glyph = font.glyphs[GLOBAL.currentGlyphId];
	let iglyph = glyphApplyVariations(glyph, null, instance);
	setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
	
	axesUpdateValues();

	// delete instance? definitely!
	font.instances.pop();
}

function updateDesignspace() {

	const ui = CONFIG.ui;
	let cb = Q("#dsAxesMultiple");
	let xSelect = Q("#xSelect");
	let ySelect = Q("#ySelect");

	// draw cartesian axes
	let cartesian = Q("#ds-cartesian");

	let svg = SVG("svg");
	let svgg = SVG("g"); // this transforms everything inside it
	let svgXYAxes, svgXVal, svgYVal;
	let scale = 360/2; // 360 is the width & height of the cartesian space in px, 2 is the width & height of the cartesian space in normalized units (-1 to +1)
	svg.setAttributeNS(null, "width","360");
	svg.setAttributeNS(null, "height","360");
	svgg.setAttributeNS(null, "transform", `translate(180,180) scale(${scale},-${scale})`);

	svgXYAxes = SVG("path");
	svgXYAxes.attrsSVG({
		//d: "M-10000,0 L10000,0 M0,-10000 L0,10000",
		d: "M-1 0 L1 0 M0 -1 L0 1",
		stroke: `lightblue`,
		"stroke-width": `${1/scale}px`,
		fill: "none",
		"pointer-events": "none",
	});

	svgXVal = SVG("path");
	svgXVal.id = "svgXVal";
	svgXVal.attrsSVG({
		d: "M0 -1 L0 1",
		stroke: ui.designspace.colors[1],
		"stroke-width": `${1/scale}px`,
		fill: "none",
		"pointer-events": "none",
	});

	svgYVal = SVG("path");
	svgYVal.id = "svgYVal";
	svgYVal.attrsSVG({
		d: "M-1 0 L1 0",
		stroke: ui.designspace.colors[0],
		"stroke-width": `${1/scale}px`,
		fill: "none",
		"pointer-events": "none",
	});

	svgg.appendChild(svgXVal);
	svgg.appendChild(svgYVal);
	svgg.appendChild(svgXYAxes);
	svg.appendChild(svgg);

	cartesian.appendChild(svg);


	// draw some glyphs (at named instance locations)



	// capture mouse



	// consider 1d view

}

function updateGlyphsPanel(instance) {

	console.log("Updating glyphs panel");
	let font = GLOBAL.vf;

	///////////////////////////////////////////////////////
	// glyphs panel
	///////////////////////////////////////////////////////
	let panel = Q("#glyphs>div");
	panel.innerText = "";
	let scale = 0.05 * 1000 / font.unitsPerEm;

	for (let g=0; g < font.numGlyphs; g++) {

		let glyph = instance ? instance.glyphs[g] : font.glyphs[g];
		let glyphName;

		let glyphThumb = document.createElement("div");
		glyphThumb.classList.add("glyph-thumb");
		glyphThumb.setAttribute("id", `g-${g}`);

		if (glyph) {

			// simple glyph
			let svg = SVG("svg");
			let svgg = SVG("g");

			svg.setAttributeNS(null, "width","90");
			svg.setAttributeNS(null, "height","90");
			svgg.setAttributeNS(null, "transform", `translate(20,60) scale(${scale},-${scale})`);
			
			let paths = getGlyphSVGpath(glyph);
			if (!Array.isArray(paths)) { // composite
				paths = [paths];
			}
			paths.forEach((path, p) => {

				if (Array.isArray(path))
				{
					console.log("OH DEAR " + glyph.name);
				}

				let svgPath;
				let svgg3 = glyph.numContours == -1 ? SVG("g") : null; // wrap component paths in a g so they can be transformed
				svgPath = SVG("path"); // give this an id so we can detect clicks
				svgPath.attrsSVG({
					d: path,
					stroke: GLOBAL.vf.config.ui.glyphThumb.stroke,
					"stroke-width": `${GLOBAL.vf.config.ui.glyphThumb.strokeWidth}px`,
					fill: GLOBAL.vf.config.ui.glyphThumb.fill,
				});
				if (svgg3) {
					svgg3.setAttributeNS(null, "transform", `translate(${glyph.points[p][0]},${glyph.points[p][1]})`);
					svgg3.appendChild(svgPath);
					svgg.appendChild(svgg3);
				}
				else {
					svgg.id = `g${glyph.id}`;
					svgg.appendChild(svgPath);
				}
			});

			svg.appendChild(svgg);
			glyphThumb.appendChild(svg);

			glyphName = glyph.name;
		}
		else if (glyph && glyph.numContours < 0) {

			glyphName = glyph.name;

		}

		// set the label for the glyph thumb
		let label = document.createElement("label");
		label.innerText = glyphName ? glyphName : `#${g}`; // TODO: implement a toggle so we see glyph id when we want to

		// append the elements
		glyphThumb.appendChild(label);
		panel.appendChild(glyphThumb);
	}

	console.log("updateGlyphsPanel end");


	//let instance = font.addInstance(null, {tuple: GLOBAL.tuple});

	console.log(instance);
	setActiveGlyph(GLOBAL.currentGlyphId, instance);
	//font.instances.pop();

}

function setAxes (font, fvs) {
	

	let sliders = Qall(".slider");
	font.axes.forEach((axis, a) => {

		if (axis.min > axis.max)
			return;

		let val = fvs[axis.tag];
		if (val < axis.min)
			val = axis.min;
		if (val > axis.max)
			val = axis.max;

		sliders[a].value = (val - axis.min) / (axis.max - axis.min);
	});
}

function getActiveInstance (font) {

	let instance = null;
	Qall(".instance").forEach(el => {
		console.log(`checking instance`)
		if (el.classList.contains("active")) {
			console.log(`got instance`, el.data.instance)
			instance = el.data.instance;
		}
	});

	return instance;
}

function setActiveInstance (font, target) {

	Qall(".instance").forEach((el, i) => {

		let instance = font.instances[i]; // font.instances[0] is the default "instance"

		// update instance ui
		if (el == target || (!target && instance.type == "default")) { // allows for future reordering
			
			el.classList.add("active");
			setAxes (font, instance.fvs);
			instanceApplyVariations (font, instance);
			updateGlyphsPanel (instance);
			axesUpdateValues();
		}
		else {
			el.classList.remove("active");
			//target.data.selected = true;
		}
	});
}


function getActiveGlyph () {

	let g=0, el;
	if (el = Q(".glyph-thumb.active")) {
		let comps = el.id.split("-");
		g = 1*comps[1];
	}
	return g;

	// TODO: it would be simpler just to store the active glyph somewhere
	// return font.currentGlyphId;
}

function getArrowParams (x1, y1, x2, y2) {

	let arrow;
	let newX2, newY2;
	let len;
	const ui = GLOBAL.vf.config.ui;

	if (x2!=x1 || y2!=y1) {
		let tipWidth = ui.arrow.tipWidth * GLOBAL.vf.unitsPerEm/1000;
		let tipLength = ui.arrow.tipLength * GLOBAL.vf.unitsPerEm/1000;
		len = Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
		let arrowBackX = (y2-y1) * tipWidth/2/len;
		let arrowBackY = (x2-x1) * tipWidth/2/len;

		arrow = {
			newX2: newX2 = x1 + (x2-x1) * (len-tipLength)/len, // assignement helps 2 lines on
			newY2: newY2 = y1 + (y2-y1) * (len-tipLength)/len, // assignement helps 2 lines on
			arrowX1: newX2+arrowBackX,
			arrowY1: newY2-arrowBackY,
			arrowX2: newX2-arrowBackX,
			arrowY2: newY2+arrowBackY,
		};
	}
	return arrow;
}

function getSVGForShape (point, shape, size) {

	let svgEl;
	switch (shape) {
		// "■●▲+x"
		case "■":
			svgEl = SVG("rect");
			svgEl.attrsSVG({
				x: point[0]-size/2,
				y: point[1]-size/2,
				width: size,
				height: size,
			});
			break;

		case "●":
			svgEl = SVG("circle");
			svgEl.attrsSVG({
				cx: point[0],
				cy: point[1],
				r: size/2,
			});
			break;

		case "▲":
			svgEl = SVG("path");
			svgEl.attrsSVG({
				d: `M${point[0]} ${point[1]+size/2}L${point[0]+size/2*0.86602540378} ${point[1]-size/2*0.5}L${point[0]-size/2*0.86602540378} ${point[1]-size/2*0.5}Z`,
			});
			break;

		case "+":
			svgEl = SVG("path");
			svgEl.attrsSVG({
				d: `M${point[0]-size/2} ${point[1]}L${point[0]+size/2} ${point[1]}M${point[0]} ${point[1]-size/2}L${point[0]} ${point[1]+size/2}`,
			});
			break;

		case "x":
			svgEl = SVG("path");
			svgEl.attrsSVG({
				d: `M${point[0]-size/2} ${point[1]-size/2}L${point[0]+size/2} ${point[1]+size/2}M${point[0]-size/2} ${point[1]+size/2}L${point[0]+size/2} ${point[1]-size/2}`,
			});
			break;
	}

	return svgEl;
}


function setActiveGlyph (g, instance) {

	// instance may be undefined

	let font = GLOBAL.vf;
	let ui = font.config.ui;
	if (g === undefined)
		g = 0;
	g *= 1;

	GLOBAL.currentGlyphId = g; // hmm, should be part of the font, not GLOBAL … TODO: check g < numGlyphs
	let glyph = font.glyphs[g];

	// highlight active glyph thumbnail (first, unhighlight all of them)
	Qall(".glyph-thumb").forEach(el => {
		el.classList.remove("active");
	});
	Q(`#g-${g}`).classList.add("active");

	let iglyph = glyphApplyVariations(glyph, null, instance);
	if (instance) {
		GLOBAL.tuple = [];
		instance.tuple.forEach((v,i) => {
			GLOBAL.tuple[i] = v; // deep copy
		})
		//GLOBAL.tuple = instance.tuple; // hmm, shallow copy should be ok, because if won’t be garbage collected
	}

	// clear main window and tvts panel
	let drawing = Q("#drawing");
	drawing.innerHTML = "";


	///////////////////////////////////////////////////////
	// Tuples panel
	///////////////////////////////////////////////////////

	// TODO: we shouldn’t be doing all this for each glyph refresh
	let panel = Q("#tvts>div");
	panel.innerHTML = "";

	let layers = []; // layers are drawn from low values (bottom) to high values (top)


	let scale = 0.5 * 1000 / font.unitsPerEm;
	let opacity = 0.5;
	let svg = SVG("svg");
	let svgg = SVG("g"); // this transforms everything inside it
	//let svgDefs = SVG("defs")
	//let svgMarker = SVG("marker")
	//let svgMarkerPath = SVG("path")
	svg.attrsSVG( {
		width: 1000,
		height: 1000,
		style: `background-color: ${ui.glyphDefault.backgroundColor};`,
	});
	svgg.setAttributeNS(null, "transform", `translate(130,500) scale(${scale},-${scale})`);

	/*
	// define marker
	svgMarker.id = "arrow";
	svgMarker.attrsSVG({
		markerWidth: 20,
		markerHeight: 20,
		fill: ui.arrow.color,
		orient: "auto",
		refX: 10,
		refY: 5,
	});
	svgMarkerPath.setAttributeNS(null, "d", "M 10 5 L 3 2 L 3 8 z");
	svgMarker.appendChild(svgMarkerPath);
	svgDefs.appendChild(svgMarker);
	*/

	/*
	// filters to use... not yet :)
	// - https://developer.mozilla.org/en-US/docs/Web/SVG/Element/filter
	let svgFilter = SVG("filter");
	svgFilter.setAttributeNS(null, "id","blur");
	let svgFilterBlur = SVG("feGaussianBlur");
	svgFilterBlur.setAttributeNS(null, "stdDeviation","5");
	svgFilter.appendChild(svgFilterBlur);
	svgDefs.appendChild(svgFilter);
	*/

	//svg.appendChild(svgDefs);


	// TODO: we're not yet using the layer idea, but I think it will be useful to allow us to make minimal updates
	let layerIds = [];
	layerIds.push(0);
	layerIds.push(1);
	layerIds.push(2);
	if (ui.loci && ui.loci.strokeWidth)
		layerIds.push(7);
	layerIds.push(3);
	if (Q("#arrows-total").checked && ui.arrow.strokeWidth)
		layerIds.push(4);
	layerIds.push(5);
	if (Q("#arrows-split").checked && ui.arrow.strokeWidth)
		layerIds.push(6);

	layerIds.forEach(L => {

		let svgPath, svgg2, svgg3, paths;
		let layer = layers[L] = {
			on: true,
			svg: null,
		};
		let style = {
			size: 0,
			fill: "none",
			stroke: "none",
			strokeWidth: 0,
		};

		switch (L) {

			// cartesian axes, the grid
			case 0:
				layer.id = "layer-grid";
				svgPath = SVG("path");
				svgPath.id = layer.id;
				svgPath.attrsSVG({
					d: "M-10000,0 L10000,0 M0,-10000 L0,10000",
					stroke: ui.cartesianAxes.stroke,
					"stroke-width": ui.cartesianAxes.strokeWidth * font.unitsPerEm/1000,
					fill: "none",
				});
				svgg.appendChild(svgPath);

				break;


			// default
			case 1:
				layer.id = "layer-default";
				//svgPath = SVG("path");

				// draw glyph

				// we transform each component
				// - check each time we use getGlyphSVGpath()
				// - we take the translation from the glyph’s points property (which has been processed as usual by tvts)
				// - TODO: we’ll take the transformation matrix from the glyph’s components[p].transform
				// - must look up the order or processing: translate, transform or transform, translate (I recall that Apple and Microsoft differed on this)
				// - fonts using transforms are quite rare; Wingdings uses rotation and reflection in some ornaments
				// - https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform

				paths = getGlyphSVGpath(glyph);
				if (!Array.isArray(paths)) { // composite
					paths = [paths];
				}
				paths.forEach((path, p) => {
					svgg3 = glyph.numContours == -1 ? SVG("g") : null; // wrap component paths in a g
					svgPath = SVG("path"); // give this an id so we can detect clicks
					svgPath.attrsSVG({
						d: path,
						stroke: ui.glyphDefault.stroke,
						"stroke-width": ui.glyphDefault.strokeWidth * font.unitsPerEm/1000,
						fill: ui.glyphDefault.fill,
					});
					if (svgg3) {
						//svgg3.setAttributeNS(null, "transform", `translate(${iglyph.points[p][0]} ${iglyph.points[p][1]})`);
						// glyph.points[0] is the xy offset of the first component,
						// glyph.points[1] is the xy offset of the second component, etc.
						svgg3.setAttributeNS(null, "transform", `translate(${glyph.points[p][0]} ${glyph.points[p][1]})`);
						svgg3.appendChild(svgPath);
						svgg.appendChild(svgg3);
						svgg3.id = layer.id;
					}
					else {
						svgPath.id = layer.id;
						svgg.appendChild(svgPath);
					}
				});

				break;


			// instance
			case 2:
				layer.id = "layer-instance";

				// draw glyph with variations taken from the current axis settings
				// - should we render all active instances in this "layer"?
				/*
				svgPath = SVG("path");
				svgPath.attrsSVG({
					"style": `opacity:${opacity}`,
					"d": getGlyphSVGpath(iglyph),
					"stroke": `black`, // make this take a value from the ui confi
					"stroke-width": `${GLOBAL.vf.config.ui.glyph.strokeWidth}px`,
					"fill": `#00f`,
					// "filter": "url(#blur)", not yet :)					
				});
				*/

				paths = getGlyphSVGpath(iglyph);
				if (!Array.isArray(paths)) { // composite
					paths = [paths];
				}
				let uiStyle = ui.glyphCurrent;
				paths.forEach((path, p) => {
					svgg3 = iglyph.numContours == -1 ? SVG("g") : null; // wrap component paths in a g
					svgPath = SVG("path"); // give this an id so we can detect clicks
					svgPath.attrsSVG({
						d: path,
						style: `opacity: ${uiStyle.opacity}`,
						stroke: uiStyle.stroke,
						"stroke-width": uiStyle.strokeWidth * font.unitsPerEm/1000,
						fill: `${uiStyle.fill}`,
						// "filter": "url(#blur)", not yet :)					
					});
					if (svgg3) {
						//svgPath.id = `g${iglyph.id}-c${p}`; // "g27-c2" means component #2 of glyph #27
						svgg3.setAttributeNS(null, "transform", `translate(${iglyph.points[p][0]} ${iglyph.points[p][1]})`);
						svgg3.appendChild(svgPath);
						svgg.appendChild(svgg3);
						svgg3.id = layer.id;
					}
					else {
						//svgg3.id = `g${iglyph.id}`; // "g27" means glyph 27
						svgg.appendChild(svgPath);
						svgPath.id = layer.id;
					}
				});

				break;

/*

			case 3:
				// TODO: decide how to show "points" for composites… origin, so we see translations?
				layer.id = "layer-instance-points";
				svgg2 = SVG("g");
				svgg2.id = layer.id;

				iglyph.points.forEach(function (pt, p) {
					let size = ui.point.size;
					let svgP;
					if (pt[2]) {
						svgP = SVG("rect"); // on-curve
						svgP.classList.add("ctrl-pt");
						svgP.attrsSVG({
							x: pt[0]-size, y: pt[1]-size,
							width: 2*size, height: 2*size,
						});
					}
					else {
						svgP = SVG("circle"); // off-curve
						svgP.classList.add("ctrl-pt");
						svgP.attrsSVG({ cx: pt[0], cy: pt[1], r: 4 });
					}
					svgP.data = { point: pt };
					svgg2.appendChild(svgP);
				});

				svgg.appendChild(svgg2);
				break;
*/

			// arrows: total
			case 4:
				layer.id = "layer-arrows-total";

				svgg2 = SVG("g");
				svgg2.id = layer.id;
				svgg2.attrsSVG({
					"stroke": ui.arrow.color,
					"stroke-width": ui.arrow.strokeWidth * font.unitsPerEm/1000,
				});

				glyph.points.forEach((point1, pt) => {
					let point2 = iglyph.points[pt]; // transformed point
					let x1 = point1[0], y1 = point1[1], x2 = point2[0], y2 = point2[1];
					if (x1==x2 && y1==y2) {
						// same location so no line (now we can ignore divide-by-zero in the else{}
					}
					else {
						// get the arrow parameters so we can draw a truncated line (maybe dotted) plus arrow head
						let arrow = getArrowParams (x1, y1, x2, y2);
						let svgLine = SVG("line");
						let svgArrowHead = SVG("path");
						svgLine.attrsSVG({ x1: x1, y1: y1, x2: arrow.newX2, y2: arrow.newY2 });
						svgArrowHead.attrsSVG({
							d: `M${x2} ${y2}L${arrow.arrowX1} ${arrow.arrowY1}L${arrow.arrowX2} ${arrow.arrowY2}Z`,
							fill: ui.arrow.color,
							stroke: "none",
						});

						if (!iglyph.touched[pt]) {
							svgLine.attrsSVG({ "stroke-dasharray": 4 * font.unitsPerEm/1000 }); // IUP implicit movement
						}

						svgg2.appendChild(svgLine);
						svgg2.appendChild(svgArrowHead);

					}
				});										

				svgg.appendChild(svgg2);
				break;


			// control points
			case 3:
			case 5:
				// draw control points, grouped in their own <g>
				if (L==3)
					layer.id = "layer-instance-points";
				else if (L==5)
					layer.id = "layer-points";
				else
					layer.id = "layer-invalid";

				// set style, with overrides
				Object.keys(ui.point).forEach(k => {
					style[k] = ui.point[k];
				});
				if (L==3 && ui.glyphCurrent.point)
					Object.keys(ui.glyphCurrent.point).forEach(k => {
						style[k] = ui.glyphCurrent.point[k];
					});
				else if (L==5 && ui.glyphDefault.point)
					Object.keys(ui.glyphDefault.point).forEach(k => {
						style[k] = ui.glyphDefault.point[k];
					});

				// only draw if they’re wanted
				if (style.size > 0) {				
					
					// create group element
					svgg2 = SVG("g");
					svgg2.id = layer.id;

					// set attrs
					svgg2.attrsSVG({
						fill: style.fill,
						"stroke-width": style.strokeWidth * font.unitsPerEm/1000,
						stroke: style.stroke,
						opacity: style.opacity,
					});

					// draw the points
					(L==3 ? iglyph : glyph).points.forEach(function (pt, p) {
						let svgEl = getSVGForShape (
							pt,
							pt[2] ? style.shape : style.shapeOffCurve,
							style.size * font.unitsPerEm/1000);
						svgg2.appendChild(svgEl);
					});

					svgg.appendChild(svgg2);
				}
				break;


			// arrows: split
			case 6:

				layer.id = "layer-arrows-split";
				svgg2 = SVG("g");
				svgg2.id = layer.id;
				svgg2.attrsSVG({
					"fill": "none",
					"stroke-width": 3,
					"stroke": "green",
				});

				glyph.points.forEach((point1, pt) => {
					//let point2 = iglyph.points[pt]; // transformed point

					// TODO: handle movements for IUP points

					let x1 = point1[0], y1 = point1[1];
					let x2, y2;
					glyph.tvts.forEach((tvt, t) => {
						let sValue = iglyph.tvtsVisualization[t].S;
						let delta = tvt.deltas[pt];
						let lineColor = ui.tuple.colors[t % ui.tuple.colors.length]; // get the t’th colour in the array, wrapping round to the start when we run out of colours

						let svgLine = SVG("line");
						let svgArrowHead = SVG("path");

						if (delta === null) { // IUP
							x2 = x1 + iglyph.tvtsVisualization[t].scaledDeltas[pt][0];
							y2 = y1 + iglyph.tvtsVisualization[t].scaledDeltas[pt][1];
							svgLine.attrsSVG({ "stroke-dasharray": "4" });
						}
						else {							
							x2 = x1 + delta[0] * sValue;
							y2 = y1 + delta[1] * sValue;
						}

						let arrow = getArrowParams (x1, y1, x2, y2);
						if (x2!=x1 || y2!=y1) {

							svgLine.attrsSVG({
								x1: x1, y1: y1, x2: arrow.newX2, y2: arrow.newY2,
								stroke: lineColor,
								"stroke-width": ui.arrow.strokeWidth * font.unitsPerEm/1000,
							});

							svgArrowHead.attrsSVG({
								d: `M${x2} ${y2}L${arrow.arrowX1} ${arrow.arrowY1}L${arrow.arrowX2} ${arrow.arrowY2}Z`,
								fill: lineColor,
								stroke: "none",
							});

							svgg2.appendChild(svgLine);
							svgg2.appendChild(svgArrowHead);
						}

						x1 = x2;
						y1 = y2;
					});
				});

				svgg.appendChild(svgg2);
				break;


			// loci
			case 7: 
				layer.id = "layer-loci";
				const steps = ui.loci.steps; // we will make steps+1 instances
				let lociX = [], lociY = []; // one for each point

				svgg2 = SVG("g");
				svgg2.id = layer.id + "-X";
				svgg2.attrsSVG({
					"fill": "none",
				});

				// trace X loci from -1 to 1
				// TODO: force inclusion of default location and all axis peaks
				for (let s=0; s<steps; s++) {

					let lociInstanceX, lociInstanceY, iglyphX, iglyphY;
					let T = -1.0 + s/(steps-1) * 2.0;

					// initialize tuple
					let tupleX = [], tupleY = [];
					for (let a=0; a < font.axes.length; a++) {
						tupleX[a] = tupleY[a] = GLOBAL.tuple[a];
					}

					// check which tuple values are non-default
					// - what VF axes are attached to the X and Y axes?
					Qall("#xSelect input:checked").forEach(el => {
						font.axisIndices(el.value).forEach(i => tupleX[i] = T );
					});
					Qall("#ySelect input:checked").forEach(el => {
						font.axisIndices(el.value).forEach(i => tupleY[i] = T );
					});
					
					// make instance
					lociInstanceX = font.addInstance(null, {tuple: tupleX});
					lociInstanceY = font.addInstance(null, {tuple: tupleY});
					iglyphX = glyphApplyVariations(glyph, null, lociInstanceX, {roundDeltas: false});
					iglyphY = glyphApplyVariations(glyph, null, lociInstanceY, {roundDeltas: false});

					// build the SVG polylines in parallel
					for (let p=0; p<glyph.points.length; p++) {
						if (s==0) {
							lociX[p] = "";
							lociY[p] = "";
						}
						else {
							lociX[p] += " ";
							lociY[p] += " ";
						}
						lociX[p] += `${iglyphX.points[p][0]},${iglyphX.points[p][1]}`;
						lociY[p] += `${iglyphY.points[p][0]},${iglyphY.points[p][1]}`;
					}

					// pop instances
					font.instances.pop();
					font.instances.pop();
				}

				// create the SVG element, one set of elements per point
				for (let p=0; p<glyph.points.length; p++) {

					[lociX, lociY].forEach(LOCI => {

						let svgPolyline;

						// draw initial polyline
						svgPolyline = SVG("polyline");
						svgPolyline.attrsSVG({
							points: LOCI[p],
							stroke: LOCI===lociX ? ui.designspace.colors[0] : ui.designspace.colors[1],
							"stroke-width": ui.loci.strokeWidth * font.unitsPerEm/1000,
							opacity: ui.loci.opacity,
						});
						svgg2.appendChild(svgPolyline);

						// if railway mode, draw extra lines
						if (ui.loci.style == "railway") {

							svgPolyline = SVG("polyline");
							svgPolyline.attrsSVG({
								points: LOCI[p],
								stroke: "white",
								"stroke-width": ui.loci.strokeWidth / 1.5 * font.unitsPerEm/1000,
							});
							svgg2.appendChild(svgPolyline);

							svgPolyline = SVG("polyline");
							svgPolyline.attrsSVG({
								points: LOCI[p],
								stroke: LOCI===lociX ? ui.designspace.colors[0] : ui.designspace.colors[1],
								"stroke-width": ui.loci.strokeWidth * 1.5 * font.unitsPerEm/1000,
								"stroke-dasharray": "1 5",
							});
							svgg2.appendChild(svgPolyline);
						}

					});

				}

				svgg.appendChild(svgg2);
				break;
		}


		// add layer to the view
		layer.svg = svg;

	});


	svg.appendChild(svgg);
	drawing.appendChild(svg);

	// drawing layers
	// - coordinate grid
	// - default glyph (options: control points)
	// - transformed glyph (options: control points, arrows, per-tuple arrows)
	// - point loci
	// each layer can be on/off


	// default glyph



	// display the tvts

	glyph.tvts.forEach((tvt, t) => {

		// header row
		if (t==0) {
			let liH = document.createElement("li");
			liH.style.display = "grid";
			liH.style.gridTemplateColumns = `1.5em 80px 45px repeat(${GLOBAL.vf.axisCount}, 45px)`
			liH.innerHTML = `<label>TVT</label><label>IUP</label><label>Scalar</label>`;
			GLOBAL.vf.axes.forEach(axis => {
				liH.innerHTML += `<label style="width:100%; text-align:center;"><tt>${axis.tag}</tt></label>`;
			});
			
			panel.appendChild(liH);
		}

		let li = document.createElement("li");
		li.classList.add("tvt");

		// we mention some stuff about tvt id, then numpoints moved or something, then (aligning with axes in instance panel) an SVG graph for each axis
		li.style.display = "grid";
		li.style.gridTemplateColumns = `1.5em 80px 45px repeat(${GLOBAL.vf.axisCount}, 45px)`
		li.style.backgroundColor = "lightgrey";
		li.style.height = "20px";

		let tvtId = document.createElement("div");
		tvtId.innerText = t;
		tvtId.style.backgroundColor = ui.tuple.colors[t % ui.tuple.colors.length];
		tvtId.style.color = "white";
		tvtId.style.fontWeight = "bold";
		tvtId.style.textAlign = "center";

		let tvtDeltas = document.createElement("div");
		let numDeltas = 0;
		for (let p=0; p<tvt.deltas.length; p++) {
			if (tvt.deltas[p] !== null)
				numDeltas++;
		}
		tvtDeltas.innerText = `${tvt.deltas.length-numDeltas}`;
		tvtDeltas.setAttribute("title", `This tuple variation moves ${tvt.deltas.length-numDeltas} points via IUP.`);

		// draw S value as bar graph
		let sValue = iglyph.tvtsVisualization[t].S;
		let tvtS = document.createElement("div");
		let vizWidth = Math.max(0.25, 40 * sValue); // minimum of 0.25px
		tvtS.setAttribute("title", sValue);
		if (sValue > 0) {
			tvtS.setAttribute("style", `width: ${vizWidth}px; height: 20px; background-color: ${ui.tupleScalar.fill};`);
			li.style.backgroundColor = "white";
		}

		li.appendChild(tvtId);
		li.appendChild(tvtDeltas);
		li.appendChild(tvtS);


		// add a graph for each axis
		// - each graph is a single SVG element with descendants
		// - each tuple contains <font.numAxes> graphs representing how this tuple responds to each axis
		for (let a=0; a<GLOBAL.vf.axisCount; a++) {
			let tvtGraphEl = document.createElement("div");
			let tvtGraph = SVG("svg");
			let svgg = SVG("g");

			tvtGraph.setAttributeNS(null, "width","50");
			tvtGraph.setAttributeNS(null, "height","21");
			svgg.setAttributeNS(null, "transform", `translate(20,20) scale(1,-1)`);


			// draw a graph through start, peak, end for each axis
			let Sx = 20, Sy = 20; // x and y scales

			// draw graph paper
			let pathG = SVG("path");
			//let pathD = pathD = `M ${Sx*-1},0 L ${Sx*tvt.start[a]},0 L ${Sx*tvt.peak[a]},${Sy} L ${Sx*tvt.end[a]},0`;
			pathG.setAttributeNS(null, "fill", "none");
			pathG.setAttributeNS(null, "stroke", "darkgrey");
			pathG.setAttributeNS(null, "stroke-width", "0.5");
			pathG.setAttributeNS(null, "d", `M ${Sx*-1} 0 L ${Sx*1} 0 M 0 0 L 0 ${Sy*1}`);
			svgg.appendChild(pathG);

			// draw tuple start, peak, end data
			if (tvt.peak[a] != 0) { // “When a delta is provided for a region defined by n-tuples that have a peak value of 0 for some axis, then that axis does not factor into scalar calculations.”
				// typicaly graphs are shown at https://docs.microsoft.com/en-us/typography/opentype/spec/otvaroverview
				let path = SVG("path");
				let pathD = `M ${Sx*tvt.start[a]},0 L ${Sx*tvt.peak[a]},${Sy*1.0} L ${Sx*tvt.end[a]},0`;
				path.setAttributeNS(null, "fill", "black");
				path.setAttributeNS(null, "stroke", "none");
				path.setAttributeNS(null, "d", pathD);
				svgg.appendChild(path);

				// draw current axis position
				if (iglyph.instance && iglyph.instance.tuple[a] != 0) {
					let needle = SVG("line");
					let needleColor = ui.tupleNeedle.stroke;
					needle.attrsSVG({fill: "none", stroke: needleColor, "stroke-width": "1px", x1: iglyph.instance.tuple[a]*20, y1: 0, x2: iglyph.instance.tuple[a]*20, y2: 20});
					svgg.appendChild(needle);
				}
			}

			tvtGraph.appendChild(svgg);
			tvtGraphEl.appendChild(tvtGraph);

			tvtGraphEl.style.textAlign = "right";
			li.appendChild(tvtGraphEl);
		}
		
		panel.appendChild(li);

		// display the actual deltas for this tuple
		tvtDeltas.addEventListener("click", function (event) {
			let str = "";
			tvt.deltas.forEach((delta, p) => {
				str += `${p}: `;
				if (delta === null)
					str += "—";
				else
					str += `${Math.round(sValue*delta[0])},${Math.round(sValue*delta[1])}`;
				str += "\n";
			});
			alert (str);
		});

	});

}


function playGlyphs() {
	let g = (getActiveGlyph()+1) % GLOBAL.vf.numGlyphs;
	let instance = GLOBAL.vf.addInstance(null, {tuple: GLOBAL.tuple});
	setActiveGlyph (g, instance);
	GLOBAL.vf.instances.pop();
	GLOBAL.vf.timerGlyphPlayer = setTimeout (playGlyphs, 500);
}


// click handlers for all clicks
document.onclick = function (event) {

	//console.log(event.target);
	// about target
	// - via the method of assignment in the if(), target gets the desired element rather than a child (or grandchild) that in fact received the event
	// - the closest(x) method is great: we find whether event.target happened on something within something selected by x
	// - order matters! (e.g. an icon within an instance row must be handled before the instance row itself)
	let target;
	let font = GLOBAL.vf;

	//console.log(event.target.classList);


	if (event.target == Q("#font-file")) {
	//if (target = event.target.closest("#font-file")) {
		// debug hack to load MutatorSans easily
		Q("body").style.cursor = "wait";

		let vf = new SamsaVF({

			fontFamily: "FontNameShouldGoHere",
			url: "fonts/MutatorSans.ttf",
			callback: vfLoaded,
		});
	}

	// else if (event.target.id == "dsAxesMultiple") {
	// 	updateDesignspace();
	// }

	else if (target = event.target.closest("#controls .panel .instantiate")) {

		// create and download the instance		
		let instanceEl = target.closest(".instance");
		let instance = instanceEl.data.instance;

		GLOBAL.vf.makeInstance(instance); // creates instance.static

		//window.open (`data:font/ttf;base64,${uint8ToBase64(instance.static)}`, "_blank"); // this method wasn’t great

		let fauxLink = document.createElement("a");
		fauxLink.download = GLOBAL.vf.filename;
		fauxLink.href = "data:font/ttf;base64," + uint8ToBase64(instance.static);

		//let str = btoa(instance.static)
		//console.log (typeof str);
		//console.log (str);
		//fauxLink.href = "data:font/ttf;base64," + str;
		document.body.appendChild(fauxLink); // needed for Firefox, not Chrome or Safari
		fauxLink.click();
		fauxLink.remove();

	}

	else if (target = event.target.closest(".instance")) {

		setActiveInstance(GLOBAL.vf, target);
	}

	else if (target = event.target.closest("#axes .header .icon")) {

		let fvs = {}, redraw = true;
		if (target.classList.contains("default")) {
			GLOBAL.vf.axes.forEach((axis,a) => {
				fvs[axis.tag] = axis.default;
			});
		}
		else if (target.classList.contains("min")) {
			GLOBAL.vf.axes.forEach((axis,a) => {
				fvs[axis.tag] = axis.min;
			});
		}
		else if (target.classList.contains("max")) {
			GLOBAL.vf.axes.forEach((axis,a) => {
				fvs[axis.tag] = axis.max;
			});
		}
		else
			redraw = false;

		if (redraw) {		
			GLOBAL.tuple = GLOBAL.vf.fvsToTuple(fvs);
			let instance = font.addInstance(null, {tuple: GLOBAL.tuple});
			setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
			font.instances.pop();
			axesUpdateValues();
			setAxes (GLOBAL.vf, fvs);
		}
	}

	else if (event.target.classList.contains("ctrl-pt")) {
		console.log("click pt", event.target);
		console.log(event.target.data.point);
	}

	else if (target = event.target.closest("#glyphs>h2") 
			&& event.target.classList.contains("icon")
			&& !event.target.classList.contains("reveal")) { // this test must be before the other h2 test

		let g;
		let step = false;
		clearTimeout(font.timerGlyphPlayer);
		
		switch (event.target.id) {

			case "glyphs-stepforward":
				g = getActiveGlyph()+1;
				step = true;
				break;
			case "glyphs-stepback":
				g = getActiveGlyph()-1+font.numGlyphs;
				step = true;
				break;
			case "glyphs-play":
				playGlyphs();
				break;
			case "glyphs-stop":
				clearTimeout(font.timerGlyphPlayer);
				font.timerGlyphPlayer = undefined;
				break;
		}

		if (step) {
			let instance = font.addInstance(null, {tuple: GLOBAL.tuple});
			g %= font.numGlyphs;
			clearTimeout(font.timerGlyphPlayer);
			setActiveGlyph (g, instance);
			font.instances.pop();
		}

		// let glyph = font.glyphs[GLOBAL.currentGlyphId];
		// let iglyph = glyphApplyVariations(glyph, null, instance);
		// setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG

	}

	else if (target = event.target.closest("#controls .panel>h2")) {
		// toggle display of panel when panel header is clicked
		let panelDiv = target.parentNode.querySelector("div");
		panelDiv.parentNode.classList.toggle("open");
		if (panelDiv.parentNode.classList.contains("open"))
			panelDiv.style.display = "block";
		else
			panelDiv.style.display = "none";
	}

	else if (target = event.target.closest(".glyph-thumb")) {

		let comps = target.id.split("-");
		let g = comps[1];

		let instance = font.addInstance(null, {tuple: GLOBAL.tuple});
		setActiveGlyph(g, instance);
		font.instances.pop();

	}

	else if (target = event.target.closest("#font-list .font-file")) {

		// load font mutator

		let vf = new SamsaVF({

			fontFamily: "FontNameShouldGoHere",
			url: `fonts/${target.innerText}`,
			callback: vfLoaded,
		});

		return false;
	}

	//return false;

}

function dropHandler(ev) {

// https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/File_drag_and_drop
  // Prevent default behavior (Prevent file from being opened)
  //alert ('File(s) dropped');
  ev.preventDefault();

  if (ev.dataTransfer.items) {
    // Use DataTransferItemList interface to access the file(s)

    for (var i = 0; i < 1 /* ev.dataTransfer.items.length */ ; i++) { // limit to processing of first file dropped

      // If dropped items aren't files, reject them
      if (ev.dataTransfer.items[i].kind === 'file') {
        var file = ev.dataTransfer.items[i].getAsFile();
        let reader = new FileReader();
        reader.__file__ = file;
        reader.onload = function (event) {

			//console.log (event.target.result);
			//console.log (event.target);
			console.log(this.__file__.size)
			let vf = new SamsaVF({

				arrayBuffer: event.target.result,
				inFile: this.__file__.name,
				filesize: this.__file__.size,
				date: this.__file__.lastModified,  // doesn't retrieve the real file date
				callback: vfLoaded,
			});
		};
		reader.readAsArrayBuffer(file); // https://stackoverflow.com/questions/22659164/read-a-drag-and-dropped-file
      }
    }
  }
}

Q("#font-file").addEventListener("drop", dropHandler);
Q("#font-file").addEventListener("dragover",function(e){
	e = e || event;
	e.preventDefault();
},false);



function SVG(tag) {

    return document.createElementNS('http://www.w3.org/2000/svg', tag);
}




// method to attach multiple SVG attributes at once
// - example of attrs: { d: path, stroke: "black", "stroke-width": "2px", fill: "#eee" }
// - TODO: this is really nasty, we should only apply it to SVG objects

/*Object.prototype.attrsSVG = function (attrs) {
	for (const prop in attrs) {
		this.setAttributeNS(null, prop, attrs[prop]);
	}
}
*/

//let tempSVG = document.createElementNS('http://www.w3.org/2000/svg', "SVG");
/*
document.createElementNS.prototype.attrsSVG = function (attrs) {
	for (const prop in attrs) {
		this.setAttributeNS(null, prop, attrs[prop]);
	}
};
*/
SVGElement.prototype.attrsSVG = function (attrs) {
	for (const prop in attrs) {
		this.setAttributeNS(null, prop, attrs[prop]);
	}
};



function getArrowPathForLine(x1, y1, x2, y2, width, arrowLength, arrowWidth) {
	// returns a string suitable for use as the SVG path "d" attribute
	// it solves two problem of SVG lines when used with a pointed arrow:
	// 1. the line is printed on top of the arrow-head, making the tip blunt
	// 2. markers have colour in themselves, which is not useful when each line needs a custom colour

	// for a line pointing due east, we start at the bottom left corner and go anticlockwise
	// - Hmmm, this won’t work with dash-array for dotted lines

/*
	if (x1==x2 && y1==y2)
		return "M0 0Z";

	let path = `M${x1} ${y1}`;
	let angle = Math.atan2(y2-y1, x2-x1);
	let len = Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
	let anglePerp = angle - Math.PI;
	let xn = (x2-x1)/len;
	let yn = (y2-y1)/len;
	let c = y2-y1, x2-x1
	path += `l${yn*width/2} ${xn*width/2}`;
	path += `l${x2-x1-arrowLength*xn} ${y2-y1-arrowLength*yn}`;
	path += `l${yn*(arrowWidth-width)/2} ${xn*(arrowWidth-width)/2}`;
	path += `L${x1} ${y2}`; // now we are at the tip
	//path += `l${yn*(arrowWidth-width)/2} ${xn*(arrowWidth-width)/2}`;`;
	//path += `l`;
	//path += `l`;
	path += "z";
*/
	return path;
}



// load font list
// - only if we are in http: or https: (it’s not supported in file:)
// - TODO: switch to modern fetch(url)
if (["http:", "https:"].includes(window.location.protocol)) {

	let oReq = new XMLHttpRequest();
	oReq.open("GET", "fonts/_fontlist_.json", true);
	oReq.responseType = "json";
	oReq.onload = function(oEvent) {
		GLOBAL.fontList = this.response;
		// TODO: handle onreadystatechange to detect errors
		let panel = Q("#font-list>div");
		panel.innerHTML = "";
		GLOBAL.fontList.forEach(fontFilename => {
			panel.innerHTML += `<li class="font-file"><a href="">${fontFilename}</a></li>`;
		});
	};
	oReq.send();
}
else {
	let panel = Q("#font-list>div");
	panel.innerHTML = `<div>Remote file loading is not available for protocol “${window.location.protocol}”</div>`;
}


document.addEventListener("keydown", e => {

	if (e.key == " ") {

	}

});


</script>


</body>
</html>