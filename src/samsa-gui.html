
<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="utf-8">
<title>Samsa: Variable Font Inspector</title>

<script src="samsa-core.js"></script>

<link rel = "stylesheet" type = "text/css" href = "samsa-gui.css" />
</head>

<body>

<div id="container">

<div id="title"><h1>Samsa</h1>
	<div class="subtitle">
		variable font inspector<br>
		<a href="https://github.com/Lorp/samsa" title="Samsa on GitHub"><img width="15" height="15" src="images/GitHub-Mark-64px.svg"></a>
	</div>
	<div class="subtitle"></div>
</div>

<div id="drag-drop-zone" style="position: relative;">
	<div>
		<h1>Drop a variable font here</h1>
		<p style="text-decoration: underline;">or click to select a variable font from your computer</p>
		<p>or choose from the list of variable fonts on the left</p>
	</div>
	<input id="file-upload-input" type="file" style="position: absolute; left: 0; top: 0; opacity: 0.0; width: 100%; height: 100%;">
</div>

<div id="font-file" class="inactive" style="display:none;">
	<!-- &lt;drop a variable font here&gt; -->
</div>

<div id="controls">

	<div id="panel-info" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Info</h2>
		<div class="panel-content"></div>
	</div>

	<div id="panel-ui" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> UI</h2>
		<div class="panel-content"></div>
	</div>

	<div id="panel-webfont" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Webfont</h2>
		<div class="panel-content"></div>
	</div>

	<div id="panel-axes" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Axes</h2>
		<div class="panel-content"></div>
	</div>

	<div id="panel-stat" class="panel closed">
		<h2><span class="icon bold reveal">&#xf04b;</span> STAT</h2>
		<div class="panel-content"></div>
	</div>

	<div id="panel-instances" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Instances
			<!--
			<span class="icon" id="instances-as-grid">&#xf00a;</span>
			<span class="icon" id="instances-as-list">&#xf0c9;</span>
			-->
		</h2>
		<div class="panel-content"></div>
	</div>

	<div id="panel-tvts" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Delta sets</h2>
		<div class="panel-content" style="overflow-x: scroll;"></div>
	</div>

	<div id="panel-designspace" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Designspace</h2>
		<div class="panel-content"></div>
	</div>

	<div id="panel-glyphs" class="panel open">
		<h2><span class="icon bold reveal open">&#xf04b;</span> Glyphs
			<!-- <span class="icon bold" id="glyphs-rewind">&#xf04a;</span> -->
			<span class="icon bold" id="glyphs-stepback" title="Step back">&#xf048;</span>
			<span class="icon bold" id="glyphs-stop" title="Stop playing">&#xf04d;</span>
			<span class="icon bold" id="glyphs-play" title="Play">&#xf04b;</span>
			<span class="icon bold" id="glyphs-stepforward" title="Step forward">&#xf051;</span>
			<span class="texticon" id="glyphs-ids" title="Glyph IDs">123</span>
			<!-- <span class="icon bold" id="glyphs-fastforward">&#xf04e;</span> -->
		</h2>
		<div class="panel-content"></div>
	<br clear="all">

	</div>

	<div id="panel-font-list" class="panel open">
		<h2><span class="icon bold reveal open">&#xf04b;</span> Fonts ready to load</h2>
		<div class="panel-content"></div>
	</div>

	<div id="panel-media" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Media</h2>
		<div class="panel-content"></div>
	</div>

	<div id="panel-about" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> About</h2>
		<div class="panel-content" style="padding: 0.5em; font-size: 75%;">
			Samsa is developed by Laurence Penney 2017–present. In 2019 Google Fonts funded major improvements and libre licensing.
			<ul>
			<li><a href="https://github.com/Lorp/samsa">GitHub repository</a></li>
			<li><a href="https://www.axis-praxis.org/samsa/">Samsa</a> (hosted at Axis-Praxis)</li>
			<li><a href="https://lorp.github.io/samsa/src/samsa-gui.html">Samsa</a> (hosted on GitHub)</li>
			<li><a href="https://twitter.com/axis_praxis">@axis_praxis</a> updates via Twitter</li>
			</ul>
		</div>
	</div>

</div>

<div id="drawing" style="display:none;"></div>

</div>


<script>


let GLOBAL = {
	vf: null, // maybe allow an array of fonts... select them with a drop down in info panel
	currentGlyphId: null,
	fontList: [],
};

CONFIG.visualization = true;
CONFIG.uiModes = {

	light: {
		name: "light",

		cartesianAxes: {
			stroke: "#31b8e7",
			strokeWidth: 1,
		},

		metrics: {
			stroke: "#31b8e7",
			strokeWidth: 1,
			dashArray: [3,3],
		},

		arrow: {
			strokeWidth: 3,
			tipLength: 20,
			tipWidth: 15,
			color: "#0044ee",
		},

		designspace: {
			colors: ["blue", "red"],
		},

		tuple: {
			colors: ["#f57670", "#c39921","#57b21f","#1ebf95","#1fb7e9","#a58efc","#f966d5"], // "ggplot2 hue" palette from https://serialmentor.com/dataviz/color-basics.html
		},

		tupleNeedle: {
			stroke: "red",
		},

		tupleScalar: {
			fill: "black",
		},

		point: {
			size: 10,
			shape: "■", // one of ■●▲+x
			shapeOffCurve: "●",
			opacity: 1,
		},

		pointNumbers: {
			angle: 90,
			offset: 10,
		},

		glyphDefault: {
			fill: "#ddd",
			stroke: "none",
			strokeWidth: 0,
			backgroundColor: "transparent",
			point: {
				stroke: "#888",
				strokeWidth: 3,
				fill: "none",
				shape: "+",
				shapeOffCurve: "+",
			},
		},

		glyphCurrent: {
			fill: "none",
			stroke: "black",
			strokeWidth: 2,
			opacity: 1,
			point: {
				size: 15,
				strokeWidth: 0,
				fill: "blue",
				opacity: 0.7,
			},
		},

		glyphThumb: {
			fill: "black",
			stroke: "none",
			strokeWidth: 0,
		},

		text: {
			font: "IBM Plex",
			size: 18,
		},

		label: {
			font: "IBM Plex",
			size: 12,
		},
	},


	dark: {
		name: "dark",

		cartesianAxes: {
			stroke: "lightblue",
			strokeWidth: 1,
		},

		metrics: {
			stroke: "#31b8e7",
			strokeWidth: 1,
			dashArray: [3,3],
		},

		arrow: {
			strokeWidth: 3,
			tipLength: 20,
			tipWidth: 15,
			//color: "#0044ee",
			color: "orange",
		},

		designspace: {
			colors: ["blue", "red"],
		},

		tuple: {
			//colors: ["#269d78", "#d7601c","#7571b1","#e5318a","#68a42c","#e5aa27","#a57528"], // "ColorBrewer Dark2" palette from https://serialmentor.com/dataviz/color-basics.html
			colors: ["#f57670", "#c39921","#57b21f","#1ebf95","#1fb7e9","#a58efc","#f966d5"], // "ggplot2 hue" palette from https://serialmentor.com/dataviz/color-basics.html
		},

		tupleNeedle: {
			stroke: "red",
		},

		tupleScalar: {
			fill: "black",
		},

		point: {
			size: 7,
			shape: "+",
			shapeOffCurve: "+",
			stroke: "yellow",
			strokeWidth: 2,
		},

		pointNumbers: {
			angle: 90,
			offset: 10,
			color: "blue",
		},

		glyphDefault: {
			fill: "#555",
			stroke: "none",
			strokeWidth: 0,
			backgroundColor: "black",
		},

		glyphCurrent: {
			fill: "white",
			strokeWidth: 2,
			opacity: 0.8,
			point: {
				size: 17,
				fill: "blue",
				stroke: "none",
				opacity: 0.7,
				shape: "■", // one of ⯅●■
				shapeOffCurve: "●", // ⯅●■
			}
		},

		glyphThumb: {
			fill: "black",
			stroke: "none",
			strokeWidth: 0,
		},

		// ?better as CSS, so we can add italic, weight, border, background-color etc?
		text: {
			font: "IBM Plex",
			size: 18,
		},

		label: {
			font: "IBM Plex",
			size: 12,
		},
	},

	loci: {
		name: "loci",

		cartesianAxes: {
			stroke: "#31b8e7",
			strokeWidth: 1,
		},

		metrics: {
			stroke: "#31b8e7",
			strokeWidth: 1,
			dashArray: [3,3],
		},

		arrow: {
			strokeWidth: 0,
		},

		designspace: {
			colors: ["royalblue", "crimson"],
		},

		tuple: {
			colors: ["#f57670", "#c39921","#57b21f","#1ebf95","#1fb7e9","#a58efc","#f966d5"], // "ggplot2 hue" palette from https://serialmentor.com/dataviz/color-basics.html
		},

		tupleNeedle: {
			stroke: "red",
		},

		tupleScalar: {
			fill: "black",
		},

		loci: {
			steps: 40,
			strokeWidth: 6,
			style: "railway", // "railway" or "line"
			opacity: 0.7,
		},

		point: {
			size: 10,
			shape: "●", // one of ■●▲+x
			shapeOffCurve: "●",
			opacity: 1,
		},		

		pointNumbers: {
			angle: 90,
			offset: 10,
		},

		glyphDefault: {
			fill: "none",
			stroke: "none",
			strokeWidth: 0,
			backgroundColor: "transparent",
			point: {
				stroke: "#888",
				strokeWidth: 0,
				fill: "none",
				shape: "+",
				shapeOffCurve: "+",
			},
		},

		glyphCurrent: {
			fill: "none",
			stroke: "#aaa",
			strokeWidth: 2,
			opacity: 1,
			point: {
				size: 15,
				strokeWidth: 0,
				fill: "green",
				opacity: 0.75,
			},
		},

		glyphThumb: {
			fill: "black",
			stroke: "none",
			strokeWidth: 0,
		},

		text: {
			font: "IBM Plex",
			size: 18,
		},

		label: {
			font: "IBM Plex",
			size: 12,
		},
	},

	preview: {
		name: "preview",

		cartesianAxes: {
			stroke: "none",
			strokeWidth: 0,
		},

		metrics: {
			stroke: "none",
			strokeWidth: 0,
		},

		arrow: {
			strokeWidth: 0,
			tipLength: 0,
			tipWidth: 0,
			color: "transparent",
		},

		designspace: {
			colors: ["blue", "red"],
		},

		tuple: {
			colors: ["#f57670", "#c39921","#57b21f","#1ebf95","#1fb7e9","#a58efc","#f966d5"], // "ggplot2 hue" palette from https://serialmentor.com/dataviz/color-basics.html
		},

		tupleNeedle: {
			stroke: "red",
		},

		tupleScalar: {
			fill: "black",
		},

		point: {
			size: 0, // disable points
		},		

		pointNumbers: {},

		glyphDefault: {
			fill: "none", // disable the default glyph
			stroke: "none",
			strokeWidth: 0,
			backgroundColor: "white",
		},

		glyphCurrent: {
			fill: "black",
			stroke: "none",
			opacity: 1,
		},

		glyphThumb: {
			fill: "black",
			stroke: "none",
			strokeWidth: 0,
		},

		text: {
			font: "IBM Plex",
			size: 18,
		},

		label: {
			font: "IBM Plex",
			size: 12,
		},
	},
}

CONFIG.ui = CONFIG.uiModes["light"];

CONFIG.docs = {
	axes: {
		wght: "regex:microsoft",
		wdth: "regex:microsoft",
		opsz: "regex:microsoft",
		ital: "regex:microsoft",
		slnt: "regex:microsoft",
		xtra: "regex:typenetwork",
		xopq: "regex:typenetwork",
		ytra: "regex:typenetwork",
		yopq: "regex:typenetwork",
		ytlc: "regex:typenetwork",
		ytuc: "regex:typenetwork",
		ytde: "regex:typenetwork",
		ytas: "regex:typenetwork",
		xtab: "regex:typenetwork",
		vrot: "regex:typenetwork",
		udln: "regex:typenetwork",
		shdw: "regex:typenetwork",
		refl: "regex:typenetwork",
		otln: "regex:typenetwork",
		engr: "regex:typenetwork",
		embo: "regex:typenetwork",
		ytch: "regex:typenetwork",
		xtch: "regex:typenetwork",
		rxad: "regex:typenetwork",
		ryad: "regex:typenetwork",
		rsec: "regex:typenetwork",
		vuid: "regex:typenetwork",
		votf: "regex:typenetwork",
		gext: "https://github.com/microsoft/OpenTypeDesignVariationAxisTags/blob/master/Proposals/Glyph_Extension_Axis/ProposalSummary.md",
		hght: "https://github.com/microsoft/OpenTypeDesignVariationAxisTags/blob/master/Proposals/Height_Axis/ProposalSummary.md",
		spac: "https://github.com/Microsoft/OpenTypeDesignVariationAxisTags/blob/master/Proposals/Spacing_Axis/ProposalSummary.md",
	},
	regex: {
		microsoft: "https://docs.microsoft.com/en-us/typography/opentype/spec/dvaraxistag_$1",
		typenetwork: "https://variationsguide.typenetwork.com/#$1",
	},
	hoi: "http://underware.nl/case-studies/hoi/",
};


// add an info (help) icon to each panel
Qall("#controls .panel>h2").forEach(header => {
	let info = EL("div");
	info.innerHTML = "&#xf129;";
	info.classList.add("icon");
	info.classList.add("bold");
	info.classList.add("info");
	info.style.position = "absolute";
	info.style.right = "0.5em";
	info.style.top = "0.1em";
	header.appendChild(info);
});


// shorthands
function Q (selector) {
	return document.querySelector(selector);
}

function Qall (selector) {
	return document.querySelectorAll(selector);
}

function EL (tag) {
	return document.createElement(tag);
}

function SVG (tag) {
    return document.createElementNS("http://www.w3.org/2000/svg", tag);
}


// TODO: specify that this gets the current fvs from sliders
function getCurrentFvs() {

	// TODO: store the current values separately from the axes’ value to avoid conversions

	let fvs = {};
	Qall(".slider").forEach(slider => {
		let axis = slider.data.axis;
		fvs[axis.tag] = axis.min + slider.value * (axis.max - axis.min);
	});
	return fvs;
}


// TODO: this is needless duplication of what SamsaFont.addInstance() already does
// - we can assign the ui object in the options argument
function appendInstanceEl(instance, select) {

	let font = GLOBAL.vf;
	let panel = Q("#panel-instances>div");
	//panel.classList.add("tiles");

	// create the instance DOM element
	let li = document.createElement("div"); // not li?
	let icon = "-", title;

	// initialize instance if necessary
	if (instance === undefined) {
		instance = font.addInstance(getCurrentFvs(), { name: "Custom", ui: li }); // { name: "Custom", tuple: [] };
	}

	// list view
	// - items are: bookmark icon, name, n axis settings
	panel.style.minWidth = "100%";
	panel.style.overflowX = "scroll";


	li.classList.add("instance");
	li.style.display = "grid";
	li.style.gridTemplateColumns = `30px 30px 100px 30px 30px repeat(${GLOBAL.vf.axisCount}, 70px)`;

	// instance type
	switch (instance.type) {
		case "default": icon = "&#xf015;"; title = "Default"; break; // FontAwesome home
		case "named": icon = "&#xf02e;"; title = "Named instance"; break; // FontAwesome bookmark
		case "custom": icon = "&#xf1de;"; title = "Custom instance"; break; // FontAwesome sliders
		case "stat": icon = "&#xf03a;"; title = "STAT instance"; break; // FontAwesome list
	}
	let cell0 = document.createElement("div");
	cell0.style.cursor = "pointer";
	cell0.style.textAlign = "center";
	cell0.style.fontFamily = "FontAwesome";
	cell0.innerHTML = `<strong title="${title}">${icon}</strong>`;

	// SVG of the A glyph
	// - would current glyph be better? ... the image serves as a kind of visual label, but...
	let cell1 = document.createElement("div");
	let svg = SVG("svg");

	let glyph = font.glyphs[getDefaultGlyphId(font)];
	let iglyph = glyphApplyVariations(glyph, instance.tuple); // TODO: make composite-ready

	if (iglyph && iglyph.numContours > 0) {

		// simple glyph
		let svgPath = SVG("path");
		let svgg = SVG("g");
		let scale = 0.02 * 1000 / font.unitsPerEm;
		svg.setAttributeNS(null, "width","30");
		svg.setAttributeNS(null, "height","30");
		svgg.setAttributeNS(null, "transform", `translate(4,20) scale(${scale},-${scale})`);
		
		//svgMarker.attr({markerWidth:20,markerHeight:20);

 		svgPath.setAttributeNS(null, "d", getGlyphSVGpath(iglyph));

		svg.appendChild(svgg);

		// glyph
		svgg.appendChild(svgPath);

		// x and y axes

		//glyphThumb.appendChild(svg);

	}
	else if (glyph && glyph.numContours < 0) {


	}


	cell1.appendChild(svg);

	// instance name
	let cell2 = document.createElement("div");
	cell2.style.textAlign = "center";
	cell2.innerHTML = `<input value="${instance.name}" ${instance.type == "default" ? "readonly " : ""}style="width: 85px">`;

	// visibility
	let cell3 = document.createElement("div");
	cell3.setAttribute("title", "Visibility");
	cell3.style.textAlign = "center";
	cell3.style.fontFamily = "FontAwesome";
	cell3.style.cursor = "pointer";
	cell3.innerHTML = "&#xf06e"; // eye open f070 eye closed

	// instantiate button
	let cell4 = document.createElement("div");
	cell4.classList.add("instantiate");
	cell4.setAttribute("title", "Download TTF");
	cell4.style.textAlign = "center";
	cell4.style.fontFamily = "FontAwesome";
	cell4.style.cursor = "pointer";
	cell4.innerHTML = "&#xf358;"; //"&#xf56d;" // download

	// append all the elements so far
	li.appendChild(cell0);
	li.appendChild(cell1);
	li.appendChild(cell2);
	li.appendChild(cell3);
	li.appendChild(cell4);

	// all the axis settings
	GLOBAL.vf.axes.forEach((axis, a) => {
		let axisCell = document.createElement("div");
		axisCell.style.fontSize = "75%";
		axisCell.style.textAlign = "right";
		axisCell.innerText = instance.fvs[axis.tag];
		li.appendChild(axisCell);
	});

	// bind instance data to instance element
	li.data = { instance: instance };

	// append the instance DOM element
	panel.appendChild(li);

	cell2.addEventListener("input", ev => {
		instance.name = ev.target.value;
	});

	// make it active
	if (select) {
		setActiveInstance (GLOBAL.vf, li);
	}
}


function exportImage (format, filename="samsa-drawing", params) {
	if (GLOBAL.frameIndex === undefined)
		GLOBAL.frameIndex = 0;
	else
		GLOBAL.frameIndex++;

	let svgCode = Q("#drawing").innerHTML;

	svgCode = svgCode.replace(`<svg `, `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" `);

	if (format == "svg") {
		let fauxLink = document.createElement("a");
		fauxLink.download = filename + ".svg";
		fauxLink.href = "data:image/svg+xml;base64," + btoa(svgCode);
		document.body.appendChild(fauxLink); // needed for Firefox, not Chrome or Safari
		fauxLink.click();
		fauxLink.remove();
	}
	else if (format == "png") {
	
		// 1. create the image
		// 2. define what happens when it’s loaded
		// 3. define what to load
		let img = new Image(800, 800);
		img.onload = function () {

			// make a canvas to export the bitmap
			let canvas = document.createElement("canvas");
			canvas.setAttribute("width", 1080);
			canvas.setAttribute("height", 720);
			canvas.id = "samsa-drawing-canvas" + "-" + filename;
			canvas.style.border = "1px solid red";
			document.body.appendChild(canvas);
			let frameIndexStr = GLOBAL.frameIndex.toString();
			while (frameIndexStr.length<3)
				frameIndexStr = `0${frameIndexStr}`;

			if (params && params.frameNumbers === true)
				filename += frameIndexStr;
			filename += ".png";
			let ctx = canvas.getContext("2d");
			ctx.fillStyle = "white";
			ctx.fillRect(0, 0, canvas.width, canvas.height);
			ctx.drawImage(img, 0, 0);
			let fauxLink = document.createElement("a");
			fauxLink.download = filename;
			fauxLink.href = canvas.toDataURL('image/png'); // get pixels from canvas
			document.body.appendChild(fauxLink); // needed for Firefox, not Chrome or Safari
			fauxLink.click();
			fauxLink.remove();
			canvas.remove(); // better to just blank it each time, when exporting multiple frames?
		}

		// give the <img> a src attribute with an SVG data url, to render the SVG on the canvas
		img.src = "data:image/svg+xml," + encodeURIComponent(svgCode);	
	}
	else if (format == "svg-animation") {

		let svg = Q("#drawing svg").cloneNode();
		let svgg = Q("#drawing svg #svg-transform-group").cloneNode();
		let svgInstance = Q("#drawing svg #layer-instance").cloneNode();
		let svgAnimate = SVG("animate");

		svgg.removeAttribute("id");
		svgInstance.removeAttribute("d");
		svgInstance.removeAttribute("id");

		svgAnimate.attrsSVG({
			attributeName: "d",
			values: params.values, // the array of paths converted to a string
			keyTimes: params.keyTimes,
			dur: params.dur,
			repeatCount: params.repeatCount,
		});

		svgInstance.appendChild(svgAnimate);
		svgg.appendChild(svgInstance);
		svg.appendChild(svgg);
		let svgCode = svg.outerHTML;
		svgCode = svgCode.replace(`<svg `, `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" `);
		let fauxLink = document.createElement("a");
		fauxLink.download = filename + ".svg";
		fauxLink.href = "data:image/svg+xml;base64," + btoa(svgCode);
		document.body.appendChild(fauxLink); // needed for Firefox, not Chrome or Safari
		fauxLink.click();
		fauxLink.remove();
	}
}



function vfLoaded (font) {

	GLOBAL.vf = font;
	let panel;

	// set up initial global tuple, the default designspace location
	GLOBAL.tuple = [];
	font.axes.forEach(() => {
		GLOBAL.tuple.push(0);
	});

	///////////////////////////////////////////////////////
	// Main container grid: hide overlay and show main UI, reset cursor
	///////////////////////////////////////////////////////
	Q("#drag-drop-zone").style.display = "none";
	Q("#font-file").style.display = "block";
	Q("#drawing").style.display = "block";
	Q("#container").style.backgroundColor = "transparent";
	Q("body").style.cursor = "default";


	///////////////////////////////////////////////////////
	// Filename box
	///////////////////////////////////////////////////////
	Q("#font-file").innerText = font.filename; // or font.names[6];



	///////////////////////////////////////////////////////
	// Info panel
	///////////////////////////////////////////////////////
	panel = Q("#panel-info>div");
	panel.innerText = "";
	panel.style.fontSize = "75%";
	panel.style.wordBreak = "break-all";
	[
		["File", font.filename],
		["Size", font.filesize],
		["Full name", font.names[4]],
		["Version", font.names[5]],
	].forEach(item => {
		panel.innerHTML += `<em>${item[0]}:</em> ${item[1]}<br>`;
	});

	///////////////////////////////////////////////////////
	// UI Panel
	///////////////////////////////////////////////////////
	panel = Q("#panel-ui>div");
	if (!Q("#ui-mode")) { // only build once
		panel.innerText = "";

		// ui options select
		let uiModeHTML = "";
		uiModeHTML += `<select id="ui-mode">`;
		Object.keys(font.config.uiModes).forEach(modeId => {
			let mode = font.config.uiModes[modeId];
			uiModeHTML += `<option value="${modeId}">${mode.name || modeId}</option>`;
		});
		uiModeHTML += `</select><br>`;
		panel.innerHTML += uiModeHTML;
		panel.innerHTML += `<input id="arrows-split" class="ui-arrows" type="checkbox" checked><label for="arrows-split">Split deltas</label>`;
		panel.innerHTML += "&nbsp;";
		panel.innerHTML += `<input id="arrows-total" class="ui-arrows" type="checkbox"><label for="arrows-total">Total deltas</label>`;
		panel.innerHTML += "&nbsp;";
		panel.innerHTML += `<input id="point-numbers" class="ui-arrows" type="checkbox"><label for="point-numbers">Point numbers</label>`;

		/*
		panel.innerHTML += "<label>Delta colours</label>&nbsp;";
		panel.innerHTML += `<input id="arrows-colours" name="arrows-colours" class="ui-arrows-colours" type="radio" checked><label for="arrows-split">by tuple</label>&nbsp;`;
		panel.innerHTML += `<input id="arrows-colours" name="arrows-colours" class="ui-arrows-colours" type="radio"><label for="arrows-total">by order</label><br>`;
		*/

		// set the value for the select (for some reason it doesn’t work if this code comes any earlier)
		Q("#ui-mode").value = font.config.ui.name;

		// UI checkbox click
		Qall(".ui-arrows").forEach(el => {
			el.addEventListener("change", e => {
				let instance = font.addInstance(null, {tuple: GLOBAL.tuple});
				let glyph = font.glyphs[GLOBAL.currentGlyphId];
				let iglyph = glyphApplyVariations(glyph, null, instance);
				setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
				font.instances.pop();
			});
		});
	}


	///////////////////////////////////////////////////////
	// Webfont panel
	///////////////////////////////////////////////////////
	panel = Q("#panel-webfont>div");
	panel.innerText = "AaBbCc";
	panel.setAttribute("contentEditable", true);

	// add the webfont
	let webfontFace = new FontFace("Webfont", font.data.buffer)
	webfontFace.load().then(webfontFace => {
		document.fonts.add(webfontFace);
	});


	///////////////////////////////////////////////////////
	// Media panel
	///////////////////////////////////////////////////////
	panel = Q("#panel-media>div");
	panel.innerText = "";
	panel.style.display = "grid";
	panel.style.gridTemplateColumns = "auto auto auto";

	// export buttons
	panel.innerHTML += `<div></div><div></div><button id="export-svg">Export SVG</button>`;
	panel.innerHTML += `<div></div><div></div><button id="export-png">Export PNG</button>`;
	//panel.innerHTML += `<div></div><div></div><button id="export-mp4">Export MP4</button>`;
	panel.innerHTML += `<label>Select axis</label>`;

	// axis selector	
	let mediaAxisSelect = EL("select");
	mediaAxisSelect.id = "svg-animation-axis";
	font.axes.forEach(axis => {
		let option = EL("option");
		option.setAttribute("value", axis.id);
		option.innerText = `${axis.tag} (${axis.id})`;
		mediaAxisSelect.appendChild(option);
	});
	panel.appendChild(mediaAxisSelect);
	panel.innerHTML += `<button id="export-svg-animation">Export SVG animation</button>`;
	
	// SVG export
	Q("#export-svg").addEventListener("click", () => {
		exportImage ("svg");
	});

	// SVG export
	if (Q("#export-svg-animation")) {

		Q("#export-svg-animation").addEventListener("click", () => {

			// build special animation object object to pass to the exporter
			// - MDN https://developer.mozilla.org/en-US/docs/Web/SVG/Element/animate
			// - CSS-Tricks/Sara Soueidan https://css-tricks.com/guide-svg-animations-smil/

			// for every single-axis tuple that controls axis 0
			// - record start, peak, end
			// - build this into a sorted array of timing values
			// - then use this array of timing values to get the required instances

			// let’s build fvs, not tuple, so we don’t need to worry about avar or whether default is at min or max
			// - hmm, are you sure? we’re using normalized values because we parse tvts


			let fvs = {};
			let glyph = font.glyphs[GLOBAL.currentGlyphId];
			let keyTimesSet = new Set();
			let thisAxis = Q("#panel-media #svg-animation-axis").value;
			let svgAnimation;

			// find the tvts that only affect the chosen axis, then record their start, peak, end
			glyph.tvts.forEach(tvt => {

				// check it’s just axis 0 that is non-zero
				if (tvt.peak[thisAxis] != 0.0) {

					let valid = true;
					for (let a=0; a<font.axes.length; a++) {
						if (tvt.peak[a] != 0.0 && a != thisAxis) {
							valid = false;
							break;
						}
					}
					if (valid) {
						keyTimesSet.add(tvt.start[thisAxis]).add(tvt.peak[thisAxis]).add(tvt.end[thisAxis]);
					}
				}
			});

			if (keyTimesSet.size > 0) {

				// create a sorted keyTimes array from the set of unique values
				let keyTimes = Array.from(keyTimesSet).sort((a, b) => a - b);
				let keyTimesZeroOne; // normalized on a scale from 0 to 1
				let keyPaths = [];
				keyTimes.forEach(T => {

					let animInstance, iglyph;
					let frameTuple = []; // create tuple for this frame’s instance
					for (let a=0; a < font.axes.length; a++) {
						frameTuple[a] = a==thisAxis ? T : 0; // animate the <thisAxis> axis
					}
					
					animInstance = font.addInstance(null, {tuple: frameTuple}); // make instance
					iglyph = glyphApplyVariations(glyph, null, animInstance); // make instance glyph
					keyPaths.push(getGlyphSVGpath(iglyph)); // get SVG path of this instance
					font.instances.pop(); // pop instance
				});

				// create keyTimesZeroOne array, normalized onto range [0,1]
				let kMin=keyTimes[0], kMax=keyTimes[keyTimes.length-1];
				if (kMin == 0.0 && kMax == 1.0)
					keyTimesZeroOne = keyTimes;
				else {
					keyTimesZeroOne = [];
					keyTimes.forEach(T => {
						keyTimesZeroOne.push((T-kMin) / (kMax-kMin));
					});
				}

				// build svg using keyPaths and keyTimes
				svgAnimation = {
					attributeName: "d",
					dur: "5s",
					values: keyPaths.join(";"),
					keyTimes: keyTimesZeroOne.join(";"),
					repeatCount: "indefinite",
				};
			}
			if (svgAnimation)
				exportImage ("svg-animation", "samsa-animation", svgAnimation);
		});
	}
	// PNG export
	Q("#export-png").addEventListener("click", () => {
		exportImage ("png");
	});

	if (Q("#export-mp4")) {

		Q("#export-mp4").addEventListener("click", () => {

			// TODO: more efficient to just make one canvas, and blank it for each frame?

			if (0) {
				GLOBAL.animSteps = 10;
				GLOBAL.animCurrent = 0;

				function doAnimationFrame () {
					if (GLOBAL.animCurrent < GLOBAL.animSteps) {

						let animInstance, iglyph;
						let Tmin = font.axes[0].min < font.axes[0].default ? -1.0 : 0.0;
						let Tmax = font.axes[0].max > font.axes[0].default ? 1.0 : 0.0;
						let T = Tmin + GLOBAL.animCurrent/(GLOBAL.animSteps-1) * (Tmax-Tmin);
						let frameNumberStr = GLOBAL.animCurrent.toString();
						while (frameNumberStr.length < 3)
							frameNumberStr = `0${frameNumberStr}`;

						let frameTuple = []; // create tuple for this frame’s instance
						for (let a=0; a < font.axes.length; a++) {
							frameTuple[a] = a==0 ? T : 0; // animate only axis 0 for now
						}
						
						animInstance = font.addInstance(null, {tuple: frameTuple}); // make instance
						iglyph = glyphApplyVariations(font.glyphs[GLOBAL.currentGlyphId], null, animInstance); // make instance glyph
						setActiveGlyph (GLOBAL.currentGlyphId, animInstance); // make SVG of instance glyph
						exportImage ("png", `samsa-frame${frameNumberStr}`, {frameNumbers: false}); // place SVG on canvas, export canvas as PNG
						font.instances.pop(); // pop instance

						GLOBAL.animCurrent++;
					}
					else {
						console.log(`end`);
						clearInterval (GLOBAL.animTimer);
						GLOBAL.animTimer = undefined;
					}

				}

				GLOBAL.animTimer = setInterval(doAnimationFrame, 200);
			}
			else {

				const steps = 50;

				for (let s=0; s<steps; s++) {

					let animInstance, iglyph;
					let Tmin = font.axes[0].min < font.axes[0].default ? -1.0 : 0.0;
					let Tmax = font.axes[0].max > font.axes[0].default ? 1.0 : 0.0;
					let T = Tmin + s/(steps-1) * (Tmax-Tmin);
					let frameNumberStr = s.toString();
					while (frameNumberStr.length < 3) // generate frame number string (TODO: write padWithZeroes() function)
						frameNumberStr = `0${frameNumberStr}`;

					let frameTuple = []; // create tuple for this frame’s instance
					for (let a=0; a < font.axes.length; a++) {
						frameTuple[a] = a==0 ? T : 0; // animate only axis 0 for now
					}
					
					animInstance = font.addInstance(null, {tuple: frameTuple}); // make instance
					iglyph = glyphApplyVariations(font.glyphs[GLOBAL.currentGlyphId], null, animInstance); // make instance glyph
					setActiveGlyph (GLOBAL.currentGlyphId, animInstance); // make SVG of instance glyph
					exportImage ("png", `samsa-frame${frameNumberStr}`, {frameNumbers: false}); // place SVG on canvas, export canvas as PNG
					font.instances.pop(); // pop instance
				}

				// save shell script to invoke ffmpeg
				let frameRate = 24;
				let shellScript = `ffmpeg -r ${frameRate} -i samsa-frame%03d.png -vcodec libx264 -pix_fmt yuv420p samsa-movie.mp4`;
				let scriptLink = document.createElement("a");
				scriptLink.download = "samsa-movie.sh";
				scriptLink.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(shellScript));
				document.body.appendChild(scriptLink); // needed for Firefox, not Chrome or Safari
				scriptLink.click();
				document.body.removeChild(scriptLink);
			}

		});
	}



	///////////////////////////////////////////////////////
	// Axes panel
	///////////////////////////////////////////////////////
	panel = Q("#panel-axes>div");
	panel.innerText = "";


	let liH = document.createElement("li");
	liH.classList.add("header");
	liH.style.display = "grid";
	liH.style.gridTemplateColumns = `35px 20px 1fr 50px 50px 50px 50px 10px`;
	liH.innerHTML = `<label>Tag</label><label class="icon bold">&#xf129;</label><label>Name</label><label class="min icon bold" style="text-align:center;">&#xf13a;</label><label class="default icon bold" style="text-align:center;">&#xf015;</label><label class="max icon bold" style="text-align:center;">&#xf139;</label><label class="icon bold" style="text-align:center;">&#xf007;</label>`;
	panel.appendChild(liH);

	// add each axis
	font.axes.forEach((axis, a) => {

		let li = EL("li");
		li.id = `axis-${a}`;
		li.classList.add("axis-row");
		li.style.display = "grid";
		li.style.gridTemplateColumns = liH.style.gridTemplateColumns;
		li.style.listStyleType = "none";

		li.innerHTML = `<label class="tag"><tt>${axis.tag}</tt></label>`;

		let docStr = "", docUrl = font.config.docs.axes[axis.tag.toLowerCase()];
		if (docUrl) {
			let docParts = docUrl.split(/:(.+)/)
			if (docUrl && docParts[0] == "regex") {
				docUrl = font.config.docs.regex[docParts[1]].replace("$1", axis.tag.toLowerCase()); // handles microsoft and typenetwork
			}
			docStr = `<a href="${docUrl}" class="icon bold" title="‘${axis.tag}’ axis specification" target="_blank">&#xf05a;</a>`; // book icon, links to the specification of this axis
		}
		li.innerHTML += `<div>${docStr}</div>`;

		li.innerHTML += `<label>${axis.name}</label>`;

		li.innerHTML += `<input class="axis-min" value="${axis.min}" readonly style="text-align:right;">`;
		li.innerHTML += `<input class="axis-default" value="${axis.default}" readonly style="text-align:right;">`;
		li.innerHTML += `<input class="axis-max" value="${axis.max}" readonly style="text-align:right;">`;
		li.innerHTML += `<input class="axis-current active" value="${axis.default}" style="text-align:right; font-weight: 900;">`; // current

		let nudger = EL("div");
		nudger.style.height = "1rem";
		nudger.classList.add("no-select");
		nudger.style.fontSize = "0.5rem";
		nudger.innerHTML += `<div class="axis-nudge">+</div>`;
		nudger.innerHTML += `<div class="axis-nudge">−</div>`;
		li.appendChild(nudger);

		panel.appendChild(li);

		// handle text input
		li.querySelector(".axis-current").addEventListener("change", ev => {

			const font = GLOBAL.vf;
			const axis = ev.target.closest("li").data.axis;

			// parse the number in base 10 or base 16
			const numFormat = Q("#axis-value-format").value;
			let number;
			switch (numFormat) {
				case "user": case "norm":
					number = parseFloat(ev.target.value);
					break;
				case "userhex": case "normhex":
					number = parseInt(ev.target.value, 16);
					if (numFormat == "userhex") {
						if (number >= 0x80000000)
							number -= 0x100000000;
						number /= 0x10000;
					}
					else { // numFormat == "normhex"
						if (number >= 0xc000)
							number -= 0x10000;
						number /= 0x4000;
					}
					break;
			}

			if (numFormat == "user" || numFormat == "userhex") {
				number = GLOBAL.vf.axisNormalize(axis, number);
			}

			if (number>1) number = 1;
			if (number<-1) number = -1;
			GLOBAL.tuple[axis.id] = number;
			let instance = font.addInstance(null, {tuple: GLOBAL.tuple});
			setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
			setAxes (font, font.tupleToFvs(GLOBAL.tuple));
			axesUpdateValues();
			panelSTAT_handleChange();
			panelWebfont_handleChange();
			font.instances.pop();
		});

		let slider = EL("input");
		slider.classList.add("slider");
		slider.setAttribute("type", "range");
		slider.setAttribute("min", 0.0);
		slider.setAttribute("max", 1.0);
		slider.setAttribute("step", 0.001);

		panel.appendChild(slider);

		slider.data = li.data = {axis: axis, current: axis.default};

		slider.addEventListener("input", axisInput);

		// double-click sets the axis to default
		li.querySelector(".tag").addEventListener("dblclick", ev => {

			let fvsFromSliders = getCurrentFvs();
			let fvs = font.tupleToFvs(GLOBAL.tuple);
			let tag = ev.target.innerText;
			fvs[tag] = axis.default;

			setAxes (font, fvs);
			let instance = font.addInstance(fvs);
			setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
			axesUpdateValues();
			panelSTAT_handleChange();
			panelWebfont_handleChange();
			font.instances.pop();
		});

	});

	// create grid layout
	let grid = EL("div");
	grid.style.display = "grid";
	grid.classList.add("axes-footer");
	grid.style.gridTemplateColumns = "30% 35% 1fr";
	grid.style.gridColumnGap = "3px";

	let axisValueFormat = EL("select");
	axisValueFormat.id = "axis-value-format";
	axisValueFormat.innerHTML = `<option>user</option><option>userhex</option><option>norm</option><option>normhex</option>`;

	let addInstanceEl = EL("button");
	addInstanceEl.innerText = "Add instance";
	addInstanceEl.class = "instance-add";

	let axisValueLabel = EL("label");
	axisValueLabel.innerText = "Number format";

	grid.appendChild(axisValueLabel);
	grid.appendChild(axisValueFormat);
	grid.appendChild(addInstanceEl);

	// avar toggle
	if (font.avar.length > 0) {
		let avarLabel = EL("label");
		let avarChk = EL("input");
		avarChk.setAttribute("type", "checkbox");
		avarChk.id = "avarChk";
		avarLabel.innerText = "Show avar";
		avarLabel.setAttribute("for", avarChk)
		grid.appendChild(avarLabel);
		grid.appendChild(avarChk);

		avarChk.addEventListener("change", ev => {
			Q(`#avar`).style.display = avarChk.checked ? "block" : "none";
		});
	}

	panel.appendChild(grid);

	// avar ui
	const avarDiv = EL("div");
	avarDiv.id = "avar";
	avarDiv.style.width = "100%";
	avarDiv.style.minHeight = "100px";
	avarDiv.style.display = "none";

	if (font.avar.length > 0) {
		let avarSVGwidth = 340, avarSVGheight = 100;
		let avarMapColor = "grey", avarCurrentColor = "limegreen";
		font.avar.forEach((axisMaps, a) => {
			if (axisMaps.length > 0) {
				const avarSVG = SVG("svg");

				avarSVG.classList.add("avar-axis-svg");
				avarSVG.data = {axis: font.axes[a]};
				avarSVG.attrsSVG({
					width: 360,
					height: 116,
				});

				let rect = SVG("rect");
				rect.attrsSVG({
					x: 10,
					y: 10,
					width: avarSVGwidth,
					height: avarSVGheight,
					stroke: "black",
					"stroke-width": 0.25,
					fill: "none",
				});
				avarSVG.appendChild(rect);

				axisMaps.forEach(map => {

					let arrowLine = SVG("line");
					let arrowHead = SVG("path");
					let arrow = getArrowParams({
						x1: 10 + (map[0]+1)/2 * avarSVGwidth,
						y1: 10,
						x2: 10 + (map[1]+1)/2 * avarSVGwidth,
						y2: 10 + avarSVGheight,
						tipWid: 5,
						tipLen: 10,
					});

					arrowLine.attrsSVG({
						x1: arrow.x1,
						y1: arrow.y1,
						x2: arrow.newX2,
						y2: arrow.newY2,
						stroke: avarMapColor,
						"stroke-width": 1,
						fill: avarMapColor,
					});

					arrowHead.attrsSVG({
						d: `M${arrow.x2} ${arrow.y2}L${arrow.arrowX1} ${arrow.arrowY1}L${arrow.arrowX2} ${arrow.arrowY2}Z`,
						fill: avarMapColor,
					});

					avarSVG.appendChild(arrowLine);
					avarSVG.appendChild(arrowHead);
				});

				// current line
				let avarCurrentLine = SVG("line");
				let avarCurrentHead = SVG("path");
				let arrow = getArrowParams({
					x1: 10 + 1/2 * avarSVGwidth,
					y1: 10,
					x2: 10 + 1/2 * avarSVGwidth,
					y2: 10+avarSVGheight,
					tipWid: 10,
					tipLen: 20,
				});
				avarCurrentLine.attrsSVG({
					stroke: avarCurrentColor,
					"stroke-width": 3,
					x1: arrow.x1,
					y1: arrow.y1,
					x2: arrow.newX2,
					y2: arrow.newY2,
				});

				avarCurrentHead.attrsSVG({
					d: `M${arrow.x2} ${arrow.y2}L${arrow.arrowX1} ${arrow.arrowY1}L${arrow.arrowX2} ${arrow.arrowY2}Z`,
					fill: avarCurrentColor,
				});

				avarCurrentLine.classList.add("avar-current");
				avarCurrentHead.classList.add("avar-current");

				avarSVG.appendChild(avarCurrentLine);
				avarSVG.appendChild(avarCurrentHead);

				let titleEl = SVG("title");
				titleEl.textContent = `${font.axes[a].default}\n→ ${0}\n → ${0}\n${font.axes[a].default}`;
				avarSVG.appendChild(titleEl);

				avarDiv.appendChild(avarSVG);
			}

		});
	}
	panel.appendChild(avarDiv);

	// handle events

	// event: click
	addInstanceEl.addEventListener("click", ()=>{
		appendInstanceEl(undefined, true);
	});

	// event: change format
	Q("#axis-value-format").addEventListener("change", ()=>{

		let fvs = font.tupleToFvs(GLOBAL.tuple);
		font.axes.forEach((axis,a) => {
			Q(`#axis-${a}>.axis-min`).value = numberFormat(axis.min, axis);
			Q(`#axis-${a}>.axis-default`).value = numberFormat(axis.default, axis);
			Q(`#axis-${a}>.axis-max`).value = numberFormat(axis.max, axis);
			let currentVal = fvs[axis.tag] === undefined ? axis.default : fvs[axis.tag];
			Q(`#axis-${a}>.axis-current`).value = numberFormat(currentVal, axis);
		});

	});


	///////////////////////////////////////////////////////
	// STAT panel
	///////////////////////////////////////////////////////
	panel = Q("#panel-stat>div");
	panel.innerText = "";
	if (font.tables.STAT) {
		const STAT = font.tables.STAT.data;
		
		// create grid layout
		let grid = document.createElement("div");
		grid.style.display = "grid";
		grid.classList.add("designAxes");
		grid.style.gridTemplateColumns = "30% 35% 1fr";
		grid.style.gridColumnGap = "3px";

		let label, select, note;

		// for each STAT designAxis create a <select>; plus a <select> for multiaxis axisValueTables
		let selects = [];
		for (let a=0; a <= STAT.designAxesSorted.length; a++) { // we build 1+designAxes.length selects
			let select = EL("select");
			select.data = {};
			
			if (a < STAT.designAxes.length)
				select.data.designAxis = STAT.designAxesSorted[a]; // we make 1 per designAxis, plus another for multiaxis (format 4)

			let option = EL("option");
			option.value = -1;
			option.innerText = "[no match]";
			select.appendChild(option)

			selects.push(select);
		}
		
		// go thru all axisValueTables, assigning them to their correct <select>
		STAT.axisValueTables.forEach((avt, a) => {

			let option = EL("option");
			option.value = a; // for easy retrieval of the axisValueTable later
			option.data = { axisValueTable: avt };
			option.innerText = font.names[avt.nameID];
			if (avt.flags & 0x0002) { // ELIDABLE_AXIS_VALUE_NAME
				option.innerText = "(" + option.innerText + ")";
			}

			switch (avt.format) {

				case 1: case 2: case 3:
					let designAxis = STAT.designAxes[avt.axisIndex];
					selects[designAxis.axisOrdering].appendChild(option); // TODO: vulnerability when axisOrdering values are not well formed, zero-indexed ids
					break;

				case 4:
					selects[STAT.designAxesSorted.length].appendChild(option); // append to the last select (for multi-axis records)
					break;
			}

		});

		selects.forEach(select => {

			label = EL("label");

			if (select.querySelectorAll("option").length == 0) {
				// handle a <select> without options
				let option = EL("option");
				option.innerText = "(none)";
				select.appendChild(option);
				select.disabled = true;
			}
			else {
				// handle changes in this <select>
				select.addEventListener("change", ev => {

					const STAT = font.tables.STAT.data;
					if (ev.target.value != -1) {

						const STAT = GLOBAL.vf.tables.STAT.data;
						let avt = STAT.axisValueTables[ev.target.value];
						let fvs = GLOBAL.vf.tupleToFvs(GLOBAL.tuple);
						let axisIndices = avt.axisIndex;
						let values = avt.value;
						if (avt.format != 4) { // for format 4, they are already arrays
							axisIndices = [axisIndices];
							values = [values];
						}

						// upadte the fvs from the axisValueTable
						axisIndices.forEach((axisIndex, a) => {
							fvs[STAT.designAxes[axisIndex].tag] = values[a];
						});

						// update the rest of the Samsa UI
						setAxes (font, fvs);
						let instance = font.addInstance(fvs, {type: "custom"});
						setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
						axesUpdateValues();
						panelSTAT_handleChange(fvs);
						panelWebfont_handleChange();
						font.instances.pop();

					}
				});
			}

			if (select.data && select.data.designAxis)
				label.innerText = font.names[select.data.designAxis.nameID];
			else
				label.innerText = "Multi-axis";

			// disable selection for any <select> with no options
			if (select.options.length <= 1)
				select.disabled = true;	

			// append these to the grid
			grid.appendChild(label);
			grid.appendChild(select);
			grid.appendChild(EL("label"));

		});

		label = EL("label");
		let input = EL("input");

		input.id = "stat-composed-name";
		input.readOnly = true;

		label.innerText = "Composed name";
		grid.appendChild(label);
		grid.appendChild(input);

		panel.appendChild(grid);


		// "Add instance" button
		let addInstanceEl = document.createElement("button");
		addInstanceEl.innerText = "Add instance";
		addInstanceEl.class = "instance-add";
		grid.appendChild(addInstanceEl);

		// set current STAT instance and add it to the Instances panel
		addInstanceEl.addEventListener("click", () => {

			let fvs = GLOBAL.vf.tupleToFvs(GLOBAL.tuple);
			let instance = font.addInstance(fvs, { type: "stat", name: Q("#stat-composed-name").value });
			appendInstanceEl(instance, true);
		});
	}

	else {
		panel.innerHTML = "This font does not contain a STAT table.";
	}


	///////////////////////////////////////////////////////
	// Instances panel
	///////////////////////////////////////////////////////
	panel = Q("#panel-instances>div");
	panel.innerText = "";
	panel.style.backgroundClip = "border-box";
	panel.style.padding = "1px 0"; // necessary so the padding of the contents uses the panel’s background-color 

	let li = Q("div");
	let fvsString = "";

	// add each instance
	font.instances.forEach((instance, i) => {
		appendInstanceEl(instance);
	});
	setActiveInstance(GLOBAL.vf); // without an instance parameter, it sets it to the default


	///////////////////////////////////////////////////////
	// Designspace panel
	///////////////////////////////////////////////////////
	panel = Q("#panel-designspace>div");
	panel.innerText = "";
	panel.style.backgroundColor = "white";

	// build cartesian area
	let cartesian = document.createElement("div");
	cartesian.id = "ds-cartesian";
	cartesian.setAttribute("style", "width: 100%; height: 360px;");
	panel.appendChild(cartesian);

	// checkboxes for X and Y axis assignment
	let htmlX, htmlY;
	htmlX = `<div id="xSelect" class="ds-axis-group">`;
	htmlY = `<div id="ySelect" class="ds-axis-group">`;
	GLOBAL.vf.axes.forEach((axis,a) => {
		htmlX += `<div><input type="checkbox" id="x-${axis.tag}" value="${axis.tag}"${a==0 ? " checked" : ""}><label for="x-${axis.tag}">${axis.tag}</label></div>`;
		htmlY += `<div><input type="checkbox" id="y-${axis.tag}" value="${axis.tag}"${a==1 ? " checked" : ""}><label for="y-${axis.tag}">${axis.tag}</label></div>`;
	});
	htmlX += `</div>`;
	htmlY += `</div>`;
	panel.innerHTML += `<div class="cartesian-axis-row"><div>X=<span id="xValue">0</span></div>${htmlX}</div>`;
	panel.innerHTML += `<div class="cartesian-axis-row"><div>Y=<span id="yValue">0</span></div>${htmlY}</div>`;
	
	// attach change events to each checkbox
	Qall(".ds-axis-group input").forEach(el => {
		el.addEventListener("change", () => {
			// validate new state of checkboxes
			let valid = true, foundAxes = [];
			Qall(".ds-axis-group input:checked").forEach(el => {
				if (foundAxes.includes(el.value))
					valid = false;
				else
					foundAxes.push(el.value);
			});

			// if invalid, set red background
			xSelect.style.backgroundColor = ySelect.style.backgroundColor = valid ? "inherit" : "red";
		});
	});

	// TODO: consider user/normalized option

	updateDesignspace();


	// TODO: .designspace export - is this useful?
	if (false) {

		let exportEl = document.createElement("button");
		exportEl.innerText = "Export as .designspace";
		exportEl.id = "instance-add";
		panel.appendChild(exportEl);

		/*
		<designspace format="3">
			<axes>
				<!-- define axes here -->
				<axis../>
				</axes>
			<sources>
				<!-- define masters here -->
				<source../>
			</sources>
			<instances>
				<!-- define instances here -->
				<instance../>
			</instances>
		</designspace>
		*/

		let designspace = document.createElement("designspace");
		designspace.setAttribute("format", 3);
		let dsAxes = document.createElement("axes");
		let dsSources = document.createElement("sources");
		let dsInstances = document.createElement("instances");
		GLOBAL.vf.axes.forEach(axis => {
			let dsAxis = document.createElement("axis");
			dsAxis.setAttribute("name", axis.name);
			dsAxis.setAttribute("tag", axis.tag);
			dsAxis.setAttribute("minimum", axis.min);
			dsAxis.setAttribute("default", axis.default);
			dsAxis.setAttribute("maximum", axis.max);
			dsAxes.appendChild(dsAxis);
		})
		// what to do about sources?
		GLOBAL.vf.instances.forEach(instance => {
			let dsInst = document.createElement("instance");
			//dsInstances.appendChild(dsInst);
		})
		designspace.appendChild(dsAxes);
		designspace.appendChild(dsSources);
		designspace.appendChild(dsInstances);
		console.log ("<?xml version='1.0' encoding='utf-8'?>\n" + designspace.outerHTML);
	}



	if (!panel.parentNode.classList.contains("open"))
		panel.style.display = "none";


	///////////////////////////////////////////////////////
	// Glyphs panel
	///////////////////////////////////////////////////////
	GLOBAL.currentGlyphId = getDefaultGlyphId(font);
	updateGlyphsPanel (font.instances[0]); // instances[0] is always the default instance


	Q("body").style.cursor = "default";


	///////////////////////////////////////////////////////
	// late event handlers and assignments
	///////////////////////////////////////////////////////

	// ui: handle change of mode
	Q("#ui-mode").addEventListener("change", () => {
		font.config.ui = font.config.uiModes[Q("#ui-mode").value]; // set the config variable to the current selection in #ui-mode
		let instance = font.addInstance(null, {tuple: GLOBAL.tuple});
		setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
		font.instances.pop();
	});

	// designspace: handle mousemove and mousedown (late event handler)
	Q("#ds-cartesian").addEventListener("mousemove", e => {
		// requires pointer-events:none on all grid lines
		if (e.buttons & 1) { // 1 is bitmask for left mouse button
			updateDesignSpaceMoved(e);
		}
	});
	Q("#ds-cartesian").addEventListener("mousedown", e => {
		updateDesignSpaceMoved(e);
	});

}


function updateDesignSpaceMoved(e) {

	const saveScrollY = Q("#controls").scrollTop; // fixes Safari macOS 10.14 bug where controls panel scrolls to top on most interactions
	let font = GLOBAL.vf;
	let rect = e.target.getBoundingClientRect();
	let x = e.clientX - rect.left;
	let y = e.clientY - rect.top;
	x = x/180-1;
	y = 1-y/180;

	// update the visual designspace location lines
	Q("#svgXVal").setAttributeNS(null, "d", `M${x} -1 L${x} 1`);
	Q("#svgYVal").setAttributeNS(null, "d", `M-1 ${y} L1 ${y}`);

	// initialize tuple
	let tuple = [];
	for (let a=0; a < font.axes.length; a++) {
		tuple.push(0); // default is 0 by definition
	}
	
	// what VF axes are attached to the X axis?
	Qall("#xSelect input:checked").forEach(el => {
		font.axisIndices(el.value).forEach(i => tuple[i]=x );
	});

	// what VF axes are attached to the Y axis?
	Qall("#ySelect input:checked").forEach(el => {
		font.axisIndices(el.value).forEach(i => tuple[i]=y );
	});

	// update the text fields
	Q("#xValue").innerText = x.toFixed(5);
	Q("#yValue").innerText = y.toFixed(5);

	// set the axes in the Axes panel
	let fvs = font.tupleToFvs(tuple);
	setAxes (font, fvs);

	// now update the glyph in the drawing
	// - should we do this simply by setting the axes in the Axes panel
	let instance = font.addInstance(null, {tuple: tuple});
	let glyph = font.glyphs[GLOBAL.currentGlyphId];
	let iglyph = glyphApplyVariations(glyph, null, instance);
	setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
	font.instances.pop();

	axesUpdateValues();
	panelWebfont_handleChange();

	Q("#controls").scrollTop = saveScrollY; // for the macOS 10.14 bug referenced at the start of this click handler
}

function numberFormat(val, axis) {

	let V;
	switch (Q("#axis-value-format").value) {

		case "user":
			V = val;
			break;

		case "userhex":
			V = Math.round(val * 0x10000);
			if (V<0)
				V += 0x100000000;
			V = V.toString(16);
			for (let p=V.length; p<8; p++)
				V = `0${V}`;
			break;

		case "norm":
			V = GLOBAL.vf.axisNormalize(axis, val);
			break;

		case "normhex":
			V = GLOBAL.vf.axisNormalize(axis, val);
			V = Math.round(V * 0x4000);
			if (V<0)
				V += 0x10000;
			V = V.toString(16);
			for (let p=V.length; p<4; p++)
				V = `0${V}`;
			break;

	}
	return V;
}


function axesUpdateValues () {
	// update axis values
	const font = GLOBAL.vf;
	let fvs = font.tupleToFvs(GLOBAL.tuple);
	font.axes.forEach((axis,a) => {
		let currentVal = fvs[axis.tag] === undefined ? axis.default : fvs[axis.tag];
		Q(`#axis-${a}>.axis-current`).value = numberFormat(currentVal, axis);
	});

	// update avar
	if (font.avar) {

		let avarSVGs = Qall(".avar-axis-svg");
		if (avarSVGs.length > 0) {
			avarSVGs.forEach(avarSVG => {

				let avarSVGwidth = 340, avarSVGheight = 100;
				let axis = avarSVG.data.axis;
				let userVal = Q(`#axis-${axis.id}`).data.current, userValTrans = axis.default;
				let initial = font.axisNormalize(axis, userVal, true); // set avarIgnore arg to true
				let final = GLOBAL.tuple[axis.id]; // == font.axisNormalize(axis, userVal); // i.e. avarIgnore == undefined
				let avarCurrentLine = avarSVG.querySelector("line.avar-current");
				let avarCurrentHead = avarSVG.querySelector("path.avar-current");
				let arrow = getArrowParams({
					x1: 10 + (initial+1)/2 * avarSVGwidth,
					y1: 10,
					x2: 10 + (final+1)/2 * avarSVGwidth,
					y2: 10 + avarSVGheight,
					tipWid: 10,
					tipLen: 20,
				});

				// adjust the arrow’s line and head attributes
				avarCurrentLine.attrsSVG({
					x1: arrow.x1,
					y1: arrow.y1,
					x2: arrow.newX2,
					y2: arrow.newY2,
				});
				avarCurrentHead.attrsSVG({
					d: `M${arrow.x2} ${arrow.y2}L${arrow.arrowX1} ${arrow.arrowY1}L${arrow.arrowX2} ${arrow.arrowY2}Z`,
				});

				// set title tooltip
				if (final > 0)
					userValTrans += final * (axis.max - axis.default);
				else if (final < 0)
					userValTrans += final * (axis.default - axis.min);
				avarSVG.querySelector("title").textContent = `${userVal}\n→ ${initial}\n→ ${final}\n→ ${userValTrans}`;
			});
		}

		font.axes.forEach((axis, a) => {
			axis.id

		});
	}
}


function panelWebfont_handleChange() {
	let fvs = GLOBAL.vf.tupleToFvs(GLOBAL.tuple);
	Q("#panel-webfont.panel>div").style.fontVariationSettings = fvsToCSS(fvs);
}


function axisInput(ev) {

	const saveScrollY = Q("#controls").scrollTop; // fixes Safari macOS 10.14 bug where controls panel scrolls to top on most interactions
	let font = GLOBAL.vf;
	let fvsFromSliders = getCurrentFvs();
	let fvs = font.tupleToFvs(GLOBAL.tuple);
	let tag = ev.target.data.axis.tag;
	fvs[tag] = fvsFromSliders[tag];
	ev.target.data.current = fvs[tag];

	// create instance
	let instance = font.addInstance(fvs); // { name: "Custom", tuple: [] };

	let glyph = font.glyphs[GLOBAL.currentGlyphId];
	let iglyph = glyphApplyVariations(glyph, null, instance);
	setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
	
	axesUpdateValues();
	panelSTAT_handleChange();
	panelWebfont_handleChange();

	// delete instance
	font.instances.pop();
	Q("#controls").scrollTop = saveScrollY; // for the macOS 10.14 bug referenced at the start of this click handler
}

function updateDesignspace() {

	const ui = CONFIG.ui;
	let cb = Q("#dsAxesMultiple");
	let xSelect = Q("#xSelect");
	let ySelect = Q("#ySelect");

	// draw cartesian axes
	let cartesian = Q("#ds-cartesian");

	let svg = SVG("svg");
	let svgg = SVG("g"); // this transforms everything inside it
	svgg.id = "svg-transform-group";
	let svgXYAxes, svgXVal, svgYVal;
	let scale = 360/2; // 360 is the width & height of the cartesian space in px, 2 is the width & height of the cartesian space in normalized units (-1 to +1)
	svg.setAttributeNS(null, "width","360");
	svg.setAttributeNS(null, "height","360");
	svgg.setAttributeNS(null, "transform", `translate(180,180) scale(${scale},-${scale})`);

	svgXYAxes = SVG("path");
	svgXYAxes.attrsSVG({
		//d: "M-10000,0 L10000,0 M0,-10000 L0,10000",
		d: "M-1 0 L1 0 M0 -1 L0 1",
		stroke: `lightblue`,
		"stroke-width": `${1/scale}px`,
		fill: "none",
		"pointer-events": "none",
	});

	svgXVal = SVG("path");
	svgXVal.id = "svgXVal";
	svgXVal.attrsSVG({
		d: "M0 -1 L0 1",
		stroke: ui.designspace.colors[1],
		"stroke-width": `${1/scale}px`,
		fill: "none",
		"pointer-events": "none",
	});

	svgYVal = SVG("path");
	svgYVal.id = "svgYVal";
	svgYVal.attrsSVG({
		d: "M-1 0 L1 0",
		stroke: ui.designspace.colors[0],
		"stroke-width": `${1/scale}px`,
		fill: "none",
		"pointer-events": "none",
	});

	svgg.appendChild(svgXVal);
	svgg.appendChild(svgYVal);
	svgg.appendChild(svgXYAxes);
	svg.appendChild(svgg);

	cartesian.appendChild(svg);


	// draw some glyphs (at named instance locations)



	// capture mouse



	// consider 1d view

}


function panelSTAT_handleChange(fvs) {

	const font = GLOBAL.vf;
	if (!font.tables["STAT"])
		return;

	const STAT = font.tables["STAT"].data;
	if (fvs === undefined)
		fvs = font.tupleToFvs(GLOBAL.tuple);
	let selectValues = {};
	const axisTags = Object.keys(fvs);
	let statName, elidable = true, statNamesStrs = [];

	// find the avt’s which match this fvs
	let avtIndexMulti = -1;
	for (let a=0; a<STAT.axisValueTables.length; a++) {
		const avt = STAT.axisValueTables[a];
		axisTags.forEach(tag => {

			// TODO: are we sure rounding is ok here? If not we can roud-trip through tuple representation

			// do we have a match?
			if (avt.format < 4 && 
				selectValues[tag] === undefined && 
				(fvs[tag] == avt.value || (avt.format == 2 && fvs[tag] >= avt.min && fvs[tag] <= avt.max)) && 
				tag == STAT.designAxes[avt.axisIndex].tag) {

				selectValues[tag] = {};
				selectValues[tag].avtIndex = a; // index of this axisValueTable in STAT.axisValueTables
				selectValues[tag].note = "";
			}
			else if (avt.format == 4 && avtIndexMulti == -1) {
				let match = true;
				avt.axisIndex.forEach((axisIndex, a) => { // axisIndex is an array because format 4
					if (avt.value[a] != fvs[STAT.designAxes[axisIndex].tag])
						match = false;
				});
				if (match)
					avtIndexMulti = a;
			}
		});
	}

	// for each <select>, select the right option
	Qall("#panel-stat select").forEach((select, a) => {
		let tag;
		if (a < STAT.designAxes.length) {
			tag = select.data.designAxis.tag;
			if (select.options.length > 1) {
				if (fvs[tag] === undefined) // this fvs needs to specify all fvar axes
					select.value = select.options[1].value; // set designAxes which are not in the font to the (only) valid option
				else
					select.value = (selectValues[tag] === undefined) ? -1 : selectValues[tag].avtIndex;
			}
		}
		else {
			select.value = avtIndexMulti;
		}

		// calculate the note for this <select>
		let note = "";
		if (select.options.length > 1) {
			let axisIndices = [], values = [];
			if (select.value != -1) {

				let avt = STAT.axisValueTables[select.value];
				axisIndices = avt.axisIndex;
				let values = avt.value;
				if (avt.format != 4) {
					axisIndices = [axisIndices];
					values = [values];
					note = avt.value;
				}

				// get stat name component
				let name = font.names[avt.nameID];
				let thisElidable = avt.flags & 0x0002;

				if (avt.format == 2 && fvs[tag] != values[0]) {
					name += `[${Math.round(fvs[tag]*100)/100}]`;
					thisElidable = false; // make "Regular" no longer elidable if we’ve appended a value
				}

				if (!thisElidable) {
					if (a < STAT.designAxes.length)
						statNamesStrs.push(name); // append single-axis names
					else
						statNamesStrs.unshift(name); // prepend multiaxis names (the OpenType spec doesn’t not say what happens for these names… perhaps they should be ignored if their axes have already been accounted for by single-axis axisValueTables)
					elidable = false; // global elidable
				}

				// determine the fvs
				axisIndices.forEach((axisIndex, a) => {
					fvs[STAT.designAxes[axisIndex].tag] = values[a];
				});

				// augment the note
				switch (avt.format) {
					case 2: note += ` [${avt.min},${avt.max}]`; break;
					case 3: note += ` (→ ${avt.linkedValue})`; break;
					case 4: note = JSON.stringify(fvs); break;
				}
			}
		}

		// set the note
		select.nextSibling.innerText = note; // vulnerable to layout changes but concise! (requires <label> of the note to immediately follow the <select>)
	});

	// finalize and display statName
	if (elidable && STAT.elidedFallbackNameID !== undefined)
		statName = font.names[STAT.elidedFallbackNameID];
	else
		statName = statNamesStrs.join(" ");
	Q("#stat-composed-name").value = statName;
}


function updateGlyphsPanel(instance) {

	//console.log("Updating glyphs panel: START");
	const font = GLOBAL.vf;

	///////////////////////////////////////////////////////
	// glyphs panel
	///////////////////////////////////////////////////////
	const panel = Q("#panel-glyphs>div");
	panel.innerText = "";
	const scale = 0.05 * 1000 / font.unitsPerEm;
	let showGlyphIds = Q("#panel-glyphs>h2 #glyphs-ids").classList.contains("active");
	
	for (let g=0; g < font.numGlyphs; g++) {

		let glyph = instance ? instance.glyphs[g] : font.glyphs[g];
		let glyphThumb = document.createElement("div");
		glyphThumb.classList.add("glyph-thumb");
		glyphThumb.setAttribute("id", `g-${g}`);

		if (glyph) {

			// simple glyph
			let svg = SVG("svg");
			let svgg = SVG("g");

			svg.setAttributeNS(null, "width","90");
			svg.setAttributeNS(null, "height","90");
			svgg.setAttributeNS(null, "transform", `translate(20,60) scale(${scale},-${scale})`);
			
			let paths = getGlyphSVGpath(glyph);
			if (!Array.isArray(paths)) { // composite
				paths = [paths];
			}

			paths.forEach((path, p) => {

				if (Array.isArray(path)) {
					console.log("Warning: glyph <" + glyph.name + "> has nested components >1 level deep");
				}

				let svgPath;
				let svgg3 = glyph.numContours == -1 ? SVG("g") : null; // wrap component paths in a g so they can be transformed
				svgPath = SVG("path"); // give this an id so we can detect clicks
				svgPath.attrsSVG({
					d: path,
					stroke: GLOBAL.vf.config.ui.glyphThumb.stroke,
					"stroke-width": `${GLOBAL.vf.config.ui.glyphThumb.strokeWidth}px`,
					fill: GLOBAL.vf.config.ui.glyphThumb.fill,
				});
				if (svgg3) {
					svgg3.attrsSVG({
						transform: `translate(${glyph.points[p][0]},${glyph.points[p][1]})`,
					});
					svgg3.appendChild(svgPath);
					svgg.appendChild(svgg3);
				}
				else {
					svgg.id = `g${glyph.id}`;
					svgg.appendChild(svgPath);
				}
			});

			svg.appendChild(svgg);
			glyphThumb.appendChild(svg);

		}
		else if (glyph && glyph.numContours < 0) {


		}

		// set the label for the glyph thumb: glyph name and glyph id
		let label = document.createElement("label");
		let spanName = document.createElement("span"), spanId = document.createElement("span");
		spanName.innerText = font.glyphs[g].name || "undefined";
		spanName.classList.add("name");
		spanId.innerText = g;
		spanId.classList.add("number");
		if (showGlyphIds)
			spanName.style.display = "none";
		else
			spanId.style.display = "none";

		// append the elements
		label.appendChild(spanName);
		label.appendChild(spanId);
		glyphThumb.appendChild(label);
		panel.appendChild(glyphThumb);
	}

	//console.log("Updating glyphs panel: END");
	setActiveGlyph(GLOBAL.currentGlyphId, instance);
}

function setAxes (font, fvs) {
	

	let sliders = Qall(".slider");
	font.axes.forEach((axis, a) => {

		if (axis.min > axis.max)
			return;

		let val = fvs[axis.tag];
		if (val < axis.min)
			val = axis.min;
		if (val > axis.max)
			val = axis.max;

		sliders[a].value = (val - axis.min) / (axis.max - axis.min);
		sliders[a].data.current = val;
	});
}

function getActiveInstance (font) {

	let instance = null;
	Qall(".instance").forEach(el => {
		console.log(`checking instance`)
		if (el.classList.contains("active")) {
			console.log(`got instance`, el.data.instance)
			instance = el.data.instance;
		}
	});

	return instance;
}

function setActiveInstance (font, target) {

	Qall(".instance").forEach((el, i) => {

		let instance = font.instances[i]; // font.instances[0] is the default "instance"

		// update instance ui
		if (el == target || (!target && instance.type == "default")) { // allows for future reordering
			
			el.classList.add("active");
			setAxes (font, instance.fvs);
			instanceApplyVariations (font, instance);
			updateGlyphsPanel (instance);
			axesUpdateValues();
			panelSTAT_handleChange();
			panelWebfont_handleChange();
		}
		else {
			el.classList.remove("active");
			//target.data.selected = true;
		}
	});
}


function getActiveGlyph () {

	let g=0, el;
	if (el = Q(".glyph-thumb.active")) {
		let comps = el.id.split("-");
		g = 1*comps[1];
	}
	return g;

	// TODO: it would be simpler just to store the active glyph somewhere
	// return font.currentGlyphId;
}


function getArrowParams (arrow) {

	// call with getArrowParams({x1: x1, x2: x2, y1: y1, y2: y2, tipLen: tipLen, tipWid, tipWid})

	const x1 = arrow.x1, y1 = arrow.y1, x2 = arrow.x2, y2 = arrow.y2;
	const tipLen = arrow.tipLen, tipWid = arrow.tipWid;
	if (x2!=x1 || y2!=y1) {
		const len = Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
		const arrowBackX = (y2-y1) * tipWid/2/len, arrowBackY = (x2-x1) * tipWid/2/len;

		arrow.arrowX1 = arrow.arrowX2 = arrow.newX2 = x1 + (x2-x1) * (len-tipLen)/len;
		arrow.arrowY1 = arrow.arrowY2 = arrow.newY2 = y1 + (y2-y1) * (len-tipLen)/len;
		arrow.arrowX1 += arrowBackX;
		arrow.arrowY1 -= arrowBackY;
		arrow.arrowX2 -= arrowBackX;
		arrow.arrowY2 += arrowBackY;
	}
	return arrow;
}

function getSVGForShape (point, shape, size) {

	let svgEl;
	switch (shape) {
		// "■●▲+x"
		case "■":
			svgEl = SVG("rect");
			svgEl.attrsSVG({
				x: point[0]-size/2,
				y: point[1]-size/2,
				width: size,
				height: size,
			});
			break;

		case "●":
			svgEl = SVG("circle");
			svgEl.attrsSVG({
				cx: point[0],
				cy: point[1],
				r: size/2,
			});
			break;

		case "▲":
			svgEl = SVG("path");
			svgEl.attrsSVG({
				d: `M${point[0]} ${point[1]+size/2}L${point[0]+size/2*0.86602540378} ${point[1]-size/2*0.5}L${point[0]-size/2*0.86602540378} ${point[1]-size/2*0.5}Z`,
			});
			break;

		case "+":
			svgEl = SVG("path");
			svgEl.attrsSVG({
				d: `M${point[0]-size/2} ${point[1]}L${point[0]+size/2} ${point[1]}M${point[0]} ${point[1]-size/2}L${point[0]} ${point[1]+size/2}`,
			});
			break;

		case "x":
			svgEl = SVG("path");
			svgEl.attrsSVG({
				d: `M${point[0]-size/2} ${point[1]-size/2}L${point[0]+size/2} ${point[1]+size/2}M${point[0]-size/2} ${point[1]+size/2}L${point[0]+size/2} ${point[1]-size/2}`,
			});
			break;
	}

	return svgEl;
}


function setActiveGlyph (g, instance) {

	// instance may be undefined

	let font = GLOBAL.vf;
	let ui = font.config.ui;
	const uiScale = font.unitsPerEm/1000
	if (g === undefined)
		g = 0;
	g *= 1;

	GLOBAL.currentGlyphId = g; // hmm, should be part of the font, not GLOBAL … TODO: check g < numGlyphs
	let glyph = font.glyphs[g];

	// highlight active glyph thumbnail (first, unhighlight all of them)
	Qall(".glyph-thumb").forEach(el => {
		el.classList.remove("active");
	});
	Q(`#g-${g}`).classList.add("active");

	let iglyph = glyphApplyVariations(glyph, null, instance);
	if (instance) {
		GLOBAL.tuple = [];
		instance.tuple.forEach((v,i) => {
			GLOBAL.tuple[i] = v; // deep copy
		})
		//GLOBAL.tuple = instance.tuple; // hmm, shallow copy should be ok, because if won’t be garbage collected
	}

	// clear main window and tvts panel
	let drawing = Q("#drawing");
	drawing.innerHTML = "";


	///////////////////////////////////////////////////////
	// Tuples panel
	///////////////////////////////////////////////////////

	// TODO: we shouldn’t be doing all this for each glyph refresh
	let panel = Q("#panel-tvts>div");
	panel.innerHTML = "";

	let layers = []; // layers are drawn from low values (bottom) to high values (top)


	let scale = 0.5 / uiScale;
	let opacity = 0.5;
	let svg = SVG("svg");
	let svgg = SVG("g"); // this transforms everything inside it
	svgg.id = "svg-transform-group";
	//let svgDefs = SVG("defs")
	//let svgMarker = SVG("marker")
	//let svgMarkerPath = SVG("path")
	svg.attrsSVG( {
		width: 1000,
		height: 1000,
		style: `background-color: ${ui.glyphDefault.backgroundColor};`,
	});
	svgg.setAttributeNS(null, "transform", `translate(130,500) scale(${scale},-${scale})`);

	/*
	// define marker
	svgMarker.id = "arrow";
	svgMarker.attrsSVG({
		markerWidth: 20,
		markerHeight: 20,
		fill: ui.arrow.color,
		orient: "auto",
		refX: 10,
		refY: 5,
	});
	svgMarkerPath.setAttributeNS(null, "d", "M 10 5 L 3 2 L 3 8 z");
	svgMarker.appendChild(svgMarkerPath);
	svgDefs.appendChild(svgMarker);
	*/

	/*
	// filters to use... not yet :)
	// - https://developer.mozilla.org/en-US/docs/Web/SVG/Element/filter
	let svgFilter = SVG("filter");
	svgFilter.setAttributeNS(null, "id","blur");
	let svgFilterBlur = SVG("feGaussianBlur");
	svgFilterBlur.setAttributeNS(null, "stdDeviation","5");
	svgFilter.appendChild(svgFilterBlur);
	svgDefs.appendChild(svgFilter);
	*/

	//svg.appendChild(svgDefs);


	// TODO: we're not yet using the layer idea, but I think it will be useful to allow us to make minimal updates
	let layerIds = [];
	layerIds.push(0);
	layerIds.push(1);
	layerIds.push(2);
	if (ui.loci && ui.loci.strokeWidth)
		layerIds.push(7);
	layerIds.push(3);
	if (Q("#arrows-total").checked && ui.arrow.strokeWidth)
		layerIds.push(4);
	layerIds.push(5);
	if (Q("#arrows-split").checked && ui.arrow.strokeWidth)
		layerIds.push(6);
	if (Q("#point-numbers").checked && CONFIG.ui.name != "preview")
		layerIds.push(8);

	layerIds.forEach(L => {

		let svgPath, svgg2, svgg3, paths;
		let layer = layers[L] = {
			on: true,
			svg: null,
		};
		let style = {
			size: 0,
			fill: "none",
			stroke: "none",
			strokeWidth: 0,
		};

		switch (L) {

			// cartesian axes, the grid (and metrics!)
			case 0:

				// draw cartesian axes
				if (ui.cartesianAxes.strokeWidth > 0 || ui.cartesianAxes.stroke != "none") {
					layer.id = "layer-grid";
					svgPath = SVG("path");
					svgPath.id = layer.id;
					svgPath.attrsSVG({
						d: "M-10000,0 L10000,0 M0,-10000 L0,10000",
						stroke: ui.cartesianAxes.stroke,
						"stroke-width": ui.cartesianAxes.strokeWidth * uiScale,
						fill: "none",
					});
					svgg.appendChild(svgPath);
				}

				// draw advance width
				if (ui.metrics.strokeWidth > 0 || ui.metrics.stroke != "none") {
					svgPath = SVG("path");
					svgPath.attrsSVG({
						d: `M${iglyph.points[glyph.points.length-3][0]} -10000V10000`, // glyph.points.length works for simple, composite and empty
						stroke: ui.metrics.stroke,
						"stroke-width": ui.metrics.strokeWidth * uiScale,
					});
					if (ui.metrics.dashArray) {
						let dashStr = "";
						ui.metrics.dashArray.forEach(dash => {
							dashStr += `${dash*uiScale} `;
						});
						svgPath.attrsSVG({
							"stroke-dasharray": dashStr,
						});
					}
					svgg.appendChild(svgPath);
				}

				break;


			// default
			case 1:
				layer.id = "layer-default";
				//svgPath = SVG("path");

				// draw glyph

				// we transform each component
				// - check each time we use getGlyphSVGpath()
				// - we take the translation from the glyph’s points property (which has been processed as usual by tvts)
				// - TODO: we’ll take the transformation matrix from the glyph’s components[p].transform
				// - must look up the order or processing: translate, transform or transform, translate (I recall that Apple and Microsoft differed on this)
				// - fonts using transforms are quite rare; Wingdings uses rotation and reflection in some ornaments
				// - https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform

				paths = getGlyphSVGpath(glyph);
				if (!Array.isArray(paths)) { // composite
					paths = [paths];
				}
				paths.forEach((path, p) => {
					svgg3 = glyph.numContours == -1 ? SVG("g") : null; // wrap component paths in a g
					svgPath = SVG("path"); // give this an id so we can detect clicks
					svgPath.attrsSVG({
						d: path,
						stroke: ui.glyphDefault.stroke,
						"stroke-width": ui.glyphDefault.strokeWidth * uiScale,
						fill: ui.glyphDefault.fill,
					});
					if (svgg3) {
						//svgg3.setAttributeNS(null, "transform", `translate(${iglyph.points[p][0]} ${iglyph.points[p][1]})`);
						// glyph.points[0] is the xy offset of the first component,
						// glyph.points[1] is the xy offset of the second component, etc.
						svgg3.setAttributeNS(null, "transform", `translate(${glyph.points[p][0]} ${glyph.points[p][1]})`);
						svgg3.appendChild(svgPath);
						svgg.appendChild(svgg3);
						svgg3.id = layer.id;
					}
					else {
						svgPath.id = layer.id;
						svgg.appendChild(svgPath);
					}
				});

				break;


			// instance
			case 2:
				layer.id = "layer-instance";

				// draw glyph with variations taken from the current axis settings
				// - should we render all active instances in this "layer"?
				/*
				svgPath = SVG("path");
				svgPath.attrsSVG({
					"style": `opacity:${opacity}`,
					"d": getGlyphSVGpath(iglyph),
					"stroke": `black`, // make this take a value from the ui confi
					"stroke-width": `${GLOBAL.vf.config.ui.glyph.strokeWidth}px`,
					"fill": `#00f`,
					// "filter": "url(#blur)", not yet :)					
				});
				*/

				paths = getGlyphSVGpath(iglyph);
				if (!Array.isArray(paths)) { // composite
					paths = [paths];
				}
				let uiStyle = ui.glyphCurrent;
				paths.forEach((path, p) => {
					svgg3 = iglyph.numContours == -1 ? SVG("g") : null; // wrap component paths in a g
					svgPath = SVG("path"); // give this an id so we can detect clicks
					svgPath.attrsSVG({
						d: path,
						style: `opacity: ${uiStyle.opacity}`,
						stroke: uiStyle.stroke,
						"stroke-width": uiStyle.strokeWidth * uiScale,
						fill: `${uiStyle.fill}`,
						// "filter": "url(#blur)", not yet :)					
					});
					if (svgg3) {
						//svgPath.id = `g${iglyph.id}-c${p}`; // "g27-c2" means component #2 of glyph #27
						svgg3.setAttributeNS(null, "transform", `translate(${iglyph.points[p][0]} ${iglyph.points[p][1]})`);
						svgg3.appendChild(svgPath);
						svgg.appendChild(svgg3);
						svgg3.id = layer.id;
					}
					else {
						//svgg3.id = `g${iglyph.id}`; // "g27" means glyph 27
						svgg.appendChild(svgPath);
						svgPath.id = layer.id;
					}
				});

				break;

/*

			case 3:
				// TODO: decide how to show "points" for composites… origin, so we see translations?
				layer.id = "layer-instance-points";
				svgg2 = SVG("g");
				svgg2.id = layer.id;

				iglyph.points.forEach(function (pt, p) {
					let size = ui.point.size;
					let svgP;
					if (pt[2]) {
						svgP = SVG("rect"); // on-curve
						svgP.classList.add("ctrl-pt");
						svgP.attrsSVG({
							x: pt[0]-size, y: pt[1]-size,
							width: 2*size, height: 2*size,
						});
					}
					else {
						svgP = SVG("circle"); // off-curve
						svgP.classList.add("ctrl-pt");
						svgP.attrsSVG({ cx: pt[0], cy: pt[1], r: 4 });
					}
					svgP.data = { point: pt };
					svgg2.appendChild(svgP);
				});

				svgg.appendChild(svgg2);
				break;
*/

			// arrows: total
			case 4:
				layer.id = "layer-arrows-total";

				svgg2 = SVG("g");
				svgg2.id = layer.id;
				svgg2.attrsSVG({
					"stroke": ui.arrow.color,
					"stroke-width": ui.arrow.strokeWidth * uiScale,
				});

				// TODO: Make a function to draw arrows that the "split arrows" method can use too
				glyph.points.forEach((point1, pt) => {
					let point2 = iglyph.points[pt]; // transformed point
					let x1 = point1[0], y1 = point1[1], x2 = point2[0], y2 = point2[1];
					if (x1==x2 && y1==y2) {
						// same location so no line (now we can ignore divide-by-zero in the else{}
					}
					else {
						// get the arrow parameters so we can draw a truncated line (maybe dotted) plus arrow head
						//let arrow = getArrowParams (x1, y1, x2, y2);
						let arrow = getArrowParams ({x1: x1, y1: y1, x2: x2, y2: y2, tipWid: ui.arrow.tipWidth * GLOBAL.vf.unitsPerEm/1000, tipLen: ui.arrow.tipLength * GLOBAL.vf.unitsPerEm/1000});
						let svgLine = SVG("line");
						let svgArrowHead = SVG("path");
						svgLine.attrsSVG({ x1: x1, y1: y1, x2: arrow.newX2, y2: arrow.newY2 });
						svgArrowHead.attrsSVG({
							d: `M${x2} ${y2}L${arrow.arrowX1} ${arrow.arrowY1}L${arrow.arrowX2} ${arrow.arrowY2}Z`,
							fill: ui.arrow.color,
							stroke: "none",
						});

						if (!iglyph.touched[pt]) {
							svgLine.attrsSVG({ "stroke-dasharray": 4 * uiScale }); // IUP implicit movement
						}

						svgg2.appendChild(svgLine);
						svgg2.appendChild(svgArrowHead);

					}
				});										

				svgg.appendChild(svgg2);
				break;


			// control points
			case 3:
			case 5:
				// draw control points, grouped in their own <g>
				if (L==3)
					layer.id = "layer-instance-points";
				else if (L==5)
					layer.id = "layer-points";
				else
					layer.id = "layer-invalid";

				// set style, with overrides
				Object.keys(ui.point).forEach(k => {
					style[k] = ui.point[k];
				});
				if (L==3 && ui.glyphCurrent.point)
					Object.keys(ui.glyphCurrent.point).forEach(k => {
						style[k] = ui.glyphCurrent.point[k];
					});
				else if (L==5 && ui.glyphDefault.point)
					Object.keys(ui.glyphDefault.point).forEach(k => {
						style[k] = ui.glyphDefault.point[k];
					});

				// only draw if they’re wanted
				if (style.size > 0) {				
					
					// create group element
					svgg2 = SVG("g");
					svgg2.id = layer.id;

					// set attrs
					svgg2.attrsSVG({
						fill: style.fill,
						"stroke-width": style.strokeWidth * uiScale,
						stroke: style.stroke,
						opacity: style.opacity,
					});

					// draw the points
					(L==3 ? iglyph : glyph).points.forEach(function (pt, p) {
						let svgEl = getSVGForShape (
							pt,
							pt[2] ? style.shape : style.shapeOffCurve,
							style.size * uiScale);
						svgg2.appendChild(svgEl);
					});

					svgg.appendChild(svgg2);
				}
				break;


			// arrows: split
			case 6:

				layer.id = "layer-arrows-split";
				svgg2 = SVG("g");
				svgg2.id = layer.id;
				svgg2.attrsSVG({
					"fill": "none",
					"stroke-width": 3,
					"stroke": "green",
				});

				glyph.points.forEach((point, pt) => {

					let x1 = point[0], y1 = point[1];
					let x2, y2;

					// make an arrow for each tvt
					glyph.tvts.forEach((tvt, t) => {
						let sValue = iglyph.tvtsVisualization[t].S;
						let delta = tvt.deltas[pt];
						let iup = (delta === null);
						let lineColor = ui.tuple.colors[t % ui.tuple.colors.length]; // get the t’th colour in the array, wrapping round to the start when we run out of colours

						if (iup) {
							x2 = x1 + iglyph.tvtsVisualization[t].scaledDeltas[pt][0];
							y2 = y1 + iglyph.tvtsVisualization[t].scaledDeltas[pt][1];
						}
						else {							
							x2 = x1 + delta[0] * sValue;
							y2 = y1 + delta[1] * sValue;
						}

						if (x2!=x1 || y2!=y1) {

							// Arrows:
							// We avoid SVG’s built-in method of attaching shapes to lines, and make a separate line and arrowhead
							// Thick lines blunt pointed arrows, so we draw each line up to the base of the arrowhead.
							// It might be more efficient to draw each tuple’s lines as one path
							// - but the resulting SVG would be ugly to edit
							// - and we’d also have to make separate paths for IUP and non-IUP arrows
							//let arrow = getArrowParams (x1, y1, x2, y2);
							let arrow = getArrowParams ({x1: x1, y1: y1, x2: x2, y2: y2, tipWid: ui.arrow.tipWidth * GLOBAL.vf.unitsPerEm/1000, tipLen: ui.arrow.tipLength * GLOBAL.vf.unitsPerEm/1000});

							// make the line
							let svgLine = SVG("line");
							svgLine.attrsSVG({
								x1: x1, y1: y1, x2: arrow.newX2, y2: arrow.newY2,
								stroke: lineColor,
								"stroke-width": ui.arrow.strokeWidth * uiScale,
							});
							if (iup)
								svgLine.attrsSVG({ "stroke-dasharray": 4 * uiScale });

							// make the arrowhead with SVG path
							// - SVG polygon more efficient, but less flexible if we want a special shape
							let svgArrowHead = SVG("path");
							svgArrowHead.attrsSVG({
								d: `M${x2} ${y2}L${arrow.arrowX1} ${arrow.arrowY1}L${arrow.arrowX2} ${arrow.arrowY2}Z`,
								fill: lineColor,
								stroke: "none",
							});

							svgg2.appendChild(svgLine);
							svgg2.appendChild(svgArrowHead);
						}
						// show "pinned" points with a circle (these are points with 0,0 deltas, that protect other unmoved points that also do not move because of IUP)
						// - hmm, not sure it is a good idea to try to visualize "pinned" points
						// - they might be pinned by 1 axis, IUP’d by another axis, and moved by yet another axis
						// - maybe useful only if you have one single-tuple axis active?
						/*
						else if (!iup && (delta[0] === 0 && delta[1] === 0)) {

							console.log("circle!");
							let svgCircle = SVG("circle");
							svgCircle.attrsSVG({
								cx: x1,
								cy: y1,
								r: 28,
								stroke: lineColor,
							});
							svgg2.appendChild(svgCircle);
						}
						*/

						x1 = x2;
						y1 = y2;
					});
				});

				svgg.appendChild(svgg2);
				break;


			// loci
			case 7: 
				layer.id = "layer-loci";
				const steps = ui.loci.steps; // we will make steps+1 instances
				let lociX = [], lociY = []; // one for each point

				svgg2 = SVG("g");
				svgg2.id = layer.id + "-X";
				svgg2.attrsSVG({
					"fill": "none",
				});

				// trace X loci from -1 to 1
				// TODO: force inclusion of default location and all axis peaks
				for (let s=0; s<steps; s++) {

					let lociInstanceX, lociInstanceY, iglyphX, iglyphY;
					let T = -1.0 + s/(steps-1) * 2.0;

					// initialize tuple
					let tupleX = [], tupleY = [];
					for (let a=0; a < font.axes.length; a++) {
						tupleX[a] = tupleY[a] = GLOBAL.tuple[a];
					}

					// check which tuple values are non-default
					// - what VF axes are attached to the X and Y axes?
					Qall("#xSelect input:checked").forEach(el => {
						font.axisIndices(el.value).forEach(i => tupleX[i] = T );
					});
					Qall("#ySelect input:checked").forEach(el => {
						font.axisIndices(el.value).forEach(i => tupleY[i] = T );
					});
					
					// make instance
					lociInstanceX = font.addInstance(null, {tuple: tupleX});
					lociInstanceY = font.addInstance(null, {tuple: tupleY});
					iglyphX = glyphApplyVariations(glyph, null, lociInstanceX, {roundDeltas: false});
					iglyphY = glyphApplyVariations(glyph, null, lociInstanceY, {roundDeltas: false});

					// build the SVG polylines in parallel
					for (let p=0; p<glyph.points.length; p++) {
						if (s==0) {
							lociX[p] = "";
							lociY[p] = "";
						}
						else {
							lociX[p] += " ";
							lociY[p] += " ";
						}
						lociX[p] += `${iglyphX.points[p][0]},${iglyphX.points[p][1]}`;
						lociY[p] += `${iglyphY.points[p][0]},${iglyphY.points[p][1]}`;
					}

					// pop instances
					font.instances.pop();
					font.instances.pop();
				}

				// create the SVG element, one set of elements per point
				for (let p=0; p<glyph.points.length; p++) {

					[lociX, lociY].forEach(LOCI => {

						let svgPolyline;

						// draw initial polyline
						svgPolyline = SVG("polyline");
						svgPolyline.attrsSVG({
							points: LOCI[p],
							stroke: LOCI===lociX ? ui.designspace.colors[0] : ui.designspace.colors[1],
							"stroke-width": ui.loci.strokeWidth * uiScale,
							opacity: ui.loci.opacity,
						});
						svgg2.appendChild(svgPolyline);

						// if railway mode, draw extra lines
						if (ui.loci.style == "railway") {

							svgPolyline = SVG("polyline");
							svgPolyline.attrsSVG({
								points: LOCI[p],
								stroke: "white",
								"stroke-width": ui.loci.strokeWidth / 1.5 * uiScale,
							});
							svgg2.appendChild(svgPolyline);

							svgPolyline = SVG("polyline");
							svgPolyline.attrsSVG({
								points: LOCI[p],
								stroke: LOCI===lociX ? ui.designspace.colors[0] : ui.designspace.colors[1],
								"stroke-width": ui.loci.strokeWidth * 1.5 * uiScale,
								"stroke-dasharray": `${1*uiScale} ${5*uiScale}`,
							});
							svgg2.appendChild(svgPolyline);
						}

					});

				}

				svgg.appendChild(svgg2);
				break;

			// point numbers
			case 8: 

				layer.id = "layer-pointnumbers";

				svgg2 = SVG("g");
				svgg2.id = layer.id;
				svgg2.attrsSVG({
					"fill": ui.pointNumbers.color || "black",
					"stroke": "none",
				});

				let xOffset = yOffset = ui.pointNumbers.offset || 0;
				let angle = ui.pointNumbers.angle * Math.PI/180 || 0;
				angle = Math.PI - angle;
				xOffset *= Math.sin(angle) * uiScale;
				yOffset *= Math.cos(angle) * uiScale;

				iglyph.points.forEach((point, pt) => {

					// make a text element for each point
					let svgText = SVG("text");
					svgText.textContent = pt;

					svgText.attrsSVG({
						x: point[0]+xOffset,
						y: point[1]+yOffset,
						style: `font-weight: normal; font-size: ${24*uiScale}px;`,
						class: "point-number",
						transform: `translate(0,${2*point[1]}) scale(1,-1)`,
					});

					// if angle points to the left of the point, make the number’s text anchor on the right hand side
					if (xOffset < 0)
						svgText.attrsSVG({
							"text-anchor": "end",
						});

					svgg2.appendChild(svgText);
				});

				svgg.appendChild(svgg2);
				break;
		}


		// add layer to the view
		layer.svg = svg;

	});


	svg.appendChild(svgg);
	drawing.appendChild(svg);

	// drawing layers
	// - coordinate grid
	// - default glyph (options: control points)
	// - transformed glyph (options: control points, arrows, per-tuple arrows)
	// - point loci
	// each layer can be on/off


	// default glyph



	// display the tvts

	glyph.tvts.forEach((tvt, t) => {

		// header row
		if (t==0) {
			let liH = document.createElement("li");
			liH.style.display = "grid";
			liH.style.gridTemplateColumns = `1.5em 80px 45px repeat(${GLOBAL.vf.axisCount}, 45px)`
			liH.innerHTML = `<label>ID</label><label>Deltas</label><label>Scalar</label>`;
			GLOBAL.vf.axes.forEach(axis => {
				liH.innerHTML += `<label style="width:100%; text-align:center;"><tt>${axis.tag}</tt></label>`;
			});
			
			panel.appendChild(liH);
		}

		let li = document.createElement("li");
		li.classList.add("tvt");

		// we mention some stuff about tvt id, then numpoints moved or something, then (aligning with axes in instance panel) an SVG graph for each axis
		li.style.display = "grid";
		li.style.gridTemplateColumns = `1.5em 80px 45px repeat(${GLOBAL.vf.axisCount}, 45px)`
		li.style.backgroundColor = "lightgrey";
		li.style.height = "20px";

		let tvtId = document.createElement("div");
		tvtId.innerText = t;
		tvtId.style.backgroundColor = ui.tuple.colors[t % ui.tuple.colors.length];
		tvtId.style.color = "white";
		tvtId.style.fontWeight = "bold";
		tvtId.style.textAlign = "center";

		let tvtDeltas = document.createElement("div");
		let numDeltas = 0;
		for (let p=0; p<tvt.deltas.length; p++) {
			if (tvt.deltas[p] !== null)
				numDeltas++;
		}
		tvtDeltas.innerHTML = `&nbsp;<span class="icon bold reveal open" style="position: static;">&#xf04b;</span>` + ` ${numDeltas}`;
		tvtDeltas.setAttribute("title", `This tuple variation moves ${tvt.deltas.length-numDeltas} points via IUP.`);

		// draw S value as bar graph
		let sValue = iglyph.tvtsVisualization[t].S;
		let tvtS = document.createElement("div");
		let vizWidth = Math.max(0.25, 40 * sValue); // minimum of 0.25px
		tvtS.setAttribute("title", sValue);
		if (sValue > 0) {
			tvtS.setAttribute("style", `width: ${vizWidth}px; height: 20px; background-color: ${ui.tupleScalar.fill};`);
			li.style.backgroundColor = "white";
		}

		li.appendChild(tvtId);
		li.appendChild(tvtDeltas);
		li.appendChild(tvtS);


		// add a graph for each axis
		// - each graph is a single SVG element with descendants
		// - each tuple contains <font.numAxes> graphs representing how this tuple responds to each axis
		for (let a=0; a<GLOBAL.vf.axisCount; a++) {
			let tvtGraphEl = document.createElement("div");
			let tvtGraph = SVG("svg");
			let svgg = SVG("g");

			tvtGraph.setAttributeNS(null, "width","50");
			tvtGraph.setAttributeNS(null, "height","21");
			svgg.setAttributeNS(null, "transform", `translate(20,20) scale(1,-1)`);


			// draw a graph through start, peak, end for each axis
			let Sx = 20, Sy = 20; // x and y scales

			// draw graph paper
			let pathG = SVG("path");
			//let pathD = pathD = `M ${Sx*-1},0 L ${Sx*tvt.start[a]},0 L ${Sx*tvt.peak[a]},${Sy} L ${Sx*tvt.end[a]},0`;
			pathG.setAttributeNS(null, "fill", "none");
			pathG.setAttributeNS(null, "stroke", "darkgrey");
			pathG.setAttributeNS(null, "stroke-width", "0.5");
			pathG.setAttributeNS(null, "d", `M ${Sx*-1} 0 L ${Sx*1} 0 M 0 0 L 0 ${Sy*1}`);
			svgg.appendChild(pathG);

			// draw tuple start, peak, end data
			if (tvt.peak[a] != 0) { // “When a delta is provided for a region defined by n-tuples that have a peak value of 0 for some axis, then that axis does not factor into scalar calculations.”
				// typicaly graphs are shown at https://docs.microsoft.com/en-us/typography/opentype/spec/otvaroverview
				let path = SVG("path");
				let pathD = `M ${Sx*tvt.start[a]},0 L ${Sx*tvt.peak[a]},${Sy*1.0} L ${Sx*tvt.end[a]},0`;
				path.setAttributeNS(null, "fill", "black");
				path.setAttributeNS(null, "stroke", "none");
				path.setAttributeNS(null, "d", pathD);
				svgg.appendChild(path);

				// draw current axis position
				if (iglyph.instance && iglyph.instance.tuple[a] != 0) {
					let needle = SVG("line");
					let needleColor = ui.tupleNeedle.stroke;
					needle.attrsSVG({fill: "none", stroke: needleColor, "stroke-width": "1px", x1: iglyph.instance.tuple[a]*20, y1: 0, x2: iglyph.instance.tuple[a]*20, y2: 20});
					svgg.appendChild(needle);
				}
			}

			tvtGraph.appendChild(svgg);
			tvtGraphEl.appendChild(tvtGraph);

			tvtGraphEl.style.textAlign = "right";
			li.appendChild(tvtGraphEl);
		}
		
		panel.appendChild(li);

		// display the actual deltas for this tuple
		tvtDeltas.addEventListener("click", function (event) {
			let str = "";
			tvt.deltas.forEach((delta, p) => {
				str += `${p}: `;
				if (delta === null)
					str += "—";
				else
					str += `${Math.round(sValue*delta[0])},${Math.round(sValue*delta[1])}`;
				str += "\n";
			});
			alert (str);
		});

	});

}


function playGlyphs() {
	let g = (getActiveGlyph()+1) % GLOBAL.vf.numGlyphs;
	let instance = GLOBAL.vf.addInstance(null, {tuple: GLOBAL.tuple});
	setActiveGlyph (g, instance);
	GLOBAL.vf.instances.pop();
	GLOBAL.vf.timerGlyphPlayer = setTimeout (playGlyphs, 500);
}


// click handlers for all clicks
document.onclick = function (event) {

	console.log(event.target);
	// about target
	// - via the method of assignment in the if(), target gets the desired element rather than a child (or grandchild) that in fact received the event
	// - the closest(x) method is great: we find whether event.target happened on something within something selected by x
	// - order matters! (e.g. an icon within an instance row must be handled before the instance row itself)
	let target;
	let font = GLOBAL.vf;
	const saveScrollY = Q("#controls").scrollTop; // fixes Safari macOS 10.14 bug where controls panel scrolls to top on most interactions
	let handled = false;

	// load default font
	if (event.target == Q("#font-file")) {
		
		Q("body").style.cursor = "wait";

		let vf = new SamsaFont({
			fontFamily: "DefaultFont",
			url: `${GLOBAL.fontList.directory}/${GLOBAL.fontList.default}`, // "fonts/MutatorSans.ttf"
			callback: vfLoaded,
		});

		handled = true;
	}

	else if (target = event.target.closest("#controls .panel .instantiate")) {

		// create and download the instance		
		let instanceEl = target.closest(".instance");
		let instance = instanceEl.data.instance;

		GLOBAL.vf.makeInstance(instance); // creates instance.static

		let fauxLink = document.createElement("a");
		fauxLink.download = GLOBAL.vf.filename;
		fauxLink.href = "data:font/ttf;base64," + uint8ToBase64(instance.static);

		document.body.appendChild(fauxLink); // needed for Firefox, not Chrome or Safari
		fauxLink.click();
		fauxLink.remove();

		handled = true;
	}

	else if (target = event.target.closest(".instance")) {

		setActiveInstance(GLOBAL.vf, target);
		handled = true;
	}

	else if (target = event.target.closest("#panel-axes .header .icon")) {

		let fvs = {}, redraw = true;
		if (target.classList.contains("default")) {
			GLOBAL.vf.axes.forEach((axis,a) => {
				fvs[axis.tag] = axis.default;
			});
		}
		else if (target.classList.contains("min")) {
			GLOBAL.vf.axes.forEach((axis,a) => {
				fvs[axis.tag] = axis.min;
			});
		}
		else if (target.classList.contains("max")) {
			GLOBAL.vf.axes.forEach((axis,a) => {
				fvs[axis.tag] = axis.max;
			});
		}
		else
			redraw = false;

		if (redraw) {
			let instance = font.addInstance(fvs);
			setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
			font.instances.pop();
			axesUpdateValues();
			panelSTAT_handleChange();
			panelWebfont_handleChange();
			setAxes (GLOBAL.vf, fvs);
		}
		handled = true;
	}

	else if (event.target.classList.contains("ctrl-pt")) {
		console.log("click pt", event.target);
		console.log(event.target.data.point);
		handled = true;
	}

	else if (target = event.target.closest("#controls .panel>h2 .info")) {

		// load help file
		const helpFile = target.parentNode.parentNode.id + ".md"; // one of these for each panel, so panel-glyphs.md, panel-stat.md, etc.

		fetch(`help/${helpFile}`)
		.then(response => {
				return response.text();
			}, 
			error => {
				return "## No response from server\n\nHelp files are only available when Samsa is installed on a web server.";
				console.log ("No response from server: Samsa was probably run by double-clicking the html file, so under file:// instead of https://");
			}
		)
		.then(doc => {

			doc = ">>> EXPERIMENTAL HELP DISPLAY <<<\n\n" + doc;

 			// linebreaks
			doc = doc.replace( /\n\n/g, "<br>\n\n");
			doc = doc.replace( /  \n/g, "<br>\n");

			// numbered lists
			// - m is multiline, g is global
			doc = doc.replace( /\n\n^\d+\. (.+?)$/gm, "\n\n<ol><li>$1</li>"); // first
			doc = doc.replace( /^\d+\. (.*?)$\n\n/gm, "\n<li>$1</li></ol>\n"); // last
			doc = doc.replace( /^\d+\. (.+?)$/gm, "\n<li>$1</li>"); // middle

			// unnumbered lists
			doc = doc.replace( /\n\n(\*|-) (.+?)$/gm, "\n\n<ul><li>$2</li>"); // first
			doc = doc.replace( /^(\*|-) (.*?)$\n\n/gm, "\n<li>$2</li></ul>\n"); // last
			doc = doc.replace( /^(\*|-) (.+?)$/gm, "\n<li>$2</li>"); // middle

			doc = doc.replace( /(\*\*|__)([^\n]+?)(\*\*|__)/g, `<strong>$2</strong>`); // bold
			doc = doc.replace( /(\*|_)([^\n]+?)(\*|_)/g, `<em>$2</em>`); // italic

			// headings
			doc = doc.replace( /### (.*)\n/g, "<h3>$1</h3>\n"); // h3
			doc = doc.replace( /## (.*)\n/g, "<h2>$1</h2>\n"); // h2
			doc = doc.replace( /# (.*)\n/g, "<h1>$1</h1>\n"); // h1

			// links
			doc = doc.replace( /\[([^\]]*?)\]\(([^)]*?)\)/g, `<a href="$2">$1</a>`); // links

			// code
			// - TODO code blocks
			doc = doc.replace( /`([^ \n]*?)`/g, `<tt>$1</tt>`); // <tt>

			// build ui
			const overlay = EL("div");
			overlay.classList.add("popup-overlay");
			document.body.appendChild(overlay);

			const help = EL("div");
			help.id = "help-overlay";
			help.classList.add("popup-modal");
			help.innerHTML = doc;
			document.body.appendChild(help);

			const closeButton = EL("button");
			closeButton.style.position = "absolute";
			closeButton.style.top = "1em";
			closeButton.style.right = "2em";
			closeButton.innerText = "Close";
			help.appendChild(closeButton);

			closeButton.addEventListener("click", removeOverlay);
			overlay.addEventListener("click", removeOverlay);
						
		});
		handled = true;
	}

	else if (target = event.target.closest("#panel-glyphs>h2") 
			&& event.target.classList.contains("icon")
			&& !event.target.classList.contains("reveal")) { // this test must be before the other h2 test

		let g;
		let step = false;
		clearTimeout(font.timerGlyphPlayer);
		
		switch (event.target.id) {

			case "glyphs-stepforward":
				g = getActiveGlyph()+1;
				step = true;
				break;
			case "glyphs-stepback":
				g = getActiveGlyph()-1+font.numGlyphs;
				step = true;
				break;
			case "glyphs-play":
				playGlyphs();
				break;
			case "glyphs-stop":
				clearTimeout(font.timerGlyphPlayer);
				font.timerGlyphPlayer = undefined;
				break;
		}

		if (step) {
			let instance = font.addInstance(null, {tuple: GLOBAL.tuple});
			g %= font.numGlyphs;
			clearTimeout(font.timerGlyphPlayer);
			setActiveGlyph (g, instance);
			font.instances.pop();
		}

		handled = true;
	}

	else if (target = event.target.closest("#panel-glyphs>h2") 
			&& event.target.id == "glyphs-ids") {

		// toggle the display of the spans inside the label
		let active = Q("#glyphs-ids").classList.toggle("active");
		let glyphLabels = Qall("#panel-glyphs .glyph-thumb label");
		glyphLabels.forEach(label => {			
			label.querySelector(".number").style.display = active ? "inline" : "none";
			label.querySelector(".name").style.display = active ? "none" : "inline";
		})
		handled = true;
	}

	else if (target = event.target.closest("#controls .panel>h2")) {

		// toggle display of panel when panel header is clicked
		let panelDiv = target.parentNode.querySelector("div.panel-content");
		console.log(panelDiv);
		target.parentNode.classList.toggle("open");
		if (target.parentNode.classList.contains("open"))
			panelDiv.style.display = "block";
		else
			panelDiv.style.display = "none";
		handled = true;
	}



	else if (target = event.target.closest(".glyph-thumb")) {

		let comps = target.id.split("-");
		let g = comps[1];
		event.preventDefault(); // stops the <a href...> having an effect?

		let instance = font.addInstance(null, {tuple: GLOBAL.tuple});
		setActiveGlyph(g, instance);
		font.instances.pop();
		handled = true;
	}

	else if (event.target.classList.contains("axis-nudge")) {

		const delta = event.target.innerHTML == "+" ? 1 : -1; // is the delta +1 or -1? the decrementer innerHTML can be - (hyphen-minus) or − (minus sign) or in fact anything except +
		const axis = event.target.closest("li").data.axis; // which axis is this?
		GLOBAL.tuple[axis.id] += delta/16384; // adjust the tuple
		if (GLOBAL.tuple[axis.id] > 1)
			GLOBAL.tuple[axis.id] = 1;
		if (GLOBAL.tuple[axis.id] < -1)
			GLOBAL.tuple[axis.id] = -1;

		let instance = font.addInstance(null, {tuple: GLOBAL.tuple});
		setActiveGlyph(GLOBAL.currentGlyphId, instance);
		axesUpdateValues();
		panelSTAT_handleChange();
		panelWebfont_handleChange();
		setAxes (font, font.tupleToFvs(GLOBAL.tuple));
		font.instances.pop();
		handled = true;
	}

	else if (target = event.target.closest("#panel-font-list .font-file")) {

		// load font from the list
		event.preventDefault(); // stops the <a href...> having an effect?

		let vf = new SamsaFont({

			fontFamily: "FontNameShouldGoHere",
			url: `${GLOBAL.fontList.directory}/${target.innerText}`,
			callback: vfLoaded,
		});
		handled = true;
	}

	if (handled) {
		Q("#controls").scrollTop = saveScrollY; // for the macOS 10.14 bug referenced at the start of this click handler
		return false;
	}

	// no return value if the event was not handled
	return true;
}


// handle click to upload file
Q("#file-upload-input").addEventListener("change", ev => {

	console.log("ok we got input");
	console.log(ev.target.files[0]);

	const file = ev.target.files[0];

	Q("body").style.cursor = "wait";

    const reader = new FileReader();
    reader.__file__ = file;
    reader.onload = function (event) {

		console.log (this.result);
		console.log (event.target);
		console.log(this.__file__.size);
		let vf = new SamsaFont({

			arrayBuffer: this.result,
			inFile: this.__file__.name,
			filesize: this.__file__.size,
			date: this.__file__.lastModified,  // doesn't retrieve the real file date
			callback: vfLoaded,
		});
	};

	reader.readAsArrayBuffer(file); // https://stackoverflow.com/questions/22659164/read-a-drag-and-dropped-file

});

// show that dragging is active
Q("#file-upload-input").addEventListener("dragenter", ev => {
	Q("#drag-drop-zone").style.borderColor = "limegreen"; //"#d0f473";
});
Q("#file-upload-input").addEventListener("dragleave", ev => {
	Q("#drag-drop-zone").style.borderColor = "grey";
});


// destroy the elements that make the overlay popup
function removeOverlay () {

	Qall(".popup-overlay, .popup-modal").forEach(el => {
		el.remove();
	});
}


// handle the drag-drop
// - https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/File_drag_and_drop
function dropHandler(ev) {
  
	console.log("dropHandler");
	ev.preventDefault(); // prevent default behavior (which is to open the file)

	Q("body").style.cursor = "wait";

	if (ev.dataTransfer.items) {
		const numItems = 1; // ev.dataTransfer.items.length; // for now, only process the first file dropped

		for (let i = 0; i < numItems; i++) {

			// if this item is not a file, reject it
			if (ev.dataTransfer.items[i].kind === "file") {
				const file = ev.dataTransfer.items[i].getAsFile();
				const reader = new FileReader();
				reader.__file__ = file;
				reader.onload = function (event) {

					let vf = new SamsaFont({
						arrayBuffer: event.target.result,
						inFile: this.__file__.name,
						filesize: this.__file__.size,
						date: this.__file__.lastModified,  // doesn't retrieve the real file date
						callback: vfLoaded,
					});
				};
			reader.readAsArrayBuffer(file); // https://stackoverflow.com/questions/22659164/read-a-drag-and-dropped-file
			}
		}
	}
}

Q("#font-file").addEventListener("drop", dropHandler);
Q("#font-file").addEventListener("dragover",function(e){
	e = e || event;
	e.preventDefault();
},false);





// method to attach multiple SVG attributes at once
// - example of attrs: { d: path, stroke: "black", "stroke-width": "2px", fill: "#eee" }
SVGElement.prototype.attrsSVG = function (attrs) {
	for (const prop in attrs) {
		this.setAttributeNS(null, prop, attrs[prop]);
	}
};



function getArrowPathForLine(x1, y1, x2, y2, width, arrowLength, arrowWidth) {
	// returns a string suitable for use as the SVG path "d" attribute
	// it solves two problem of SVG lines when used with a pointed arrow:
	// 1. the line is printed on top of the arrow-head, making the tip blunt
	// 2. markers have colour in themselves, which is not useful when each line needs a custom colour

	// for a line pointing due east, we start at the bottom left corner and go anticlockwise
	// - Hmmm, this won’t work with dash-array for dotted lines

/*
	if (x1==x2 && y1==y2)
		return "M0 0Z";

	let path = `M${x1} ${y1}`;
	let angle = Math.atan2(y2-y1, x2-x1);
	let len = Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
	let anglePerp = angle - Math.PI;
	let xn = (x2-x1)/len;
	let yn = (y2-y1)/len;
	let c = y2-y1, x2-x1
	path += `l${yn*width/2} ${xn*width/2}`;
	path += `l${x2-x1-arrowLength*xn} ${y2-y1-arrowLength*yn}`;
	path += `l${yn*(arrowWidth-width)/2} ${xn*(arrowWidth-width)/2}`;
	path += `L${x1} ${y2}`; // now we are at the tip
	//path += `l${yn*(arrowWidth-width)/2} ${xn*(arrowWidth-width)/2}`;`;
	//path += `l`;
	//path += `l`;
	path += "z";
*/
	return path;
}



// load the list of fonts from samsa-fonts.json into the font-list panel
// - this is the list of fonts available for 1-click loading
// - only for normal web server ("http:" or "https:", not "file:")
if (["http:", "https:"].includes(window.location.protocol)) {

	fetch("samsa-fonts.json")
	.then(response => {
			return response.json(); // another promise, not a string!
		}, 
		error => {
			console.log (error);
		}
	)
	.then(responseJSON => { // then for the json() promise
		// populate the font list panel
		let panel = Q("#panel-font-list>div");
		panel.innerHTML = "";
		GLOBAL.fontList = responseJSON;
		GLOBAL.fontList.fonts.forEach(fontFilename => {
			panel.innerHTML += `<li class="font-file">${fontFilename}</li>`;
		});
	});
}
else {
	let panel = Q("#panel-font-list>div");
	panel.innerHTML = `<div>Remote file loading is not available for protocol “${window.location.protocol}”</div>`;
}



document.addEventListener("keydown", ev => {

	if (ev.key == " " && GLOBAL.vf) {
		const el = ev.target;
		const tagName = el.tagName.toLowerCase();
		if (el.isContentEditable || (tagName == "input" && el.type == "text") || tagName == "textarea") {
			return true;
		}

		if (ev.repeat) {
			ev.preventDefault(); // we don’t want anything to scroll, which is default behaviour for space
			return true;
		}

		// switch to preview mode if not in preview mode
		ev.preventDefault();
		if (Q("#ui-mode").value != "preview") {
			const saveScrollY = Q("#controls").scrollTop; // fixes Safari macOS 10.14 bug where controls panel scrolls to top on most interactions
			GLOBAL.quickPreviewSaved = GLOBAL.vf.config.ui.name;
			GLOBAL.vf.config.ui = GLOBAL.vf.config.uiModes["preview"];
			let instance = GLOBAL.vf.addInstance(null, {tuple: GLOBAL.tuple});
			setActiveGlyph (GLOBAL.currentGlyphId, instance);
			GLOBAL.vf.instances.pop();
			Q("#controls").scrollTop = saveScrollY; // for the macOS 10.14 bug referenced at the start of this click handler
		}
		return false;
	}

	if (ev.keyCode == 27) {
		removeOverlay();
	}

});


document.addEventListener("keyup", ev => {

	if (ev.key == " " && GLOBAL.vf) {
		// switch to preview mode if not in preview mode
		if (GLOBAL.quickPreviewSaved) {
			ev.preventDefault();
			GLOBAL.vf.config.ui = GLOBAL.vf.config.uiModes[GLOBAL.quickPreviewSaved];
			GLOBAL.quickPreviewSaved = null;
			let instance = GLOBAL.vf.addInstance(null, {tuple: GLOBAL.tuple});
			setActiveGlyph (GLOBAL.currentGlyphId, instance);
			GLOBAL.vf.instances.pop();
		}
		return false;
	}

});

</script>


</body>
</html>