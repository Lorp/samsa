<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="utf-8">
<title>Samsa: Variable Font Inspector</title>

<script src="samsa-core.js"></script>

<link rel = "stylesheet" type = "text/css" href = "samsa-gui.css" />
</head>

<body>

<div id="container">

<div id="title"><h1>Samsa</h1>
	<div class="subtitle">
		variable font inspector<br>
		<a href="https://github.com/Lorp/samsa" title="Samsa on GitHub"><img width="15" height="15" src="images/GitHub-Mark-64px.svg"></a>
	</div>
	<div class="subtitle"></div>
</div>

<div id="font-file" class="inactive">
	&lt;drop a variable font here&gt;
</div>

<div id="controls">

	<div id="panel-info" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Info</h2>
		<div></div>
	</div>

	<div id="panel-ui" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> UI</h2>
		<div></div>
	</div>

	<div id="panel-webfont" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Webfont</h2>
		<div></div>
	</div>

	<div id="panel-axes" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Axes</h2>
		<div></div>
	</div>

	<div id="panel-stat" class="panel closed">
		<h2><span class="icon bold reveal">&#xf04b;</span> STAT</h2>
		<div></div>
	</div>

	<div id="panel-instances" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Instances
			<!--
			<span class="icon" id="instances-as-grid">&#xf00a;</span>
			<span class="icon" id="instances-as-list">&#xf0c9;</span>
			-->
		</h2>
		<div></div>
	</div>

	<div id="panel-tvts" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Tuple Variations</h2>
		<div style="overflow-x: scroll;"></div>
	</div>

	<div id="panel-designspace" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Designspace</h2>
		<div></div>
	</div>

	<div id="panel-glyphs" class="panel open">
		<h2><span class="icon bold reveal open">&#xf04b;</span> Glyphs
			<!-- <span class="icon bold" id="glyphs-rewind">&#xf04a;</span> -->
			<span class="icon bold" id="glyphs-stepback" title="Step back">&#xf048;</span>
			<span class="icon bold" id="glyphs-stop" title="Stop playing">&#xf04d;</span>
			<span class="icon bold" id="glyphs-play" title="Play">&#xf04b;</span>
			<span class="icon bold" id="glyphs-stepforward" title="Step forward">&#xf051;</span>
			<span class="texticon" id="glyphs-ids" title="Glyph IDs">123</span>
			<!-- <span class="icon bold" id="glyphs-fastforward">&#xf04e;</span> -->
		</h2>
		<div></div>
	<br clear="all">

	</div>

	<div id="panel-font-list" class="panel open">
		<h2><span class="icon bold reveal open">&#xf04b;</span> Fonts ready to load</h2>
		<div></div>
	</div>

	<div id="panel-media" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Media</h2>
		<div></div>
	</div>

</div>

<div id="drawing"></div>

</div>


<script>


let GLOBAL = {
	vf: null, // maybe allow an array of fonts... select them with a drop down in info panel
	currentGlyphId: null,
	fontList: [],
};

CONFIG.visualization = true;
CONFIG.uiModes = {

	light: {
		name: "light",

		cartesianAxes: {
			stroke: "#31b8e7",
			strokeWidth: 1,
		},

		arrow: {
			strokeWidth: 3,
			tipLength: 20,
			tipWidth: 15,
			color: "#0044ee",
		},

		designspace: {
			colors: ["blue", "red"],
		},

		tuple: {
			colors: ["#f57670", "#c39921","#57b21f","#1ebf95","#1fb7e9","#a58efc","#f966d5"], // "ggplot2 hue" palette from https://serialmentor.com/dataviz/color-basics.html
		},

		tupleNeedle: {
			stroke: "red",
		},

		tupleScalar: {
			fill: "black",
		},

		point: {
			size: 10,
			shape: "■", // one of ■●▲+x
			shapeOffCurve: "●",
			opacity: 1,
		},

		pointNumbers: {
			angle: 90,
			offset: 10,
		},

		glyphDefault: {
			fill: "#ddd",
			stroke: "none",
			strokeWidth: 0,
			backgroundColor: "transparent",
			point: {
				stroke: "#888",
				strokeWidth: 3,
				fill: "none",
				shape: "+",
				shapeOffCurve: "+",
			},
		},

		glyphCurrent: {
			fill: "none",
			stroke: "black",
			strokeWidth: 2,
			opacity: 1,
			point: {
				size: 15,
				strokeWidth: 0,
				fill: "blue",
				opacity: 0.7,
			},
		},

		glyphThumb: {
			fill: "black",
			stroke: "none",
			strokeWidth: 0,
		},

		text: {
			font: "IBM Plex",
			size: 18,
		},

		label: {
			font: "IBM Plex",
			size: 12,
		},
	},

	dark: {
		name: "dark",

		cartesianAxes: {
			stroke: "lightblue",
			strokeWidth: 1,
		},

		arrow: {
			strokeWidth: 3,
			tipLength: 20,
			tipWidth: 15,
			//color: "#0044ee",
			color: "orange",
		},

		designspace: {
			colors: ["blue", "red"],
		},

		tuple: {
			//colors: ["#269d78", "#d7601c","#7571b1","#e5318a","#68a42c","#e5aa27","#a57528"], // "ColorBrewer Dark2" palette from https://serialmentor.com/dataviz/color-basics.html
			colors: ["#f57670", "#c39921","#57b21f","#1ebf95","#1fb7e9","#a58efc","#f966d5"], // "ggplot2 hue" palette from https://serialmentor.com/dataviz/color-basics.html
		},

		tupleNeedle: {
			stroke: "red",
		},

		tupleScalar: {
			fill: "black",
		},

		point: {
			size: 7,
			shape: "+",
			shapeOffCurve: "+",
			stroke: "yellow",
			strokeWidth: 2,
		},

		pointNumbers: {
			angle: 90,
			offset: 10,
			color: "blue",
		},

		glyphDefault: {
			fill: "#555",
			stroke: "none",
			strokeWidth: 0,
			backgroundColor: "black",
		},

		glyphCurrent: {
			fill: "white",
			strokeWidth: 2,
			opacity: 0.8,
			point: {
				size: 17,
				fill: "blue",
				stroke: "none",
				opacity: 0.7,
				shape: "■", // one of ⯅●■
				shapeOffCurve: "●", // ⯅●■
			}
		},

		glyphThumb: {
			fill: "black",
			stroke: "none",
			strokeWidth: 0,
		},

		// ?better as CSS, so we can add italic, weight, border, background-color etc?
		text: {
			font: "IBM Plex",
			size: 18,
		},

		label: {
			font: "IBM Plex",
			size: 12,
		},
	},

	loci: {
		name: "loci",

		cartesianAxes: {
			stroke: "#31b8e7",
			strokeWidth: 1,
		},

		arrow: {
			strokeWidth: 0,
		},

		designspace: {
			colors: ["royalblue", "crimson"],
		},

		tuple: {
			colors: ["#f57670", "#c39921","#57b21f","#1ebf95","#1fb7e9","#a58efc","#f966d5"], // "ggplot2 hue" palette from https://serialmentor.com/dataviz/color-basics.html
		},

		tupleNeedle: {
			stroke: "red",
		},

		tupleScalar: {
			fill: "black",
		},

		loci: {
			steps: 40,
			strokeWidth: 6,
			style: "railway", // "railway" or "line"
			opacity: 0.7,
		},

		point: {
			size: 10,
			shape: "●", // one of ■●▲+x
			shapeOffCurve: "●",
			opacity: 1,
		},		

		pointNumbers: {},

		glyphDefault: {
			fill: "none",
			stroke: "none",
			strokeWidth: 0,
			backgroundColor: "transparent",
			point: {
				stroke: "#888",
				strokeWidth: 0,
				fill: "none",
				shape: "+",
				shapeOffCurve: "+",
			},
		},

		glyphCurrent: {
			fill: "none",
			stroke: "#aaa",
			strokeWidth: 2,
			opacity: 1,
			point: {
				size: 15,
				strokeWidth: 0,
				fill: "green",
				opacity: 0.75,
			},
		},

		glyphThumb: {
			fill: "black",
			stroke: "none",
			strokeWidth: 0,
		},

		text: {
			font: "IBM Plex",
			size: 18,
		},

		label: {
			font: "IBM Plex",
			size: 12,
		},
	},

	preview: {
		name: "preview",

		cartesianAxes: {
			stroke: "lightblue",
			strokeWidth: 1,
		},

		arrow: {
			strokeWidth: 0,
			tipLength: 0,
			tipWidth: 0,
			color: "transparent",
		},

		designspace: {
			colors: ["blue", "red"],
		},

		tuple: {
			colors: ["#f57670", "#c39921","#57b21f","#1ebf95","#1fb7e9","#a58efc","#f966d5"], // "ggplot2 hue" palette from https://serialmentor.com/dataviz/color-basics.html
		},

		tupleNeedle: {
			stroke: "red",
		},

		tupleScalar: {
			fill: "black",
		},

		point: {
			size: 0, // disable points
		},		

		pointNumbers: {},

		glyphDefault: {
			fill: "none", // disable the default glyph
			stroke: "none",
			strokeWidth: 0,
			backgroundColor: "white",
		},

		glyphCurrent: {
			fill: "black",
			stroke: "none",
			opacity: 1,
		},

		glyphThumb: {
			fill: "black",
			stroke: "none",
			strokeWidth: 0,
		},

		text: {
			font: "IBM Plex",
			size: 18,
		},

		label: {
			font: "IBM Plex",
			size: 12,
		},
	},
}

CONFIG.ui = CONFIG.uiModes["light"];

CONFIG.docs = {
	axes: {
		wght: "regex:microsoft",
		wdth: "regex:microsoft",
		opsz: "regex:microsoft",
		ital: "regex:microsoft",
		slnt: "regex:microsoft",
		xtra: "regex:typenetwork",
		xopq: "regex:typenetwork",
		ytra: "regex:typenetwork",
		yopq: "regex:typenetwork",
		ytlc: "regex:typenetwork",
		ytuc: "regex:typenetwork",
		ytde: "regex:typenetwork",
		ytas: "regex:typenetwork",
		xtab: "regex:typenetwork",
		vrot: "regex:typenetwork",
		udln: "regex:typenetwork",
		shdw: "regex:typenetwork",
		refl: "regex:typenetwork",
		otln: "regex:typenetwork",
		engr: "regex:typenetwork",
		embo: "regex:typenetwork",
		ytch: "regex:typenetwork",
		xtch: "regex:typenetwork",
		rxad: "regex:typenetwork",
		ryad: "regex:typenetwork",
		rsec: "regex:typenetwork",
		vuid: "regex:typenetwork",
		votf: "regex:typenetwork",
		gext: "https://github.com/microsoft/OpenTypeDesignVariationAxisTags/blob/master/Proposals/Glyph_Extension_Axis/ProposalSummary.md",
		hght: "https://github.com/microsoft/OpenTypeDesignVariationAxisTags/blob/master/Proposals/Height_Axis/ProposalSummary.md",
		spac: "https://github.com/Microsoft/OpenTypeDesignVariationAxisTags/blob/master/Proposals/Spacing_Axis/ProposalSummary.md",
	},
	regex: {
		microsoft: "https://docs.microsoft.com/en-us/typography/opentype/spec/dvaraxistag_$1",
		typenetwork: "https://variationsguide.typenetwork.com/#$1",
	},
	hoi: "http://underware.nl/case-studies/hoi/",
};



// shorthands
function Q (selector) {
	return document.querySelector(selector);
}

function Qall (selector) {
	return document.querySelectorAll(selector);
}

function EL (tag) {
	return document.createElement(tag);
}

function SVG (tag) {
    return document.createElementNS("http://www.w3.org/2000/svg", tag);
}


// TODO: specify that this gets the current fvs from sliders
function getCurrentFvs() {

	// TODO: store the current values separately from the axes’ value to avoid conversions

	let fvs = {};
	Qall(".slider").forEach(slider => {
		let axis = slider.data.axis;
		fvs[axis.tag] = axis.min + slider.value * (axis.max - axis.min);
	});
	return fvs;
}


// TODO: this is needless duplication of what SamsaVF.addInstance() already does
// - we can assign the ui object in the options argument
function appendInstanceEl(instance, select) {

	let font = GLOBAL.vf;
	let panel = Q("#panel-instances>div");
	//panel.classList.add("tiles");

	// create the instance DOM element
	let li = document.createElement("div"); // not li?
	let icon = "-", title;

	// initialize instance if necessary
	if (instance === undefined) {
		instance = font.addInstance(getCurrentFvs(), { name: "Custom", ui: li }); // { name: "Custom", tuple: [] };
	}

	// list view
	// - items are: bookmark icon, name, n axis settings
	panel.style.minWidth = "100%";
	panel.style.overflowX = "scroll";


	li.classList.add("instance");
	li.style.display = "grid";
	li.style.gridTemplateColumns = `30px 30px 100px 30px 30px repeat(${GLOBAL.vf.axisCount}, 70px)`;

	// instance type
	switch (instance.type) {
		case "default": icon = "&#xf015;"; title = "Default"; break; // FontAwesome home
		case "named": icon = "&#xf02e;"; title = "Named instance"; break; // FontAwesome bookmark
		case "custom": icon = "&#xf1de;"; title = "Custom instance"; break; // FontAwesome sliders
		case "stat": icon = "&#xf03a;"; title = "STAT instance"; break; // FontAwesome list
	}
	let cell0 = document.createElement("div");
	cell0.style.cursor = "pointer";
	cell0.style.textAlign = "center";
	cell0.style.fontFamily = "FontAwesome";
	cell0.innerHTML = `<strong title="${title}">${icon}</strong>`;

	// SVG of the A glyph
	// - would current glyph be better? ... the image serves as a kind of visual label, but...
	let cell1 = document.createElement("div");
	let svg = SVG("svg");

	let glyph = font.glyphs[getDefaultGlyphId(font)];
	let iglyph = glyphApplyVariations(glyph, instance.tuple); // TODO: make composite-ready

	if (iglyph && iglyph.numContours > 0) {

		// simple glyph
		let svgPath = SVG("path");
		let svgg = SVG("g");
		let scale = 0.02 * 1000 / font.unitsPerEm;
		svg.setAttributeNS(null, "width","30");
		svg.setAttributeNS(null, "height","30");
		svgg.setAttributeNS(null, "transform", `translate(4,20) scale(${scale},-${scale})`);
		
		//svgMarker.attr({markerWidth:20,markerHeight:20);

 		svgPath.setAttributeNS(null, "d", getGlyphSVGpath(iglyph));

		svg.appendChild(svgg);

		// glyph
		svgg.appendChild(svgPath);

		// x and y axes

		//glyphThumb.appendChild(svg);

	}
	else if (glyph && glyph.numContours < 0) {


	}


	cell1.appendChild(svg);

	// instance name
	let cell2 = document.createElement("div");
	cell2.style.textAlign = "center";
	cell2.innerHTML = `<input value="${instance.name}" ${instance.type == "default" ? "readonly " : ""}style="width: 85px">`;

	// visibility
	let cell3 = document.createElement("div");
	cell3.setAttribute("title", "Visibility");
	cell3.style.textAlign = "center";
	cell3.style.fontFamily = "FontAwesome";
	cell3.style.cursor = "pointer";
	cell3.innerHTML = "&#xf06e"; // eye open f070 eye closed

	// instantiate button
	let cell4 = document.createElement("div");
	cell4.classList.add("instantiate");
	cell4.setAttribute("title", "Download TTF");
	cell4.style.textAlign = "center";
	cell4.style.fontFamily = "FontAwesome";
	cell4.style.cursor = "pointer";
	cell4.innerHTML = "&#xf358;"; //"&#xf56d;" // download

	// append all the elements so far
	li.appendChild(cell0);
	li.appendChild(cell1);
	li.appendChild(cell2);
	li.appendChild(cell3);
	li.appendChild(cell4);

	// all the axis settings
	GLOBAL.vf.axes.forEach((axis, a) => {
		let axisCell = document.createElement("div");
		axisCell.style.fontSize = "75%";
		axisCell.style.textAlign = "right";
		axisCell.innerText = instance.fvs[axis.tag];
		li.appendChild(axisCell);
	});

	// bind instance data to instance element
	li.data = { instance: instance };

	// append the instance DOM element
	panel.appendChild(li);

	cell2.addEventListener("input", ev => {
		instance.name = ev.target.value;
	});

	// make it active
	if (select) {
		setActiveInstance (GLOBAL.vf, li);
	}
}


function exportImage (format, filename="samsa-drawing", params) {
	if (GLOBAL.frameIndex === undefined)
		GLOBAL.frameIndex = 0;
	else
		GLOBAL.frameIndex++;

	let svgCode = Q("#drawing").innerHTML;

	svgCode = svgCode.replace(`<svg `, `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" `);

	if (format == "svg") {
		let fauxLink = document.createElement("a");
		fauxLink.download = filename + ".svg";
		fauxLink.href = "data:image/svg+xml;base64," + btoa(svgCode);
		document.body.appendChild(fauxLink); // needed for Firefox, not Chrome or Safari
		fauxLink.click();
		fauxLink.remove();
	}
	else if (format == "png") {
	
		// 1. create the image
		// 2. define what happens when it’s loaded
		// 3. define what to load
		let img = new Image(800, 800);
		img.onload = function () {

			// make a canvas to export the bitmap
			let canvas = document.createElement("canvas");
			canvas.setAttribute("width", 1080);
			canvas.setAttribute("height", 720);
			canvas.id = "samsa-drawing-canvas" + "-" + filename;
			canvas.style.border = "1px solid red";
			document.body.appendChild(canvas);
			let frameIndexStr = GLOBAL.frameIndex.toString();
			while (frameIndexStr.length<3)
				frameIndexStr = `0${frameIndexStr}`;

			if (params && params.frameNumbers === true)
				filename += frameIndexStr;
			filename += ".png";
			let ctx = canvas.getContext("2d");
			ctx.fillStyle = "white";
			ctx.fillRect(0, 0, canvas.width, canvas.height);
			ctx.drawImage(img, 0, 0);
			let fauxLink = document.createElement("a");
			fauxLink.download = filename;
			fauxLink.href = canvas.toDataURL('image/png'); // get pixels from canvas
			document.body.appendChild(fauxLink); // needed for Firefox, not Chrome or Safari
			fauxLink.click();
			fauxLink.remove();
			canvas.remove(); // better to just blank it each time, when exporting multiple frames?
		}

		// give the <img> a src attribute with an SVG data url, to render the SVG on the canvas
		img.src = "data:image/svg+xml," + encodeURIComponent(svgCode);	
	}
	else if (format == "svg-animation") {

		let svg = Q("#drawing svg").cloneNode();
		let svgg = Q("#drawing svg #svg-transform-group").cloneNode();
		let svgInstance = Q("#drawing svg #layer-instance").cloneNode();
		let svgAnimate = SVG("animate");

		svgg.removeAttribute("id");
		svgInstance.removeAttribute("d");
		svgInstance.removeAttribute("id");

		svgAnimate.attrsSVG({
			attributeName: "d",
			values: params.values, // the array of paths converted to a string
			keyTimes: params.keyTimes,
			dur: params.dur,
			repeatCount: params.repeatCount,
		});

		svgInstance.appendChild(svgAnimate);
		svgg.appendChild(svgInstance);
		svg.appendChild(svgg);
		let svgCode = svg.outerHTML;
		svgCode = svgCode.replace(`<svg `, `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" `);
		let fauxLink = document.createElement("a");
		fauxLink.download = filename + ".svg";
		fauxLink.href = "data:image/svg+xml;base64," + btoa(svgCode);
		document.body.appendChild(fauxLink); // needed for Firefox, not Chrome or Safari
		fauxLink.click();
		fauxLink.remove();
	}
}



function vfLoaded (font) {

	GLOBAL.vf = font;
	let panel;

	// set up initial global tuple, the default designspace location
	GLOBAL.tuple = [];
	font.axes.forEach(() => {
		GLOBAL.tuple.push(0);
	});


	///////////////////////////////////////////////////////
	// Filename box
	///////////////////////////////////////////////////////
	Q("#font-file").innerText = font.filename; // or font.names[6];



	///////////////////////////////////////////////////////
	// Info panel
	///////////////////////////////////////////////////////
	panel = Q("#panel-info>div");
	panel.innerText = "";
	panel.innerHTML += `${font.filename} (${font.filesize || "<em>n</em>"} bytes)<br>`;
	panel.innerHTML += `Full name: ${font.names[4]}<br>`;
	//panel.innerHTML += `Date: ${Date(font.date).toString()}<br>`;



	///////////////////////////////////////////////////////
	// UI Panel
	///////////////////////////////////////////////////////
	panel = Q("#panel-ui>div");
	if (!Q("#ui-mode")) { // only build once
		panel.innerText = "";

		// ui options select
		let uiModeHTML = "";
		uiModeHTML += `<select id="ui-mode">`;
		Object.keys(font.config.uiModes).forEach(mode => {
			uiModeHTML += `<option value="${mode}">${mode}</option>`;
		});
		uiModeHTML += `</select><br>`;
		panel.innerHTML += uiModeHTML;
		panel.innerHTML += `<input id="arrows-split" class="ui-arrows" type="checkbox" checked><label for="arrows-split">Split deltas</label>`;
		panel.innerHTML += "&nbsp;";
		panel.innerHTML += `<input id="arrows-total" class="ui-arrows" type="checkbox"><label for="arrows-total">Total deltas</label>`;
		panel.innerHTML += "&nbsp;";
		panel.innerHTML += `<input id="point-numbers" class="ui-arrows" type="checkbox"><label for="point-numbers">Point numbers</label>`;

		/*
		panel.innerHTML += "<label>Delta colours</label>&nbsp;";
		panel.innerHTML += `<input id="arrows-colours" name="arrows-colours" class="ui-arrows-colours" type="radio" checked><label for="arrows-split">by tuple</label>&nbsp;`;
		panel.innerHTML += `<input id="arrows-colours" name="arrows-colours" class="ui-arrows-colours" type="radio"><label for="arrows-total">by order</label><br>`;
		*/

		// set the value for the select (for some reason it doesn’t work if this code comes any earlier)
		Q("#ui-mode").value = font.config.ui.name;

		// UI checkbox click
		Qall(".ui-arrows").forEach(el => {
			el.addEventListener("change", e => {
				let instance = font.addInstance(null, {tuple: GLOBAL.tuple});
				let glyph = font.glyphs[GLOBAL.currentGlyphId];
				let iglyph = glyphApplyVariations(glyph, null, instance);
				setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
				font.instances.pop();
			});
		});
	}


	///////////////////////////////////////////////////////
	// Webfont panel
	///////////////////////////////////////////////////////
	panel = Q("#panel-webfont>div");
	panel.innerText = "AaBbCc";
	panel.setAttribute("contentEditable", true);

	// add the webfont
	let webfontFace = new FontFace("Webfont", font.data.buffer)
	webfontFace.load().then(webfontFace => {
		document.fonts.add(webfontFace);
	});


	///////////////////////////////////////////////////////
	// Media panel
	///////////////////////////////////////////////////////
	panel = Q("#panel-media>div");
	panel.innerText = "";
	panel.style.display = "grid";
	panel.style.gridTemplateColumns = "auto auto auto";

	// export buttons
	panel.innerHTML += `<div></div><div></div><button id="export-svg">Export SVG</button>`;
	panel.innerHTML += `<div></div><div></div><button id="export-png">Export PNG</button>`;
	//panel.innerHTML += `<div></div><div></div><button id="export-mp4">Export MP4</button>`;
	panel.innerHTML += `<label>Select axis</label>`;

	// axis selector	
	let mediaAxisSelect = EL("select");
	mediaAxisSelect.id = "svg-animation-axis";
	font.axes.forEach(axis => {
		let option = EL("option");
		option.setAttribute("value", axis.id);
		option.innerText = `${axis.tag} (${axis.id})`;
		mediaAxisSelect.appendChild(option);
	});
	panel.appendChild(mediaAxisSelect);
	panel.innerHTML += `<button id="export-svg-animation">Export SVG animation</button>`;
	
	// SVG export
	Q("#export-svg").addEventListener("click", () => {
		exportImage ("svg");
	});

	// SVG export
	if (Q("#export-svg-animation")) {

		Q("#export-svg-animation").addEventListener("click", () => {

			// build special animation object object to pass to the exporter
			// - MDN https://developer.mozilla.org/en-US/docs/Web/SVG/Element/animate
			// - CSS-Tricks/Sara Soueidan https://css-tricks.com/guide-svg-animations-smil/

			// for every single-axis tuple that controls axis 0
			// - record start, peak, end
			// - build this into a sorted array of timing values
			// - then use this array of timing values to get the required instances

			// let’s build fvs, not tuple, so we don’t need to worry about avar or whether default is at min or max
			// - hmm, are you sure? we’re using normalized values because we parse tvts


			let fvs = {};
			let glyph = font.glyphs[GLOBAL.currentGlyphId];
			let keyTimesSet = new Set();
			let thisAxis = Q("#panel-media #svg-animation-axis").value;
			let svgAnimation;

			// find the tvts that only affect the chosen axis, then record their start, peak, end
			glyph.tvts.forEach(tvt => {

				// check it’s just axis 0 that is non-zero
				if (tvt.peak[thisAxis] != 0.0) {

					let valid = true;
					for (let a=0; a<font.axes.length; a++) {
						if (tvt.peak[a] != 0.0 && a != thisAxis) {
							valid = false;
							break;
						}
					}
					if (valid) {
						keyTimesSet.add(tvt.start[thisAxis]).add(tvt.peak[thisAxis]).add(tvt.end[thisAxis]);
					}
				}
			});

			if (keyTimesSet.size > 0) {

				// create a sorted keyTimes array from the set of unique values
				let keyTimes = Array.from(keyTimesSet).sort((a, b) => a - b);
				let keyTimesZeroOne; // normalized on a scale from 0 to 1
				let keyPaths = [];
				keyTimes.forEach(T => {

					let animInstance, iglyph;
					let frameTuple = []; // create tuple for this frame’s instance
					for (let a=0; a < font.axes.length; a++) {
						frameTuple[a] = a==thisAxis ? T : 0; // animate the <thisAxis> axis
					}
					
					animInstance = font.addInstance(null, {tuple: frameTuple}); // make instance
					iglyph = glyphApplyVariations(glyph, null, animInstance); // make instance glyph
					keyPaths.push(getGlyphSVGpath(iglyph)); // get SVG path of this instance
					font.instances.pop(); // pop instance
				});

				// create keyTimesZeroOne array, normalized onto range [0,1]
				let kMin=keyTimes[0], kMax=keyTimes[keyTimes.length-1];
				if (kMin == 0.0 && kMax == 1.0)
					keyTimesZeroOne = keyTimes;
				else {
					keyTimesZeroOne = [];
					keyTimes.forEach(T => {
						keyTimesZeroOne.push((T-kMin) / (kMax-kMin));
					});
				}

				// build svg using keyPaths and keyTimes
				svgAnimation = {
					attributeName: "d",
					dur: "5s",
					values: keyPaths.join(";"),
					keyTimes: keyTimesZeroOne.join(";"),
					repeatCount: "indefinite",
				};
			}
			if (svgAnimation)
				exportImage ("svg-animation", "samsa-animation", svgAnimation);
		});
	}
	// PNG export
	Q("#export-png").addEventListener("click", () => {
		exportImage ("png");
	});

	if (Q("#export-mp4")) {

		Q("#export-mp4").addEventListener("click", () => {

			// TODO: more efficient to just make one canvas, and blank it for each frame?

			if (0) {
				GLOBAL.animSteps = 10;
				GLOBAL.animCurrent = 0;

				function doAnimationFrame () {
					if (GLOBAL.animCurrent < GLOBAL.animSteps) {

						let animInstance, iglyph;
						let Tmin = font.axes[0].min < font.axes[0].default ? -1.0 : 0.0;
						let Tmax = font.axes[0].max > font.axes[0].default ? 1.0 : 0.0;
						let T = Tmin + GLOBAL.animCurrent/(GLOBAL.animSteps-1) * (Tmax-Tmin);
						let frameNumberStr = GLOBAL.animCurrent.toString();
						while (frameNumberStr.length < 3)
							frameNumberStr = `0${frameNumberStr}`;

						let frameTuple = []; // create tuple for this frame’s instance
						for (let a=0; a < font.axes.length; a++) {
							frameTuple[a] = a==0 ? T : 0; // animate only axis 0 for now
						}
						
						animInstance = font.addInstance(null, {tuple: frameTuple}); // make instance
						iglyph = glyphApplyVariations(font.glyphs[GLOBAL.currentGlyphId], null, animInstance); // make instance glyph
						setActiveGlyph (GLOBAL.currentGlyphId, animInstance); // make SVG of instance glyph
						exportImage ("png", `samsa-frame${frameNumberStr}`, {frameNumbers: false}); // place SVG on canvas, export canvas as PNG
						font.instances.pop(); // pop instance

						GLOBAL.animCurrent++;
					}
					else {
						console.log(`end`);
						clearInterval (GLOBAL.animTimer);
						GLOBAL.animTimer = undefined;
					}

				}

				GLOBAL.animTimer = setInterval(doAnimationFrame, 200);
			}
			else {

				const steps = 50;

				for (let s=0; s<steps; s++) {

					let animInstance, iglyph;
					let Tmin = font.axes[0].min < font.axes[0].default ? -1.0 : 0.0;
					let Tmax = font.axes[0].max > font.axes[0].default ? 1.0 : 0.0;
					let T = Tmin + s/(steps-1) * (Tmax-Tmin);
					let frameNumberStr = s.toString();
					while (frameNumberStr.length < 3) // generate frame number string (TODO: write padWithZeroes() function)
						frameNumberStr = `0${frameNumberStr}`;

					let frameTuple = []; // create tuple for this frame’s instance
					for (let a=0; a < font.axes.length; a++) {
						frameTuple[a] = a==0 ? T : 0; // animate only axis 0 for now
					}
					
					animInstance = font.addInstance(null, {tuple: frameTuple}); // make instance
					iglyph = glyphApplyVariations(font.glyphs[GLOBAL.currentGlyphId], null, animInstance); // make instance glyph
					setActiveGlyph (GLOBAL.currentGlyphId, animInstance); // make SVG of instance glyph
					exportImage ("png", `samsa-frame${frameNumberStr}`, {frameNumbers: false}); // place SVG on canvas, export canvas as PNG
					font.instances.pop(); // pop instance
				}

				// save shell script to invoke ffmpeg
				let frameRate = 24;
				let shellScript = `ffmpeg -r ${frameRate} -i samsa-frame%03d.png -vcodec libx264 -pix_fmt yuv420p samsa-movie.mp4`;
				let scriptLink = document.createElement("a");
				scriptLink.download = "samsa-movie.sh";
				scriptLink.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(shellScript));
				document.body.appendChild(scriptLink); // needed for Firefox, not Chrome or Safari
				scriptLink.click();
				document.body.removeChild(scriptLink);
			}

		});
	}



	///////////////////////////////////////////////////////
	// Axes panel
	///////////////////////////////////////////////////////
	panel = Q("#panel-axes>div");
	panel.innerText = "";


	let liH = document.createElement("li");
	liH.classList.add("header");
	liH.style.display = "grid";
	liH.style.gridTemplateColumns = `35px 20px 1fr 50px 50px 50px 50px`;
	liH.innerHTML = `<label>Tag</label><label class="icon bold">&#xf129;</label><label>Name</label><label class="min icon bold" style="text-align:center;">&#xf13a;</label><label class="default icon bold" style="text-align:center;">&#xf015;</label><label class="max icon bold" style="text-align:center;">&#xf139;</label><label class="icon bold" style="text-align:center;">&#xf007;</label>`;
	panel.appendChild(liH);

	// add each axis
	font.axes.forEach((axis, a) => {

		let li = EL("li");
		li.id = `axis-${a}`;
		li.classList.add("axis-row");
		li.style.display = "grid";
		li.style.gridTemplateColumns = liH.style.gridTemplateColumns;
		li.style.listStyleType = "none";

		li.innerHTML = `<label class="tag"><tt>${axis.tag}</tt></label>`;

		let docStr = "", docUrl = font.config.docs.axes[axis.tag.toLowerCase()];
		if (docUrl) {
			let docParts = docUrl.split(/:(.+)/)
			if (docUrl && docParts[0] == "regex") {
				docUrl = font.config.docs.regex[docParts[1]].replace("$1", axis.tag.toLowerCase()); // handles microsoft and typenetwork
			}
			docStr = `<a href="${docUrl}" class="icon bold" title="‘${axis.tag}’ axis specification" target="_blank">&#xf05a;</a>`; // book icon, links to the specification of this axis
		}
		li.innerHTML += `<div>${docStr}</div>`;

		li.innerHTML += `<label>${axis.name}</label>`;

		li.innerHTML += `<input class="axis-min" value="${axis.min}" readonly style="text-align:right;">`;
		li.innerHTML += `<input class="axis-default" value="${axis.default}" readonly style="text-align:right;">`;
		li.innerHTML += `<input class="axis-max" value="${axis.max}" readonly style="text-align:right;">`;
		li.innerHTML += `<input class="axis-current active" value="${axis.default}" style="text-align:right; font-weight: bold;">`; // current

		panel.appendChild(li);

		let slider = EL("input");
		slider.classList.add("slider");
		slider.setAttribute("type", "range");
		slider.setAttribute("min", 0.0);
		slider.setAttribute("max", 1.0);
		slider.setAttribute("step", 0.001);

		slider.data = {axis: axis};

		panel.appendChild(slider);
		slider.addEventListener("input", axisInput);

		// double-click sets the axis to default
		li.querySelector(".tag").addEventListener("dblclick", ev => {
			let fvs = getCurrentFvs();
			let tag = ev.target.innerText;
			GLOBAL.vf.axes.forEach((axis, a) => {
				if (axis.tag == tag)
					fvs[tag] = axis.default;
			});

			setAxes (font, fvs);
			let instance = font.addInstance(fvs);
			setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
			axesUpdateValues();
			webfontPanelUpdateVariationSettings();
			font.instances.pop();
		});

	});

	// create grid layout
	let grid = EL("div");
	grid.style.display = "grid";
	grid.classList.add("axes-footer");
	grid.style.gridTemplateColumns = "30% 35% 1fr";
	grid.style.gridColumnGap = "3px";

	let axisValueFormat = EL("select");
	axisValueFormat.id = "axis-value-format";
	axisValueFormat.innerHTML = `<option>user</option><option>userhex</option><option>norm</option><option>normhex</option>`;

	let addInstanceEl = EL("button");
	addInstanceEl.innerText = "Add instance";
	addInstanceEl.class = "instance-add";

	let axisValueLabel = EL("label");
	axisValueLabel.innerText = "Number format";

	
	grid.appendChild(axisValueLabel);
	grid.appendChild(axisValueFormat)
	grid.appendChild(addInstanceEl)
	panel.appendChild(grid);

	// event: click
	addInstanceEl.addEventListener("click", ()=>{
		appendInstanceEl(undefined, true);
	});

	// event: change format
	Q("#axis-value-format").addEventListener("change", ()=>{

		let fvs = font.tupleToFvs(GLOBAL.tuple);
		font.axes.forEach((axis,a) => {
			Q(`#axis-${a}>.axis-min`).value = numberFormat(axis.min, axis);
			Q(`#axis-${a}>.axis-default`).value = numberFormat(axis.default, axis);
			Q(`#axis-${a}>.axis-max`).value = numberFormat(axis.max, axis);
			let currentVal = fvs[axis.tag] === undefined ? axis.default : fvs[axis.tag];
			Q(`#axis-${a}>.axis-current`).value = numberFormat(currentVal, axis);
		});

	});


	///////////////////////////////////////////////////////
	// STAT panel
	///////////////////////////////////////////////////////
	panel = Q("#panel-stat>div");
	panel.innerText = "";
	if (font.tables.STAT) {
		const STAT = font.tables.STAT.data;
		let allowAddInstance = true;
		
		// create grid layout
		let grid = document.createElement("div");
		grid.style.display = "grid";
		grid.classList.add("designAxes");
		grid.style.gridTemplateColumns = "30% 35% 1fr";
		grid.style.gridColumnGap = "3px";

		function setCurrentSTATinstance(font, keepInstance, ignoreInstance) {

			// build STAT name and fvs
			let statNamesAVTs = [], fvs = {};
			Qall("#panel-stat select").forEach((thisSel, a) => {

				let designAxis = thisSel.data.designAxis;
				let axisValueTable = thisSel.options[thisSel.selectedIndex].data.axisValueTable;
				let note = axisValueTable.value;
				switch (axisValueTable.format) {
					case 2:
						note += ` [${axisValueTable.min},${axisValueTable.max}]`;
						break;
					case 3:
						note += ` → ${axisValueTable.linkedValue}`;
						break;
				}
				thisSel.parentNode.querySelectorAll("label.axisValueNote")[a].innerText = note;

				statNamesAVTs.push(axisValueTable); // build STAT name
				fvs[designAxis.tag] = thisSel.value; // build fvs
			});

			// get final STAT name
			let statName, elidable = true, statNamesStrs = [];
			statNamesAVTs.forEach(statNameAVT => {
				if (!(statNameAVT.flags & 0x0002)) {
					statNamesStrs.push(font.names[statNameAVT.nameID]);
					elidable = false;
				}
			});
			if (elidable && STAT.elidedFallbackNameID !== undefined) {
				statName = font.names[STAT.elidedFallbackNameID];
			}
			else {
				statName = statNamesStrs.join(" ");
			}
			Q("#stat-name").value = statName;


			if (!ignoreInstance) { // we might just want to set the STAT instance name
				// create temporary instance
				setAxes (font, fvs);
				let instance = font.addInstance(fvs, {type: "stat", name: statName});
				setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
				axesUpdateValues();
				webfontPanelUpdateVariationSettings();

				if (keepInstance)
					return instance;
				else {
					font.instances.pop();
					return null;
				}
			}
		}

		// for each STAT designAxis
		STAT.designAxesSorted.forEach((designAxis, a) => {
			let label = EL("label");
			label.innerText = font.names[designAxis.nameID];
			let select = EL("select");
			select.data = { designAxis: designAxis };
			let note = EL("label")
			note.classList.add("axisValueNote");

			let selectedIndex=0, thisIndex=0;
			if (STAT.axisValueTables.length == 0) {
				let option = EL("option");
				option.innerText = "no axisValueTables";
				select.appendChild(option);
				select.disabled = true;
				allowAddInstance = false;
			}
			else {
				STAT.axisValueTables.forEach(axisValueTable => {
					switch (axisValueTable.format) {
						case 1: case 2: case 3:
							if (axisValueTable.axisIndex == designAxis.designAxisID) { // note that "a" is different from designAxis.designAxisID if STAT.designAxesSorted is not ordered as STAT.designAxes
								let option = EL("option");
								option.innerText = font.names[axisValueTable.nameID];
								option.value = axisValueTable.value;
								option.data = { axisValueTable: axisValueTable };
								select.appendChild(option);
								if (axisValueTable.flags & 0x0002) { // ELIDABLE_AXIS_VALUE_NAME
									option.innerText = "(" + option.innerText + ")";
									if (selectedIndex==0) {
										selectedIndex = thisIndex; // select the first elidable avt
									}
								}
								thisIndex++;
							}
							break;
					}
				});
			}

			grid.appendChild(label);
			grid.appendChild(select);
			grid.appendChild(note);
			select.selectedIndex = selectedIndex;

			// when we change the selection
			select.addEventListener("change", ev => {
				setCurrentSTATinstance(font);
			});
		});

		let input = document.createElement("input");
		input.id = "stat-name";
		input.value = "<STAT font name>";
		input.readOnly = true;

		let label = document.createElement("label");
		label.innerText = "Composed name";

		grid.appendChild(label);
		grid.appendChild(input);
		panel.appendChild(grid);

		// "Add instance" button
		let addInstanceEl = document.createElement("button");
		addInstanceEl.innerText = "Add instance";
		addInstanceEl.class = "instance-add";
		grid.appendChild(addInstanceEl);

		// set current STAT instance and add it to the Instances panel
		if (allowAddInstance) {		
			addInstanceEl.addEventListener("click", ()=>{
				let instance = setCurrentSTATinstance(font, true);
				appendInstanceEl(instance, true);
			});
		}
		else {
			addInstanceEl.disabled = true;
		}
	}

	else {
		panel.innerHTML = "This font does not contain a STAT table.";
	}


	///////////////////////////////////////////////////////
	// Instances panel
	///////////////////////////////////////////////////////
	panel = Q("#panel-instances>div");
	panel.innerText = "";
	panel.style.backgroundClip = "border-box";
	panel.style.padding = "1px 0"; // necessary so the padding of the contents uses the panel’s background-color 

	let li = Q("div");
	let fvsString = "";

	// add each instance
	font.instances.forEach((instance, i) => {
		appendInstanceEl(instance);
	});
	setActiveInstance(GLOBAL.vf); // without an instance parameter, it sets it to the default


	///////////////////////////////////////////////////////
	// Designspace panel
	///////////////////////////////////////////////////////
	panel = Q("#panel-designspace>div");
	panel.innerText = "";
	panel.style.backgroundColor = "white";

	// build cartesian area
	let cartesian = document.createElement("div");
	cartesian.id = "ds-cartesian";
	cartesian.setAttribute("style", "width: 100%; height: 360px;");
	panel.appendChild(cartesian);

	// checkboxes for X and Y axis assignment
	let htmlX, htmlY;
	htmlX = `<div id="xSelect" class="ds-axis-group">`;
	htmlY = `<div id="ySelect" class="ds-axis-group">`;
	GLOBAL.vf.axes.forEach((axis,a) => {
		htmlX += `<div><input type="checkbox" id="x-${axis.tag}" value="${axis.tag}"${a==0 ? " checked" : ""}><label for="x-${axis.tag}">${axis.tag}</label></div>`;
		htmlY += `<div><input type="checkbox" id="y-${axis.tag}" value="${axis.tag}"${a==1 ? " checked" : ""}><label for="y-${axis.tag}">${axis.tag}</label></div>`;
	});
	htmlX += `</div>`;
	htmlY += `</div>`;
	panel.innerHTML += `<div class="cartesian-axis-row"><div>X=<span id="xValue">0</span></div>${htmlX}</div>`;
	panel.innerHTML += `<div class="cartesian-axis-row"><div>Y=<span id="yValue">0</span></div>${htmlY}</div>`;
	
	// attach change events to each checkbox
	Qall(".ds-axis-group input").forEach(el => {
		el.addEventListener("change", () => {
			// validate new state of checkboxes
			let valid = true, foundAxes = [];
			Qall(".ds-axis-group input:checked").forEach(el => {
				if (foundAxes.includes(el.value))
					valid = false;
				else
					foundAxes.push(el.value);
			});

			// if invalid, set red background
			xSelect.style.backgroundColor = ySelect.style.backgroundColor = valid ? "inherit" : "red";
		});
	});

	// TODO: consider user/normalized option

	updateDesignspace();


	// TODO: .designspace export - is this useful?
	if (false) {

		let exportEl = document.createElement("button");
		exportEl.innerText = "Export as .designspace";
		exportEl.id = "instance-add";
		panel.appendChild(exportEl);

		/*
		<designspace format="3">
			<axes>
				<!-- define axes here -->
				<axis../>
				</axes>
			<sources>
				<!-- define masters here -->
				<source../>
			</sources>
			<instances>
				<!-- define instances here -->
				<instance../>
			</instances>
		</designspace>
		*/

		let designspace = document.createElement("designspace");
		designspace.setAttribute("format", 3);
		let dsAxes = document.createElement("axes");
		let dsSources = document.createElement("sources");
		let dsInstances = document.createElement("instances");
		GLOBAL.vf.axes.forEach(axis => {
			let dsAxis = document.createElement("axis");
			dsAxis.setAttribute("name", axis.name);
			dsAxis.setAttribute("tag", axis.tag);
			dsAxis.setAttribute("minimum", axis.min);
			dsAxis.setAttribute("default", axis.default);
			dsAxis.setAttribute("maximum", axis.max);
			dsAxes.appendChild(dsAxis);
		})
		// what to do about sources?
		GLOBAL.vf.instances.forEach(instance => {
			let dsInst = document.createElement("instance");
			//dsInstances.appendChild(dsInst);
		})
		designspace.appendChild(dsAxes);
		designspace.appendChild(dsSources);
		designspace.appendChild(dsInstances);
		console.log ("<?xml version='1.0' encoding='utf-8'?>\n" + designspace.outerHTML);
	}



	if (!panel.parentNode.classList.contains("open"))
		panel.style.display = "none";


	///////////////////////////////////////////////////////
	// Glyphs panel
	///////////////////////////////////////////////////////
	GLOBAL.currentGlyphId = getDefaultGlyphId(font);
	updateGlyphsPanel (font.instances[0]); // instances[0] is always the default instance


	Q("body").style.cursor = "default";


	///////////////////////////////////////////////////////
	// late event handlers and assignments
	///////////////////////////////////////////////////////

	// ui: handle change of mode
	Q("#ui-mode").addEventListener("change", () => {
		console.log(Q("#ui-mode").value);
		font.config.ui = font.config.uiModes[Q("#ui-mode").value];

		let instance = font.addInstance(null, {tuple: GLOBAL.tuple});
		setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
		font.instances.pop();
	});

	// designspace: handle mousemove and mousedown (late event handler)
	Q("#ds-cartesian").addEventListener("mousemove", e => {
		// requires pointer-events:none on all grid lines
		if (e.buttons & 1) { // 1 is bitmask for left mouse button
			updateDesignSpaceMoved(e);
		}
	});
	Q("#ds-cartesian").addEventListener("mousedown", e => {
		updateDesignSpaceMoved(e);
	});

	if (font.tables.STAT) {
		setCurrentSTATinstance(font, false, false); // this must be after the Glyphs panel is created
	}

}


function updateDesignSpaceMoved(e) {

	let font = GLOBAL.vf;
	let rect = e.target.getBoundingClientRect();
	let x = e.clientX - rect.left;
	let y = e.clientY - rect.top;
	x = x/180-1;
	y = 1-y/180;

	// update the visual designspace location lines
	Q("#svgXVal").setAttributeNS(null, "d", `M${x} -1 L${x} 1`);
	Q("#svgYVal").setAttributeNS(null, "d", `M-1 ${y} L1 ${y}`);

	// initialize tuple
	let tuple = [];
	for (let a=0; a < font.axes.length; a++) {
		tuple.push(0); // default is 0 by definition
	}
	
	// what VF axes are attached to the X axis?
	Qall("#xSelect input:checked").forEach(el => {
		font.axisIndices(el.value).forEach(i => tuple[i]=x );
	});

	// what VF axes are attached to the Y axis?
	Qall("#ySelect input:checked").forEach(el => {
		font.axisIndices(el.value).forEach(i => tuple[i]=y );
	});

	// update the text fields
	Q("#xValue").innerText = x.toFixed(5);
	Q("#yValue").innerText = y.toFixed(5);

	// set the axes in the Axes panel
	let fvs = font.tupleToFvs(tuple);
	setAxes (font, fvs);

	// now update the glyph in the drawing
	// - should we do this simply by setting the axes in the Axes panel
	let instance = font.addInstance(null, {tuple: tuple});
	let glyph = font.glyphs[GLOBAL.currentGlyphId];
	let iglyph = glyphApplyVariations(glyph, null, instance);
	setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
	font.instances.pop();

	axesUpdateValues();
	webfontPanelUpdateVariationSettings();
}

function numberFormat(val, axis) {

	let V;
	switch (Q("#axis-value-format").value) {

		case "user":
			V = val;
			break;

		case "userhex":
			V = Math.round(val * 0x10000);
			if (V<0)
				V += 0x100000000;
			V = V.toString(16);
			for (let p=V.length; p<8; p++)
				V = `0${V}`;
			break;

		case "norm":
			V = GLOBAL.vf.axisNormalize(axis, val);
			break;

		case "normhex":
			V = GLOBAL.vf.axisNormalize(axis, val);
			V = Math.round(V * 0x4000);
			if (V<0)
				V += 0x10000;
			V = V.toString(16);
			for (let p=V.length; p<4; p++)
				V = `0${V}`;
			break;

	}
	return V;
}


function axesUpdateValues () {
	// update axis values
	let fvs = GLOBAL.vf.tupleToFvs(GLOBAL.tuple);
	GLOBAL.vf.axes.forEach((axis,a) => {
		let currentVal = fvs[axis.tag] === undefined ? axis.default : fvs[axis.tag];
		Q(`#axis-${a}>.axis-current`).value = numberFormat(currentVal, axis);
	});
}


function webfontPanelUpdateVariationSettings() {
	let fvs = GLOBAL.vf.tupleToFvs(GLOBAL.tuple);
	Q("#panel-webfont.panel>div").style.fontVariationSettings = fvsToCSS(fvs);
}


function axisInput() {

	let font = GLOBAL.vf;

	// create instance
	let instance = font.addInstance(getCurrentFvs()); // { name: "Custom", tuple: [] };

	let glyph = font.glyphs[GLOBAL.currentGlyphId];
	let iglyph = glyphApplyVariations(glyph, null, instance);
	setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
	
	axesUpdateValues();
	webfontPanelUpdateVariationSettings();

	// delete instance? definitely!
	font.instances.pop();
}

function updateDesignspace() {

	const ui = CONFIG.ui;
	let cb = Q("#dsAxesMultiple");
	let xSelect = Q("#xSelect");
	let ySelect = Q("#ySelect");

	// draw cartesian axes
	let cartesian = Q("#ds-cartesian");

	let svg = SVG("svg");
	let svgg = SVG("g"); // this transforms everything inside it
	svgg.id = "svg-transform-group";
	let svgXYAxes, svgXVal, svgYVal;
	let scale = 360/2; // 360 is the width & height of the cartesian space in px, 2 is the width & height of the cartesian space in normalized units (-1 to +1)
	svg.setAttributeNS(null, "width","360");
	svg.setAttributeNS(null, "height","360");
	svgg.setAttributeNS(null, "transform", `translate(180,180) scale(${scale},-${scale})`);

	svgXYAxes = SVG("path");
	svgXYAxes.attrsSVG({
		//d: "M-10000,0 L10000,0 M0,-10000 L0,10000",
		d: "M-1 0 L1 0 M0 -1 L0 1",
		stroke: `lightblue`,
		"stroke-width": `${1/scale}px`,
		fill: "none",
		"pointer-events": "none",
	});

	svgXVal = SVG("path");
	svgXVal.id = "svgXVal";
	svgXVal.attrsSVG({
		d: "M0 -1 L0 1",
		stroke: ui.designspace.colors[1],
		"stroke-width": `${1/scale}px`,
		fill: "none",
		"pointer-events": "none",
	});

	svgYVal = SVG("path");
	svgYVal.id = "svgYVal";
	svgYVal.attrsSVG({
		d: "M-1 0 L1 0",
		stroke: ui.designspace.colors[0],
		"stroke-width": `${1/scale}px`,
		fill: "none",
		"pointer-events": "none",
	});

	svgg.appendChild(svgXVal);
	svgg.appendChild(svgYVal);
	svgg.appendChild(svgXYAxes);
	svg.appendChild(svgg);

	cartesian.appendChild(svg);


	// draw some glyphs (at named instance locations)



	// capture mouse



	// consider 1d view

}

function updateGlyphsPanel(instance) {

	console.log("Updating glyphs panel: START");
	const font = GLOBAL.vf;

	///////////////////////////////////////////////////////
	// glyphs panel
	///////////////////////////////////////////////////////
	const panel = Q("#panel-glyphs>div");
	panel.innerText = "";
	const scale = 0.05 * 1000 / font.unitsPerEm;
	let showGlyphIds = Q("#panel-glyphs>h2 #glyphs-ids").classList.contains("active");
	
	for (let g=0; g < font.numGlyphs; g++) {

		let glyph = instance ? instance.glyphs[g] : font.glyphs[g];
		let glyphThumb = document.createElement("div");
		glyphThumb.classList.add("glyph-thumb");
		glyphThumb.setAttribute("id", `g-${g}`);

		if (glyph) {

			// simple glyph
			let svg = SVG("svg");
			let svgg = SVG("g");

			svg.setAttributeNS(null, "width","90");
			svg.setAttributeNS(null, "height","90");
			svgg.setAttributeNS(null, "transform", `translate(20,60) scale(${scale},-${scale})`);
			
			let paths = getGlyphSVGpath(glyph);
			if (!Array.isArray(paths)) { // composite
				paths = [paths];
			}

			paths.forEach((path, p) => {

				if (Array.isArray(path)) {
					console.log("Warning: glyph <" + glyph.name + "> has nested components >1 level deep");
				}

				let svgPath;
				let svgg3 = glyph.numContours == -1 ? SVG("g") : null; // wrap component paths in a g so they can be transformed
				svgPath = SVG("path"); // give this an id so we can detect clicks
				svgPath.attrsSVG({
					d: path,
					stroke: GLOBAL.vf.config.ui.glyphThumb.stroke,
					"stroke-width": `${GLOBAL.vf.config.ui.glyphThumb.strokeWidth}px`,
					fill: GLOBAL.vf.config.ui.glyphThumb.fill,
				});
				if (svgg3) {
					svgg3.attrsSVG({
						transform: `translate(${glyph.points[p][0]},${glyph.points[p][1]})`,
					});
					svgg3.appendChild(svgPath);
					svgg.appendChild(svgg3);
				}
				else {
					svgg.id = `g${glyph.id}`;
					svgg.appendChild(svgPath);
				}
			});

			svg.appendChild(svgg);
			glyphThumb.appendChild(svg);

		}
		else if (glyph && glyph.numContours < 0) {


		}

		// set the label for the glyph thumb: glyph name and glyph id
		let label = document.createElement("label");
		let spanName = document.createElement("span"), spanId = document.createElement("span");
		spanName.innerText = font.glyphs[g].name || "undefined";
		spanName.classList.add("name");
		spanId.innerText = g;
		spanId.classList.add("number");
		if (showGlyphIds)
			spanName.style.display = "none";
		else
			spanId.style.display = "none";

		// append the elements
		label.appendChild(spanName);
		label.appendChild(spanId);
		glyphThumb.appendChild(label);
		panel.appendChild(glyphThumb);
	}

	console.log("Updating glyphs panel: END");
	setActiveGlyph(GLOBAL.currentGlyphId, instance);
}

function setAxes (font, fvs) {
	

	let sliders = Qall(".slider");
	font.axes.forEach((axis, a) => {

		if (axis.min > axis.max)
			return;

		let val = fvs[axis.tag];
		if (val < axis.min)
			val = axis.min;
		if (val > axis.max)
			val = axis.max;

		sliders[a].value = (val - axis.min) / (axis.max - axis.min);
	});
}

function getActiveInstance (font) {

	let instance = null;
	Qall(".instance").forEach(el => {
		console.log(`checking instance`)
		if (el.classList.contains("active")) {
			console.log(`got instance`, el.data.instance)
			instance = el.data.instance;
		}
	});

	return instance;
}

function setActiveInstance (font, target) {

	Qall(".instance").forEach((el, i) => {

		let instance = font.instances[i]; // font.instances[0] is the default "instance"

		// update instance ui
		if (el == target || (!target && instance.type == "default")) { // allows for future reordering
			
			el.classList.add("active");
			setAxes (font, instance.fvs);
			instanceApplyVariations (font, instance);
			updateGlyphsPanel (instance);
			axesUpdateValues();
			webfontPanelUpdateVariationSettings();
		}
		else {
			el.classList.remove("active");
			//target.data.selected = true;
		}
	});
}


function getActiveGlyph () {

	let g=0, el;
	if (el = Q(".glyph-thumb.active")) {
		let comps = el.id.split("-");
		g = 1*comps[1];
	}
	return g;

	// TODO: it would be simpler just to store the active glyph somewhere
	// return font.currentGlyphId;
}

function getArrowParams (x1, y1, x2, y2) {

	let arrow;
	let newX2, newY2;
	let len;
	const ui = GLOBAL.vf.config.ui;

	if (x2!=x1 || y2!=y1) {
		let tipWidth = ui.arrow.tipWidth * GLOBAL.vf.unitsPerEm/1000;
		let tipLength = ui.arrow.tipLength * GLOBAL.vf.unitsPerEm/1000;
		len = Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
		let arrowBackX = (y2-y1) * tipWidth/2/len;
		let arrowBackY = (x2-x1) * tipWidth/2/len;

		arrow = {
			newX2: newX2 = x1 + (x2-x1) * (len-tipLength)/len, // assignement helps 2 lines on
			newY2: newY2 = y1 + (y2-y1) * (len-tipLength)/len, // assignement helps 2 lines on
			arrowX1: newX2+arrowBackX,
			arrowY1: newY2-arrowBackY,
			arrowX2: newX2-arrowBackX,
			arrowY2: newY2+arrowBackY,
		};
	}
	return arrow;
}

function getSVGForShape (point, shape, size) {

	let svgEl;
	switch (shape) {
		// "■●▲+x"
		case "■":
			svgEl = SVG("rect");
			svgEl.attrsSVG({
				x: point[0]-size/2,
				y: point[1]-size/2,
				width: size,
				height: size,
			});
			break;

		case "●":
			svgEl = SVG("circle");
			svgEl.attrsSVG({
				cx: point[0],
				cy: point[1],
				r: size/2,
			});
			break;

		case "▲":
			svgEl = SVG("path");
			svgEl.attrsSVG({
				d: `M${point[0]} ${point[1]+size/2}L${point[0]+size/2*0.86602540378} ${point[1]-size/2*0.5}L${point[0]-size/2*0.86602540378} ${point[1]-size/2*0.5}Z`,
			});
			break;

		case "+":
			svgEl = SVG("path");
			svgEl.attrsSVG({
				d: `M${point[0]-size/2} ${point[1]}L${point[0]+size/2} ${point[1]}M${point[0]} ${point[1]-size/2}L${point[0]} ${point[1]+size/2}`,
			});
			break;

		case "x":
			svgEl = SVG("path");
			svgEl.attrsSVG({
				d: `M${point[0]-size/2} ${point[1]-size/2}L${point[0]+size/2} ${point[1]+size/2}M${point[0]-size/2} ${point[1]+size/2}L${point[0]+size/2} ${point[1]-size/2}`,
			});
			break;
	}

	return svgEl;
}


function setActiveGlyph (g, instance) {

	// instance may be undefined

	let font = GLOBAL.vf;
	let ui = font.config.ui;
	const uiScale = font.unitsPerEm/1000
	if (g === undefined)
		g = 0;
	g *= 1;

	GLOBAL.currentGlyphId = g; // hmm, should be part of the font, not GLOBAL … TODO: check g < numGlyphs
	let glyph = font.glyphs[g];

	// highlight active glyph thumbnail (first, unhighlight all of them)
	Qall(".glyph-thumb").forEach(el => {
		el.classList.remove("active");
	});
	Q(`#g-${g}`).classList.add("active");

	let iglyph = glyphApplyVariations(glyph, null, instance);
	if (instance) {
		GLOBAL.tuple = [];
		instance.tuple.forEach((v,i) => {
			GLOBAL.tuple[i] = v; // deep copy
		})
		//GLOBAL.tuple = instance.tuple; // hmm, shallow copy should be ok, because if won’t be garbage collected
	}

	// clear main window and tvts panel
	let drawing = Q("#drawing");
	drawing.innerHTML = "";


	///////////////////////////////////////////////////////
	// Tuples panel
	///////////////////////////////////////////////////////

	// TODO: we shouldn’t be doing all this for each glyph refresh
	let panel = Q("#panel-tvts>div");
	panel.innerHTML = "";

	let layers = []; // layers are drawn from low values (bottom) to high values (top)


	let scale = 0.5 / uiScale;
	let opacity = 0.5;
	let svg = SVG("svg");
	let svgg = SVG("g"); // this transforms everything inside it
	svgg.id = "svg-transform-group";
	//let svgDefs = SVG("defs")
	//let svgMarker = SVG("marker")
	//let svgMarkerPath = SVG("path")
	svg.attrsSVG( {
		width: 1000,
		height: 1000,
		style: `background-color: ${ui.glyphDefault.backgroundColor};`,
	});
	svgg.setAttributeNS(null, "transform", `translate(130,500) scale(${scale},-${scale})`);

	/*
	// define marker
	svgMarker.id = "arrow";
	svgMarker.attrsSVG({
		markerWidth: 20,
		markerHeight: 20,
		fill: ui.arrow.color,
		orient: "auto",
		refX: 10,
		refY: 5,
	});
	svgMarkerPath.setAttributeNS(null, "d", "M 10 5 L 3 2 L 3 8 z");
	svgMarker.appendChild(svgMarkerPath);
	svgDefs.appendChild(svgMarker);
	*/

	/*
	// filters to use... not yet :)
	// - https://developer.mozilla.org/en-US/docs/Web/SVG/Element/filter
	let svgFilter = SVG("filter");
	svgFilter.setAttributeNS(null, "id","blur");
	let svgFilterBlur = SVG("feGaussianBlur");
	svgFilterBlur.setAttributeNS(null, "stdDeviation","5");
	svgFilter.appendChild(svgFilterBlur);
	svgDefs.appendChild(svgFilter);
	*/

	//svg.appendChild(svgDefs);


	// TODO: we're not yet using the layer idea, but I think it will be useful to allow us to make minimal updates
	let layerIds = [];
	layerIds.push(0);
	layerIds.push(1);
	layerIds.push(2);
	if (ui.loci && ui.loci.strokeWidth)
		layerIds.push(7);
	layerIds.push(3);
	if (Q("#arrows-total").checked && ui.arrow.strokeWidth)
		layerIds.push(4);
	layerIds.push(5);
	if (Q("#arrows-split").checked && ui.arrow.strokeWidth)
		layerIds.push(6);
	if (Q("#point-numbers").checked && ui.arrow.strokeWidth)
		layerIds.push(8);

	layerIds.forEach(L => {

		let svgPath, svgg2, svgg3, paths;
		let layer = layers[L] = {
			on: true,
			svg: null,
		};
		let style = {
			size: 0,
			fill: "none",
			stroke: "none",
			strokeWidth: 0,
		};

		switch (L) {

			// cartesian axes, the grid
			case 0:
				layer.id = "layer-grid";
				svgPath = SVG("path");
				svgPath.id = layer.id;
				svgPath.attrsSVG({
					d: "M-10000,0 L10000,0 M0,-10000 L0,10000",
					stroke: ui.cartesianAxes.stroke,
					"stroke-width": ui.cartesianAxes.strokeWidth * uiScale,
					fill: "none",
				});
				svgg.appendChild(svgPath);

				break;


			// default
			case 1:
				layer.id = "layer-default";
				//svgPath = SVG("path");

				// draw glyph

				// we transform each component
				// - check each time we use getGlyphSVGpath()
				// - we take the translation from the glyph’s points property (which has been processed as usual by tvts)
				// - TODO: we’ll take the transformation matrix from the glyph’s components[p].transform
				// - must look up the order or processing: translate, transform or transform, translate (I recall that Apple and Microsoft differed on this)
				// - fonts using transforms are quite rare; Wingdings uses rotation and reflection in some ornaments
				// - https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform

				paths = getGlyphSVGpath(glyph);
				if (!Array.isArray(paths)) { // composite
					paths = [paths];
				}
				paths.forEach((path, p) => {
					svgg3 = glyph.numContours == -1 ? SVG("g") : null; // wrap component paths in a g
					svgPath = SVG("path"); // give this an id so we can detect clicks
					svgPath.attrsSVG({
						d: path,
						stroke: ui.glyphDefault.stroke,
						"stroke-width": ui.glyphDefault.strokeWidth * uiScale,
						fill: ui.glyphDefault.fill,
					});
					if (svgg3) {
						//svgg3.setAttributeNS(null, "transform", `translate(${iglyph.points[p][0]} ${iglyph.points[p][1]})`);
						// glyph.points[0] is the xy offset of the first component,
						// glyph.points[1] is the xy offset of the second component, etc.
						svgg3.setAttributeNS(null, "transform", `translate(${glyph.points[p][0]} ${glyph.points[p][1]})`);
						svgg3.appendChild(svgPath);
						svgg.appendChild(svgg3);
						svgg3.id = layer.id;
					}
					else {
						svgPath.id = layer.id;
						svgg.appendChild(svgPath);
					}
				});

				break;


			// instance
			case 2:
				layer.id = "layer-instance";

				// draw glyph with variations taken from the current axis settings
				// - should we render all active instances in this "layer"?
				/*
				svgPath = SVG("path");
				svgPath.attrsSVG({
					"style": `opacity:${opacity}`,
					"d": getGlyphSVGpath(iglyph),
					"stroke": `black`, // make this take a value from the ui confi
					"stroke-width": `${GLOBAL.vf.config.ui.glyph.strokeWidth}px`,
					"fill": `#00f`,
					// "filter": "url(#blur)", not yet :)					
				});
				*/

				paths = getGlyphSVGpath(iglyph);
				if (!Array.isArray(paths)) { // composite
					paths = [paths];
				}
				let uiStyle = ui.glyphCurrent;
				paths.forEach((path, p) => {
					svgg3 = iglyph.numContours == -1 ? SVG("g") : null; // wrap component paths in a g
					svgPath = SVG("path"); // give this an id so we can detect clicks
					svgPath.attrsSVG({
						d: path,
						style: `opacity: ${uiStyle.opacity}`,
						stroke: uiStyle.stroke,
						"stroke-width": uiStyle.strokeWidth * uiScale,
						fill: `${uiStyle.fill}`,
						// "filter": "url(#blur)", not yet :)					
					});
					if (svgg3) {
						//svgPath.id = `g${iglyph.id}-c${p}`; // "g27-c2" means component #2 of glyph #27
						svgg3.setAttributeNS(null, "transform", `translate(${iglyph.points[p][0]} ${iglyph.points[p][1]})`);
						svgg3.appendChild(svgPath);
						svgg.appendChild(svgg3);
						svgg3.id = layer.id;
					}
					else {
						//svgg3.id = `g${iglyph.id}`; // "g27" means glyph 27
						svgg.appendChild(svgPath);
						svgPath.id = layer.id;
					}
				});

				break;

/*

			case 3:
				// TODO: decide how to show "points" for composites… origin, so we see translations?
				layer.id = "layer-instance-points";
				svgg2 = SVG("g");
				svgg2.id = layer.id;

				iglyph.points.forEach(function (pt, p) {
					let size = ui.point.size;
					let svgP;
					if (pt[2]) {
						svgP = SVG("rect"); // on-curve
						svgP.classList.add("ctrl-pt");
						svgP.attrsSVG({
							x: pt[0]-size, y: pt[1]-size,
							width: 2*size, height: 2*size,
						});
					}
					else {
						svgP = SVG("circle"); // off-curve
						svgP.classList.add("ctrl-pt");
						svgP.attrsSVG({ cx: pt[0], cy: pt[1], r: 4 });
					}
					svgP.data = { point: pt };
					svgg2.appendChild(svgP);
				});

				svgg.appendChild(svgg2);
				break;
*/

			// arrows: total
			case 4:
				layer.id = "layer-arrows-total";

				svgg2 = SVG("g");
				svgg2.id = layer.id;
				svgg2.attrsSVG({
					"stroke": ui.arrow.color,
					"stroke-width": ui.arrow.strokeWidth * uiScale,
				});

				// TODO: Make a function to draw arrows that the "split arrows" method can use too
				glyph.points.forEach((point1, pt) => {
					let point2 = iglyph.points[pt]; // transformed point
					let x1 = point1[0], y1 = point1[1], x2 = point2[0], y2 = point2[1];
					if (x1==x2 && y1==y2) {
						// same location so no line (now we can ignore divide-by-zero in the else{}
					}
					else {
						// get the arrow parameters so we can draw a truncated line (maybe dotted) plus arrow head
						let arrow = getArrowParams (x1, y1, x2, y2);
						let svgLine = SVG("line");
						let svgArrowHead = SVG("path");
						svgLine.attrsSVG({ x1: x1, y1: y1, x2: arrow.newX2, y2: arrow.newY2 });
						svgArrowHead.attrsSVG({
							d: `M${x2} ${y2}L${arrow.arrowX1} ${arrow.arrowY1}L${arrow.arrowX2} ${arrow.arrowY2}Z`,
							fill: ui.arrow.color,
							stroke: "none",
						});

						if (!iglyph.touched[pt]) {
							svgLine.attrsSVG({ "stroke-dasharray": 4 * uiScale }); // IUP implicit movement
						}

						svgg2.appendChild(svgLine);
						svgg2.appendChild(svgArrowHead);

					}
				});										

				svgg.appendChild(svgg2);
				break;


			// control points
			case 3:
			case 5:
				// draw control points, grouped in their own <g>
				if (L==3)
					layer.id = "layer-instance-points";
				else if (L==5)
					layer.id = "layer-points";
				else
					layer.id = "layer-invalid";

				// set style, with overrides
				Object.keys(ui.point).forEach(k => {
					style[k] = ui.point[k];
				});
				if (L==3 && ui.glyphCurrent.point)
					Object.keys(ui.glyphCurrent.point).forEach(k => {
						style[k] = ui.glyphCurrent.point[k];
					});
				else if (L==5 && ui.glyphDefault.point)
					Object.keys(ui.glyphDefault.point).forEach(k => {
						style[k] = ui.glyphDefault.point[k];
					});

				// only draw if they’re wanted
				if (style.size > 0) {				
					
					// create group element
					svgg2 = SVG("g");
					svgg2.id = layer.id;

					// set attrs
					svgg2.attrsSVG({
						fill: style.fill,
						"stroke-width": style.strokeWidth * uiScale,
						stroke: style.stroke,
						opacity: style.opacity,
					});

					// draw the points
					(L==3 ? iglyph : glyph).points.forEach(function (pt, p) {
						let svgEl = getSVGForShape (
							pt,
							pt[2] ? style.shape : style.shapeOffCurve,
							style.size * uiScale);
						svgg2.appendChild(svgEl);
					});

					svgg.appendChild(svgg2);
				}
				break;


			// arrows: split
			case 6:

				layer.id = "layer-arrows-split";
				svgg2 = SVG("g");
				svgg2.id = layer.id;
				svgg2.attrsSVG({
					"fill": "none",
					"stroke-width": 3,
					"stroke": "green",
				});

				glyph.points.forEach((point, pt) => {

					let x1 = point[0], y1 = point[1];
					let x2, y2;

					// make an arrow for each tvt
					glyph.tvts.forEach((tvt, t) => {
						let sValue = iglyph.tvtsVisualization[t].S;
						let delta = tvt.deltas[pt];
						let iup = (delta === null);
						let lineColor = ui.tuple.colors[t % ui.tuple.colors.length]; // get the t’th colour in the array, wrapping round to the start when we run out of colours

						if (iup) {
							x2 = x1 + iglyph.tvtsVisualization[t].scaledDeltas[pt][0];
							y2 = y1 + iglyph.tvtsVisualization[t].scaledDeltas[pt][1];
						}
						else {							
							x2 = x1 + delta[0] * sValue;
							y2 = y1 + delta[1] * sValue;
						}

						if (x2!=x1 || y2!=y1) {

							// Arrows:
							// We avoid SVG’s built-in method of attaching shapes to lines, and make a separate line and arrowhead
							// Thick lines blunt pointed arrows, so we draw each line up to the base of the arrowhead.
							// It might be more efficient to draw each tuple’s lines as one path
							// - but the resulting SVG would be ugly to edit
							// - and we’d also have to make separate paths for IUP and non-IUP arrows
							let arrow = getArrowParams (x1, y1, x2, y2);

							// make the line
							let svgLine = SVG("line");
							svgLine.attrsSVG({
								x1: x1, y1: y1, x2: arrow.newX2, y2: arrow.newY2,
								stroke: lineColor,
								"stroke-width": ui.arrow.strokeWidth * uiScale,
							});
							if (iup)
								svgLine.attrsSVG({ "stroke-dasharray": 4 * uiScale });

							// make the arrowhead with SVG path
							// - SVG polygon more efficient, but less flexible if we want a special shape
							let svgArrowHead = SVG("path");
							svgArrowHead.attrsSVG({
								d: `M${x2} ${y2}L${arrow.arrowX1} ${arrow.arrowY1}L${arrow.arrowX2} ${arrow.arrowY2}Z`,
								fill: lineColor,
								stroke: "none",
							});

							svgg2.appendChild(svgLine);
							svgg2.appendChild(svgArrowHead);
						}
						// show "pinned" points with a circle (these are points with 0,0 deltas, that protect other unmoved points that also do not move because of IUP)
						// - hmm, not sure it is a good idea to try to visualize "pinned" points
						// - they might be pinned by 1 axis, IUP’d by another axis, and moved by yet another axis
						// - maybe useful only if you have one single-tuple axis active?
						/*
						else if (!iup && (delta[0] === 0 && delta[1] === 0)) {

							console.log("circle!");
							let svgCircle = SVG("circle");
							svgCircle.attrsSVG({
								cx: x1,
								cy: y1,
								r: 28,
								stroke: lineColor,
							});
							svgg2.appendChild(svgCircle);
						}
						*/

						x1 = x2;
						y1 = y2;
					});
				});

				svgg.appendChild(svgg2);
				break;


			// loci
			case 7: 
				layer.id = "layer-loci";
				const steps = ui.loci.steps; // we will make steps+1 instances
				let lociX = [], lociY = []; // one for each point

				svgg2 = SVG("g");
				svgg2.id = layer.id + "-X";
				svgg2.attrsSVG({
					"fill": "none",
				});

				// trace X loci from -1 to 1
				// TODO: force inclusion of default location and all axis peaks
				for (let s=0; s<steps; s++) {

					let lociInstanceX, lociInstanceY, iglyphX, iglyphY;
					let T = -1.0 + s/(steps-1) * 2.0;

					// initialize tuple
					let tupleX = [], tupleY = [];
					for (let a=0; a < font.axes.length; a++) {
						tupleX[a] = tupleY[a] = GLOBAL.tuple[a];
					}

					// check which tuple values are non-default
					// - what VF axes are attached to the X and Y axes?
					Qall("#xSelect input:checked").forEach(el => {
						font.axisIndices(el.value).forEach(i => tupleX[i] = T );
					});
					Qall("#ySelect input:checked").forEach(el => {
						font.axisIndices(el.value).forEach(i => tupleY[i] = T );
					});
					
					// make instance
					lociInstanceX = font.addInstance(null, {tuple: tupleX});
					lociInstanceY = font.addInstance(null, {tuple: tupleY});
					iglyphX = glyphApplyVariations(glyph, null, lociInstanceX, {roundDeltas: false});
					iglyphY = glyphApplyVariations(glyph, null, lociInstanceY, {roundDeltas: false});

					// build the SVG polylines in parallel
					for (let p=0; p<glyph.points.length; p++) {
						if (s==0) {
							lociX[p] = "";
							lociY[p] = "";
						}
						else {
							lociX[p] += " ";
							lociY[p] += " ";
						}
						lociX[p] += `${iglyphX.points[p][0]},${iglyphX.points[p][1]}`;
						lociY[p] += `${iglyphY.points[p][0]},${iglyphY.points[p][1]}`;
					}

					// pop instances
					font.instances.pop();
					font.instances.pop();
				}

				// create the SVG element, one set of elements per point
				for (let p=0; p<glyph.points.length; p++) {

					[lociX, lociY].forEach(LOCI => {

						let svgPolyline;

						// draw initial polyline
						svgPolyline = SVG("polyline");
						svgPolyline.attrsSVG({
							points: LOCI[p],
							stroke: LOCI===lociX ? ui.designspace.colors[0] : ui.designspace.colors[1],
							"stroke-width": ui.loci.strokeWidth * uiScale,
							opacity: ui.loci.opacity,
						});
						svgg2.appendChild(svgPolyline);

						// if railway mode, draw extra lines
						if (ui.loci.style == "railway") {

							svgPolyline = SVG("polyline");
							svgPolyline.attrsSVG({
								points: LOCI[p],
								stroke: "white",
								"stroke-width": ui.loci.strokeWidth / 1.5 * uiScale,
							});
							svgg2.appendChild(svgPolyline);

							svgPolyline = SVG("polyline");
							svgPolyline.attrsSVG({
								points: LOCI[p],
								stroke: LOCI===lociX ? ui.designspace.colors[0] : ui.designspace.colors[1],
								"stroke-width": ui.loci.strokeWidth * 1.5 * uiScale,
								"stroke-dasharray": `${1*uiScale} ${5*uiScale}`,
							});
							svgg2.appendChild(svgPolyline);
						}

					});

				}

				svgg.appendChild(svgg2);
				break;

			// point numbers
			case 8: 

				layer.id = "layer-pointnumbers";

				svgg2 = SVG("g");
				svgg2.id = layer.id;
				svgg2.attrsSVG({
					"fill": ui.pointNumbers.color || "black",
					"stroke": "none",
				});

				let xOffset = yOffset = ui.pointNumbers.offset || 0;
				let angle = ui.pointNumbers.angle * Math.PI/180 || 0;
				angle = Math.PI - angle;
				xOffset *= Math.sin(angle) * uiScale;
				yOffset *= Math.cos(angle) * uiScale;

				iglyph.points.forEach((point, pt) => {

					// make a text element for each point
					let svgText = SVG("text");
					svgText.textContent = pt;

					svgText.attrsSVG({
						x: point[0]+xOffset,
						y: point[1]+yOffset,
						style: `font-weight: normal; font-size: ${24*uiScale}px;`,
						class: "point-number",
						transform: `translate(0,${2*point[1]}) scale(1,-1)`,
					});

					if (xOffset < 0)
						svgText.attrsSVG({
							"text-anchor": "end",
						});

					svgg2.appendChild(svgText);
				});

				svgg.appendChild(svgg2);
				break;
		}


		// add layer to the view
		layer.svg = svg;

	});


	svg.appendChild(svgg);
	drawing.appendChild(svg);

	// drawing layers
	// - coordinate grid
	// - default glyph (options: control points)
	// - transformed glyph (options: control points, arrows, per-tuple arrows)
	// - point loci
	// each layer can be on/off


	// default glyph



	// display the tvts

	glyph.tvts.forEach((tvt, t) => {

		// header row
		if (t==0) {
			let liH = document.createElement("li");
			liH.style.display = "grid";
			liH.style.gridTemplateColumns = `1.5em 80px 45px repeat(${GLOBAL.vf.axisCount}, 45px)`
			liH.innerHTML = `<label>TVT</label><label>IUP</label><label>Scalar</label>`;
			GLOBAL.vf.axes.forEach(axis => {
				liH.innerHTML += `<label style="width:100%; text-align:center;"><tt>${axis.tag}</tt></label>`;
			});
			
			panel.appendChild(liH);
		}

		let li = document.createElement("li");
		li.classList.add("tvt");

		// we mention some stuff about tvt id, then numpoints moved or something, then (aligning with axes in instance panel) an SVG graph for each axis
		li.style.display = "grid";
		li.style.gridTemplateColumns = `1.5em 80px 45px repeat(${GLOBAL.vf.axisCount}, 45px)`
		li.style.backgroundColor = "lightgrey";
		li.style.height = "20px";

		let tvtId = document.createElement("div");
		tvtId.innerText = t;
		tvtId.style.backgroundColor = ui.tuple.colors[t % ui.tuple.colors.length];
		tvtId.style.color = "white";
		tvtId.style.fontWeight = "bold";
		tvtId.style.textAlign = "center";

		let tvtDeltas = document.createElement("div");
		let numDeltas = 0;
		for (let p=0; p<tvt.deltas.length; p++) {
			if (tvt.deltas[p] !== null)
				numDeltas++;
		}
		tvtDeltas.innerText = `${tvt.deltas.length-numDeltas}`;
		tvtDeltas.setAttribute("title", `This tuple variation moves ${tvt.deltas.length-numDeltas} points via IUP.`);

		// draw S value as bar graph
		let sValue = iglyph.tvtsVisualization[t].S;
		let tvtS = document.createElement("div");
		let vizWidth = Math.max(0.25, 40 * sValue); // minimum of 0.25px
		tvtS.setAttribute("title", sValue);
		if (sValue > 0) {
			tvtS.setAttribute("style", `width: ${vizWidth}px; height: 20px; background-color: ${ui.tupleScalar.fill};`);
			li.style.backgroundColor = "white";
		}

		li.appendChild(tvtId);
		li.appendChild(tvtDeltas);
		li.appendChild(tvtS);


		// add a graph for each axis
		// - each graph is a single SVG element with descendants
		// - each tuple contains <font.numAxes> graphs representing how this tuple responds to each axis
		for (let a=0; a<GLOBAL.vf.axisCount; a++) {
			let tvtGraphEl = document.createElement("div");
			let tvtGraph = SVG("svg");
			let svgg = SVG("g");

			tvtGraph.setAttributeNS(null, "width","50");
			tvtGraph.setAttributeNS(null, "height","21");
			svgg.setAttributeNS(null, "transform", `translate(20,20) scale(1,-1)`);


			// draw a graph through start, peak, end for each axis
			let Sx = 20, Sy = 20; // x and y scales

			// draw graph paper
			let pathG = SVG("path");
			//let pathD = pathD = `M ${Sx*-1},0 L ${Sx*tvt.start[a]},0 L ${Sx*tvt.peak[a]},${Sy} L ${Sx*tvt.end[a]},0`;
			pathG.setAttributeNS(null, "fill", "none");
			pathG.setAttributeNS(null, "stroke", "darkgrey");
			pathG.setAttributeNS(null, "stroke-width", "0.5");
			pathG.setAttributeNS(null, "d", `M ${Sx*-1} 0 L ${Sx*1} 0 M 0 0 L 0 ${Sy*1}`);
			svgg.appendChild(pathG);

			// draw tuple start, peak, end data
			if (tvt.peak[a] != 0) { // “When a delta is provided for a region defined by n-tuples that have a peak value of 0 for some axis, then that axis does not factor into scalar calculations.”
				// typicaly graphs are shown at https://docs.microsoft.com/en-us/typography/opentype/spec/otvaroverview
				let path = SVG("path");
				let pathD = `M ${Sx*tvt.start[a]},0 L ${Sx*tvt.peak[a]},${Sy*1.0} L ${Sx*tvt.end[a]},0`;
				path.setAttributeNS(null, "fill", "black");
				path.setAttributeNS(null, "stroke", "none");
				path.setAttributeNS(null, "d", pathD);
				svgg.appendChild(path);

				// draw current axis position
				if (iglyph.instance && iglyph.instance.tuple[a] != 0) {
					let needle = SVG("line");
					let needleColor = ui.tupleNeedle.stroke;
					needle.attrsSVG({fill: "none", stroke: needleColor, "stroke-width": "1px", x1: iglyph.instance.tuple[a]*20, y1: 0, x2: iglyph.instance.tuple[a]*20, y2: 20});
					svgg.appendChild(needle);
				}
			}

			tvtGraph.appendChild(svgg);
			tvtGraphEl.appendChild(tvtGraph);

			tvtGraphEl.style.textAlign = "right";
			li.appendChild(tvtGraphEl);
		}
		
		panel.appendChild(li);

		// display the actual deltas for this tuple
		tvtDeltas.addEventListener("click", function (event) {
			let str = "";
			tvt.deltas.forEach((delta, p) => {
				str += `${p}: `;
				if (delta === null)
					str += "—";
				else
					str += `${Math.round(sValue*delta[0])},${Math.round(sValue*delta[1])}`;
				str += "\n";
			});
			alert (str);
		});

	});

}


function playGlyphs() {
	let g = (getActiveGlyph()+1) % GLOBAL.vf.numGlyphs;
	let instance = GLOBAL.vf.addInstance(null, {tuple: GLOBAL.tuple});
	setActiveGlyph (g, instance);
	GLOBAL.vf.instances.pop();
	GLOBAL.vf.timerGlyphPlayer = setTimeout (playGlyphs, 500);
}


// click handlers for all clicks
document.onclick = function (event) {

	//console.log(event.target);
	// about target
	// - via the method of assignment in the if(), target gets the desired element rather than a child (or grandchild) that in fact received the event
	// - the closest(x) method is great: we find whether event.target happened on something within something selected by x
	// - order matters! (e.g. an icon within an instance row must be handled before the instance row itself)
	let target;
	let font = GLOBAL.vf;


	// load default font
	if (event.target == Q("#font-file")) {
		
		Q("body").style.cursor = "wait";

		let vf = new SamsaVF({
			fontFamily: "DefaultFont",
			url: `${GLOBAL.fontList.directory}/${GLOBAL.fontList.default}`, // "fonts/MutatorSans.ttf"
			callback: vfLoaded,
		});
	}

	// else if (event.target.id == "dsAxesMultiple") {
	// 	updateDesignspace();
	// }

	else if (target = event.target.closest("#controls .panel .instantiate")) {

		// create and download the instance		
		let instanceEl = target.closest(".instance");
		let instance = instanceEl.data.instance;

		GLOBAL.vf.makeInstance(instance); // creates instance.static

		//window.open (`data:font/ttf;base64,${uint8ToBase64(instance.static)}`, "_blank"); // this method wasn’t great

		let fauxLink = document.createElement("a");
		fauxLink.download = GLOBAL.vf.filename;
		fauxLink.href = "data:font/ttf;base64," + uint8ToBase64(instance.static);

		//let str = btoa(instance.static)
		//console.log (typeof str);
		//console.log (str);
		//fauxLink.href = "data:font/ttf;base64," + str;
		document.body.appendChild(fauxLink); // needed for Firefox, not Chrome or Safari
		fauxLink.click();
		fauxLink.remove();

	}

	else if (target = event.target.closest(".instance")) {

		setActiveInstance(GLOBAL.vf, target);
	}

	else if (target = event.target.closest("#panel-axes .header .icon")) {

		let fvs = {}, redraw = true;
		if (target.classList.contains("default")) {
			GLOBAL.vf.axes.forEach((axis,a) => {
				fvs[axis.tag] = axis.default;
			});
		}
		else if (target.classList.contains("min")) {
			GLOBAL.vf.axes.forEach((axis,a) => {
				fvs[axis.tag] = axis.min;
			});
		}
		else if (target.classList.contains("max")) {
			GLOBAL.vf.axes.forEach((axis,a) => {
				fvs[axis.tag] = axis.max;
			});
		}
		else
			redraw = false;

		if (redraw) {		
			GLOBAL.tuple = GLOBAL.vf.fvsToTuple(fvs);
			let instance = font.addInstance(null, {tuple: GLOBAL.tuple});
			setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
			font.instances.pop();
			axesUpdateValues();
			setAxes (GLOBAL.vf, fvs);
		}
	}

	else if (event.target.classList.contains("ctrl-pt")) {
		console.log("click pt", event.target);
		console.log(event.target.data.point);
	}

	else if (target = event.target.closest("#panel-glyphs>h2") 
			&& event.target.classList.contains("icon")
			&& !event.target.classList.contains("reveal")) { // this test must be before the other h2 test

		let g;
		let step = false;
		clearTimeout(font.timerGlyphPlayer);
		
		switch (event.target.id) {

			case "glyphs-stepforward":
				g = getActiveGlyph()+1;
				step = true;
				break;
			case "glyphs-stepback":
				g = getActiveGlyph()-1+font.numGlyphs;
				step = true;
				break;
			case "glyphs-play":
				playGlyphs();
				break;
			case "glyphs-stop":
				clearTimeout(font.timerGlyphPlayer);
				font.timerGlyphPlayer = undefined;
				break;
		}

		if (step) {
			let instance = font.addInstance(null, {tuple: GLOBAL.tuple});
			g %= font.numGlyphs;
			clearTimeout(font.timerGlyphPlayer);
			setActiveGlyph (g, instance);
			font.instances.pop();
		}

		// let glyph = font.glyphs[GLOBAL.currentGlyphId];
		// let iglyph = glyphApplyVariations(glyph, null, instance);
		// setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG

	}

	else if (target = event.target.closest("#panel-glyphs>h2") 
			&& event.target.id == "glyphs-ids") {

		// toggle the display of the spans inside the label
		let active = Q("#glyphs-ids").classList.toggle("active");
		let glyphLabels = Qall("#panel-glyphs .glyph-thumb label");
		glyphLabels.forEach(label => {			
			label.querySelector(".number").style.display = active ? "inline" : "none";
			label.querySelector(".name").style.display = active ? "none" : "inline";
		})
	}

	else if (target = event.target.closest("#controls .panel>h2")) {
		// toggle display of panel when panel header is clicked
		let panelDiv = target.parentNode.querySelector("div");
		panelDiv.parentNode.classList.toggle("open");
		if (panelDiv.parentNode.classList.contains("open"))
			panelDiv.style.display = "block";
		else
			panelDiv.style.display = "none";
	}

	else if (target = event.target.closest(".glyph-thumb")) {

		let comps = target.id.split("-");
		let g = comps[1];

		let instance = font.addInstance(null, {tuple: GLOBAL.tuple});
		setActiveGlyph(g, instance);
		font.instances.pop();

	}

	else if (target = event.target.closest("#panel-font-list .font-file")) {

		// load font from the list
		let vf = new SamsaVF({

			fontFamily: "FontNameShouldGoHere",
			url: `${GLOBAL.fontList.directory}/${target.innerText}`,
			callback: vfLoaded,
		});

		return false;
	}

	//return false;

}

function dropHandler(ev) {

// https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/File_drag_and_drop
  // Prevent default behavior (Prevent file from being opened)
  //alert ('File(s) dropped');
  ev.preventDefault();

  if (ev.dataTransfer.items) {
    // Use DataTransferItemList interface to access the file(s)

    for (var i = 0; i < 1 /* ev.dataTransfer.items.length */ ; i++) { // limit to processing of first file dropped

      // If dropped items aren't files, reject them
      if (ev.dataTransfer.items[i].kind === 'file') {
        var file = ev.dataTransfer.items[i].getAsFile();
        let reader = new FileReader();
        reader.__file__ = file;
        reader.onload = function (event) {

			//console.log (event.target.result);
			//console.log (event.target);
			console.log(this.__file__.size)
			let vf = new SamsaVF({

				arrayBuffer: event.target.result,
				inFile: this.__file__.name,
				filesize: this.__file__.size,
				date: this.__file__.lastModified,  // doesn't retrieve the real file date
				callback: vfLoaded,
			});
		};
		reader.readAsArrayBuffer(file); // https://stackoverflow.com/questions/22659164/read-a-drag-and-dropped-file
      }
    }
  }
}

Q("#font-file").addEventListener("drop", dropHandler);
Q("#font-file").addEventListener("dragover",function(e){
	e = e || event;
	e.preventDefault();
},false);





// method to attach multiple SVG attributes at once
// - example of attrs: { d: path, stroke: "black", "stroke-width": "2px", fill: "#eee" }
// - TODO: this is really nasty, we should only apply it to SVG objects

/*Object.prototype.attrsSVG = function (attrs) {
	for (const prop in attrs) {
		this.setAttributeNS(null, prop, attrs[prop]);
	}
}
*/

//let tempSVG = document.createElementNS('http://www.w3.org/2000/svg', "SVG");
/*
document.createElementNS.prototype.attrsSVG = function (attrs) {
	for (const prop in attrs) {
		this.setAttributeNS(null, prop, attrs[prop]);
	}
};
*/
SVGElement.prototype.attrsSVG = function (attrs) {
	for (const prop in attrs) {
		this.setAttributeNS(null, prop, attrs[prop]);
	}
};



function getArrowPathForLine(x1, y1, x2, y2, width, arrowLength, arrowWidth) {
	// returns a string suitable for use as the SVG path "d" attribute
	// it solves two problem of SVG lines when used with a pointed arrow:
	// 1. the line is printed on top of the arrow-head, making the tip blunt
	// 2. markers have colour in themselves, which is not useful when each line needs a custom colour

	// for a line pointing due east, we start at the bottom left corner and go anticlockwise
	// - Hmmm, this won’t work with dash-array for dotted lines

/*
	if (x1==x2 && y1==y2)
		return "M0 0Z";

	let path = `M${x1} ${y1}`;
	let angle = Math.atan2(y2-y1, x2-x1);
	let len = Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
	let anglePerp = angle - Math.PI;
	let xn = (x2-x1)/len;
	let yn = (y2-y1)/len;
	let c = y2-y1, x2-x1
	path += `l${yn*width/2} ${xn*width/2}`;
	path += `l${x2-x1-arrowLength*xn} ${y2-y1-arrowLength*yn}`;
	path += `l${yn*(arrowWidth-width)/2} ${xn*(arrowWidth-width)/2}`;
	path += `L${x1} ${y2}`; // now we are at the tip
	//path += `l${yn*(arrowWidth-width)/2} ${xn*(arrowWidth-width)/2}`;`;
	//path += `l`;
	//path += `l`;
	path += "z";
*/
	return path;
}



// load the list of fonts from samsa-fonts.json into the font-list panel
// - this is the list of fonts available for 1-click loading
// - only for normal web server ("http:" or "https:", not "file:")
if (["http:", "https:"].includes(window.location.protocol)) {

	fetch("samsa-fonts.json")
	.then(response => {
			console.log(response);
			return response.json(); // another promise, not a string!
		}, 
		error => {
			console.log (error);
		}
	)
	.then(responseJSON => { // then for the json() promise
		// populate the font list panel
		let panel = Q("#panel-font-list>div");
		panel.innerHTML = "";
		GLOBAL.fontList = responseJSON;
		GLOBAL.fontList.fonts.forEach(fontFilename => {
			panel.innerHTML += `<li class="font-file"><a href="">${fontFilename}</a></li>`;
		});
	});
}
else {
	let panel = Q("#panel-font-list>div");
	panel.innerHTML = `<div>Remote file loading is not available for protocol “${window.location.protocol}”</div>`;
}



document.addEventListener("keydown", e => {

	if (e.key == " ") {

	}

});


</script>


</body>
</html>