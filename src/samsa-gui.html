<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="utf-8">
<title>Samsa: Variable Font Inspector</title>

<script src="samsa-core.js"></script>

<link rel = "stylesheet" type = "text/css" href = "samsa-gui.css" />
</head>

<body>

<div id="container">

<div id="title"><h1>Samsa</h1>
	<div class="subtitle">
		variable font inspector<br>
		<a href="https://github.com/Lorp/samsa" title="Samsa on GitHub"><img width="15" height="15" src="images/GitHub-Mark-64px.svg"></a>
	</div>
	<div class="subtitle"></div>
</div>

<div id="font-file" class="inactive">
	&lt;drop a variable font here&gt;
</div>

<div id="controls">

	<div id="info" class="panel">
		<h2>Info</h2>
		<div></div>
	</div>

	<div id="axes" class="panel">
		<h2>Axes</h2>
		<div></div>
	</div>

	<div id="instances" class="panel">
		<h2>Instances
			<!--
			<span class="icon" id="instances-as-grid">&#xf00a;</span>
			<span class="icon" id="instances-as-list">&#xf0c9;</span>
			-->
		</h2>
		<div></div>
	</div>

	<div id="tvts" class="panel">
		<h2>Tuple Variations</h2>
		<div></div>
	</div>

	<div id="designspace" class="panel">
		<h2>Designspace</h2>
		<div></div>
	</div>

	<div id="stat" class="panel">
		<h2>STAT</h2>
		<div></div>
	</div>

	<div id="glyphs" class="panel">
		<h2>Glyphs
			<!-- <span class="icon" id="glyphs-rewind">&#xf04a;</span> -->
			<span class="icon" id="glyphs-stepback" title="Step back">&#xf048;</span>
			<span class="icon" id="glyphs-stop" title="Stop playing">&#xf04d;</span>
			<span class="icon" id="glyphs-play" title="Play">&#xf04b;</span>
			<span class="icon" id="glyphs-stepforward" title="Step forward">&#xf051;</span>
			<!-- <span class="icon" id="glyphs-fastforward">&#xf04e;</span> -->
		</h2>
		<div></div>
	<br clear="all">

	</div>

	<div id="font-list" class="panel">
		<h2>Fonts ready to load</h2>
		<div></div>
	</div>

</div>

<div id="drawing"></div>

</div>


<script>


let GLOBAL = {
	vf: null, // maybe allow an array of fonts... select them with a drop down in info panel
	currentGlyphId: null,
	fontList: [],
};


// shorthands
function Q (selector) {
	return document.querySelector(selector);
}
function Qall (selector) {
	return document.querySelectorAll(selector);
}


function getCurrentFvs() {

	// TODO: store the current values separately from the axes’ value to avoid conversions

	let fvs = {};
	document.querySelectorAll(".slider").forEach(slider => {
		let axis = slider.data.axis;
		fvs[axis.tag] = axis.min + slider.value * (axis.max - axis.min);
	});
	return fvs;
}


// TODO: this is needless duplication of what SamsaVF.addInstance() already does
// - we can assign the ui object in the options argument
function appendInstanceEl(instance, select) {

	let font = GLOBAL.vf;
	let panel = document.querySelector("#instances>div");

	// create the instance DOM element
	let li = document.createElement("div"); // not li?
	let icon = "-", title;

	// initialize instance if necessary
	if (instance === undefined) {
		instance = font.addInstance(getCurrentFvs(), { name: "Custom", ui: li }); // { name: "Custom", tuple: [] };
	}

	// list view
	// - items are: bookmark icon, name, n axis settings
	panel.style.minWidth = "100%";
	panel.style.overflowX = "scroll";


	li.classList.add("instance");
	li.style.display = "grid";
	li.style.gridTemplateColumns = `30px 30px 100px 30px 30px repeat(${GLOBAL.vf.axisCount}, 70px)`;

	// instance type
	switch (instance.type) {
		case "default": icon = "&#xf015;"; title = "Default"; break; // FontAwesome home
		case "named": icon = "&#xf02e;"; title = "Named instance"; break; // FontAwesome bookmark
		case "custom": icon = "&#xf1de;"; title = "Custom instance"; break; // FontAwesome sliders
	}
	let cell0 = document.createElement("div");
	cell0.style.cursor = "pointer";
	cell0.style.textAlign = "center";
	cell0.style.fontFamily = "FontAwesome";
	cell0.innerHTML = `<strong title="${title}">${icon}</strong>`;

	// SVG of the A glyph
	// - would current glyph be better? ... probably not, as the image serves as a kind of visual label
	let cell1 = document.createElement("div");
	let svg = SVG("svg");

	let glyph = font.glyphs[getDefaultGlyphId(font)];
	let iglyph = glyphApplyVariations(glyph, instance.tuple);

	if (iglyph && iglyph.numContours > 0) {

		// simple glyph
		let svgPath = SVG("path");
		let svgg = SVG("g");
		let scale = 0.02 * 1000 / font.unitsPerEm;
		svg.setAttributeNS(null, "width","30");
		svg.setAttributeNS(null, "height","30");
		svgg.setAttributeNS(null, "transform", `translate(4,20) scale(${scale},-${scale})`);
		
		//svgMarker.attr({markerWidth:20,markerHeight:20);

 		svgPath.setAttributeNS(null, "d", getGlyphSVGpath(iglyph));

		svg.appendChild(svgg);

		// glyph
		svgg.appendChild(svgPath);

		// x and y axes

		//glyphThumb.appendChild(svg);

	}
	else if (glyph && glyph.numContours < 0) {


	}


	cell1.appendChild(svg);

	// instance name
	let cell2 = document.createElement("div");
	cell2.style.textAlign = "center";
	cell2.innerHTML = `<input value="${instance.name}" ${instance.default ? "readonly " : ""}style="width: 85px">`;

	// visibility
	let cell3 = document.createElement("div");
	cell3.setAttribute("title", "Visibility");
	cell3.style.textAlign = "center";
	cell3.style.fontFamily = "FontAwesome";
	cell3.style.cursor = "pointer";
	cell3.innerHTML = "&#xf06e"; // eye open f070 eye closed

	// instantiate button
	let cell4 = document.createElement("div");
	cell4.classList.add("instantiate");
	cell4.setAttribute("title", "Download TTF");
	cell4.style.textAlign = "center";
	cell4.style.fontFamily = "FontAwesome";
	cell4.style.cursor = "pointer";
	cell4.innerHTML = "&#xf358;"; //"&#xf56d;" // download

	// append all the elements so far
	li.appendChild(cell0);
	li.appendChild(cell1);
	li.appendChild(cell2);
	li.appendChild(cell3);
	li.appendChild(cell4);

	// all the axis settings
	GLOBAL.vf.axes.forEach((axis, a) => {
		let axisCell = document.createElement("div");
		axisCell.style.fontSize = "75%";
		axisCell.style.textAlign = "right";
		axisCell.innerText = instance.fvs[axis.tag];
		li.appendChild(axisCell);
	});

	// bind instance data to instance element
	li.data = { instance: instance };

	// append the instance DOM element
	panel.appendChild(li);

	// make it active
	if (select) {
		setActiveInstance (GLOBAL.vf, li);
	}
}


function vfLoaded (font) {

	GLOBAL.vf = font;

	let panel;

	///////////////////////////////////////////////////////
	// info panel
	///////////////////////////////////////////////////////
	panel = document.querySelector("#info>div");
	panel.innerText = "";

	document.querySelector("#font-file").innerText = font.filename;

	panel.innerHTML += `${font.filename} (${font.filesize || "<em>n</em>"} bytes)<br>`;
	panel.innerHTML += `Full name: ${font.names[4]}<br>`;
	//panel.innerHTML += `Date: ${Date(font.date).toString()}<br>`;

	///////////////////////////////////////////////////////
	// axis panel
	///////////////////////////////////////////////////////
	panel = document.querySelector("#axes>div");
	panel.innerText = "";

	document.querySelector("#font-file").innerText = font.filename; // or font.names[6];

	// add each axis
	font.axes.forEach((axis, a) => {

		let label =  document.createElement("label");
		//label.innerHTML = `<span style="font-weight: bold; font-family: monospace;">${axis.tag}</span> ${axis.name}`;
		label.innerHTML = `<tt>${axis.tag}</tt> ${axis.name}`;
		let docUrl = font.config.docs.axes[axis.tag.toLowerCase()];
		if (docUrl) {
			let docParts = docUrl.split(/:(.+)/)
			if (docUrl && docParts[0] == "regex") {
				docUrl = font.config.docs.regex[docParts[1]].replace("$1", axis.tag.toLowerCase()); // handles microsoft and typenetwork
			}
			label.innerHTML += ` <a href="${docUrl}" class="icon" title="‘${axis.tag}’ axis specification" target="_blank">&#xf02d;</a>`; // book icon, links to the specification of this axis
		}
		panel.appendChild(label);

		let slider = document.createElement("input");
		slider.classList.add("slider");
		slider.setAttribute("type", "range");
		slider.setAttribute("min", 0.0);
		slider.setAttribute("max", 1.0);
		slider.setAttribute("step", 0.001);

		slider.data = {axis: axis};

		//let boxes = document.createElement("label");

		panel.appendChild(slider);
		slider.addEventListener("input", axisInput);

	});

	// add button
	let addInstanceEl = document.createElement("button");
	addInstanceEl.innerText = "Add instance";
	addInstanceEl.id = "instance-add";
	panel.appendChild(addInstanceEl);
	//addInstanceEl.onclick = addInstance;

	addInstanceEl.addEventListener("click", ()=>{
		appendInstanceEl(undefined, true);
	});



	///////////////////////////////////////////////////////
	// instances panel
	///////////////////////////////////////////////////////
	panel = document.querySelector("#instances>div");
	panel.innerText = "";
	panel.style.backgroundClip = "border-box";
	panel.style.padding = "1px 0"; // necessary so the padding of the contents uses the panel’s background-color 

	let li = document.createElement("div");
	let fvsString = "";

	// add each instance
	font.instances.forEach((instance, i) => {
		appendInstanceEl(instance);
	});
	setActiveInstance(GLOBAL.vf); // without an instance parameter, it sets it to the default


	///////////////////////////////////////////////////////
	// glyphs panel
	///////////////////////////////////////////////////////
	GLOBAL.currentGlyphId = getDefaultGlyphId(font);
	updateGlyphsPanel (); // use default glyphs


	Q("body").style.cursor = "default";
}


function axisInput() {

	let font = GLOBAL.vf;

	// create instance
	let instance = font.addInstance(getCurrentFvs()); // { name: "Custom", tuple: [] };

	let glyph = font.glyphs[font.currentGlyphId];
	let iglyph = glyphApplyVariations(glyph, getCurrentFvs());
	setActiveGlyph (font.currentGlyphId); // update the SVG

	// delete instance? definitely!
	font.instances.pop();
}

function updateGlyphsPanel(instance) {

	console.log("Updating glyphs panel");
	let font = GLOBAL.vf;

	///////////////////////////////////////////////////////
	// glyphs panel
	///////////////////////////////////////////////////////
	let panel = document.querySelector("#glyphs>div");
	panel.innerText = "";
	let scale = 0.05 * 1000 / font.unitsPerEm;

	for (let g=0; g < font.numGlyphs; g++) {

		let glyph = instance ? instance.glyphs[g] : font.glyphs[g];
		let glyphName;

		let glyphThumb = document.createElement("div");
		glyphThumb.classList.add("glyph-thumb");
		glyphThumb.setAttribute("id", `g-${g}`);


		if (glyph && glyph.numContours > 0) {

			// simple glyph
			let svg = SVG("svg");
			let svgPath = SVG("path");
			let svgg = SVG("g");

			svg.setAttributeNS(null, "width","90");
			svg.setAttributeNS(null, "height","90");
			svgg.setAttributeNS(null, "transform", `translate(20,60) scale(${scale},-${scale})`);
			
			//svgMarker.attr({markerWidth:20,markerHeight:20);

			svgPath.setAttributeNS(null, "d", getGlyphSVGpath(glyph));

			svg.appendChild(svgg);


			// glyph
			svgg.appendChild(svgPath);

			// x and y axes

			glyphThumb.appendChild(svg);

			glyphName = glyph.name;
		}
		else if (glyph && glyph.numContours < 0) {

			glyphName = glyph.name;

		}

		let selected = document.createElement("div");
		selected.classList.add("selected");
		glyphThumb.appendChild(selected);
		panel.appendChild(glyphThumb);


		let label = document.createElement("label");

		label.innerText = glyphName ? glyphName : `#${g}`; // TODO: implement a toggle so we see glyph id when we want to

		glyphThumb.appendChild(label);

	}

	setActiveGlyph(GLOBAL.currentGlyphId);

}

function setAxes (font, fvs) {
	

	let sliders = document.querySelectorAll(".slider");
	font.axes.forEach((axis, a) => {

		if (axis.min > axis.max)
			return;

		let val = fvs[axis.tag];
		if (val < axis.min)
			val = axis.min;
		if (val > axis.max)
			val = axis.max;

		sliders[a].value = (val - axis.min) / (axis.max - axis.min);
	});
}



function setActiveInstance (font, target) {

	document.querySelectorAll(".instance").forEach((el, i) => {

		let instance = font.instances[i]; // font.instances[0] is the default "instance"

		// update instance ui
		if (el == target || (!target && instance.default)) { // allows for future reordering
			
			el.classList.add("active");
			setAxes (font, instance.fvs);
			instanceApplyVariations (font, instance);
			updateGlyphsPanel (instance);
		}
		else {
			el.classList.remove("active");
			//target.data.selected = true;
		}
	});
}


function getActiveGlyph () {

	let g = 0;
	document.querySelectorAll(".glyph-thumb .selected").forEach(el => {
		if (el.style.display == "block") {
			let comps = el.parentNode.id.split("-");
			g = 1 * comps[1];
		}
	});
	return g;
	// TODO: it would be simpler just to store the active glyph somewhere
	// return font.currentGlyphId;
}


function setActiveGlyph (g) {

	let font = GLOBAL.vf;
	if (g === undefined)
		g = 0;
	g *= 1;

	font.currentGlyphId = g; // TODO: check g < numGlyphs

	document.querySelectorAll(".glyph-thumb").forEach(el => {

		document.querySelector(`#${el.id} .selected`).style.display = "none";
	});
	
	document.querySelector(`#g-${g} .selected`).style.display = "block";
	// TODO: wouldn’t this be more elegant setting background-color with a class?



	let glyph = font.glyphs[g];
	let iglyph = glyphApplyVariations(glyph, getCurrentFvs());
	//setActiveGlyph(g);

	//event.target.classList.add("selected");

	//console.log ("Glyph " + g)
	// clear main window and tvts panel
	let drawing = document.querySelector("#drawing");
	drawing.innerHTML = "";
	let panel = document.querySelector("#tvts>div");
	panel.innerHTML = "";

	let layers = []; // layers are drawn from low values (bottom) to high values (top)


	let scale = 0.5 * 1000 / font.unitsPerEm;
	let opacity = 0.5;
	let svg = SVG("svg");
	let svgg = SVG("g"); // this transforms everything inside it
	let svgDefs = SVG("defs")
	let svgMarker = SVG("marker")
	let svgMarkerPath = SVG("path")
	svg.setAttributeNS(null, "width","1000");
	svg.setAttributeNS(null, "height","1000");
	svgg.setAttributeNS(null, "transform", `translate(30,500) scale(${scale},-${scale})`);

	// define marker
	svgMarker.setAttributeNS(null, "id","arrow");
	svgMarker.setAttributeNS(null, "markerWidth","20");
	svgMarker.setAttributeNS(null, "markerHeight","20");
	svgMarkerPath.setAttributeNS(null, "d", "M 10 5 L 3 2 L 3 8 z");
	svgMarker.setAttributeNS(null, "fill", `${GLOBAL.vf.config.ui.arrow.color}`);
	svgMarker.setAttributeNS(null, "orient", "auto");
	svgMarker.setAttributeNS(null, "refX", "10");
	svgMarker.setAttributeNS(null, "refY", "5");
	svgMarker.appendChild(svgMarkerPath);
	svgDefs.appendChild(svgMarker);

	/*
	// filters to use... not yet :)
	// - https://developer.mozilla.org/en-US/docs/Web/SVG/Element/filter
	let svgFilter = SVG("filter");
	svgFilter.setAttributeNS(null, "id","blur");
	let svgFilterBlur = SVG("feGaussianBlur");
	svgFilterBlur.setAttributeNS(null, "stdDeviation","5");
	svgFilter.appendChild(svgFilterBlur);
	svgDefs.appendChild(svgFilter);
	*/

	svg.appendChild(svgDefs);


	// TODO: we're not yet using the layer idea, but I think it will be useful to allow us to make minimal updates
	for (let L=0; L<6; L++) {
		let svgPath;
		let layer = layers[L] = {
			on: true,
			svg: null,
		};

		switch (L) {

			// coordinate grid
			case 0:
				layer.type = "grid";
				svgPath = SVG("path");

				svgPath.setAttributeNS(null, "d", "M-10000,0 L10000,0 M0,-10000 L0,10000");
				svgPath.setAttributeNS(null, "stroke", `lightblue`);
				svgPath.setAttributeNS(null, "stroke-width", `1`);
				svgPath.setAttributeNS(null, "fill", "none");

				svgg.appendChild(svgPath);

				break;

			case 1:
				layer.type = "default";
				svgPath = SVG("path");

				// draw glyph
				svgPath.setAttributeNS(null, "d", getGlyphSVGpath(glyph));
				svgPath.setAttributeNS(null, "stroke", `black`); // make this take a value from the ui config
				svgPath.setAttributeNS(null, "stroke-width", `${GLOBAL.vf.config.ui.glyph.strokeWidth}px`);
				svgPath.setAttributeNS(null, "fill", `#eee`);
				svgPath.setAttributeNS(null, "d", getGlyphSVGpath(glyph));
				svgg.appendChild(svgPath);

				break;

			case 2:
				layer.type = "instance";
				svgPath = SVG("path");

				svgPath.setAttributeNS(null, "style",`opacity:${opacity}`);

				// draw glyph with variations taken from the current axis settings
				// - should we render all active instances in this "layer"?

				svgPath.setAttributeNS(null, "d", getGlyphSVGpath(iglyph));
				svgPath.setAttributeNS(null, "stroke", `black`); // make this take a value from the ui config
				svgPath.setAttributeNS(null, "stroke-width", `${GLOBAL.vf.config.ui.glyph.strokeWidth}px`);
				svgPath.setAttributeNS(null, "fill", `#00f`);
				// svgPath.setAttributeNS(null, "filter", "url(#blur)"); not yet :)


				svgg.appendChild(svgPath);
				break;

			case 3:
				layer.type = "instance-points";
				svgg2 = SVG("g");
				svgg2.setAttributeNS(null, "fill", "none");
				svgg2.setAttributeNS(null, "stroke-width", "1px");
				svgg2.setAttributeNS(null, "stroke", GLOBAL.vf.config.ui.arrow.color);
				iglyph.points.forEach(function (pt, p) {
					// TODO: use individual SVG elements for each point when we implement dragging of instance points
					let size = 4; //font.config.ui.point.size;
					svgPath = SVG("path");
					svgPath.setAttributeNS(null, "d", `M${pt[0]-size},${pt[1]} L${pt[0]+size},${pt[1]} M${pt[0]},${pt[1]+size} L${pt[0]},${pt[1]-size}`);
					svgg2.appendChild(svgPath);
				});

				svgg.appendChild(svgg2);
				break;

			case 4:
				layer.type = "arrows";

				svgg2 = SVG("g");
				svgg2.setAttributeNS(null, "stroke", `${GLOBAL.vf.config.ui.arrow.color}`);
				svgg2.setAttributeNS(null, "stroke-width", `${GLOBAL.vf.config.ui.arrow.strokeWidth}`);

				//console.log(iglyph.touched);

				glyph.points.forEach((point1, pt) => {
					let point2 = iglyph.points[pt]; // transformed point

					// we have to truncate each line so that it ends in a nice point (might be more elegant to draw the whole line+arrow as a path)
					let x1 = point1[0], y1 = point1[1], x2 = point2[0], y2 = point2[1];

					if (x1==x2 && y1==y2) {
						// same location (now we don’t need to worry about divide-by-zero in the else)
					}
					else {

						let svgLine = SVG("line");

						let hypot = Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));
						let dx = 3 * (x2-x1)/hypot;
						let dy = 3 * (y2-y1)/hypot;
						
						svgLine.setAttributeNS(null, "x1", x1);
						svgLine.setAttributeNS(null, "y1", y1);
						//svgLine.setAttributeNS(null, "x2", x2-dx); // TODO: This changes where the arrow lands, of course, so is not much use!
						//svgLine.setAttributeNS(null, "y2", y2-dy); // TODO: This changes where the arrow lands, of course, so is not much use!
						svgLine.setAttributeNS(null, "x2", x2);
						svgLine.setAttributeNS(null, "y2", y2);

						if (!iglyph.touched[pt]) { // IUP
							svgLine.setAttributeNS(null, "stroke-dasharray", "1 4");
						}

						svgLine.setAttributeNS(null, "marker-end", "url(#arrow)");
						svgg2.appendChild(svgLine);

					}
				});										

				svgg.appendChild(svgg2);
				break;

			case 5:

				// draw control points, grouped in their own <g>
				layer.type = "points";
				svgg2 = SVG("g");

				glyph.points.forEach(function (pt, p) {
					let size = font.config.ui.point.size;
					let svgP;
					if (pt[2]) {
						svgP = SVG("rect"); // on-curve
						svgP.classList.add("ctrl-pt");
						svgP.setAttributeNS(null, "x", pt[0]-size);
						svgP.setAttributeNS(null, "y", pt[1]-size);
						svgP.setAttributeNS(null, "width", 2*size);
						svgP.setAttributeNS(null, "height", 2*size);
					}
					else {
						svgP = SVG("circle"); // off-curve
						svgP.classList.add("ctrl-pt");
						svgP.setAttributeNS(null, "cx", pt[0]);
						svgP.setAttributeNS(null, "cy", pt[1]);
						svgP.setAttributeNS(null, "r", 4);
					}
					svgP.data = { point: pt };
					svgg2.appendChild(svgP);
				});

				svgg.appendChild(svgg2);
				break;

		}



		// add layer to the view

		layer.svg = svg;

	}


	svg.appendChild(svgg);
	drawing.appendChild(svg);

	// drawing layers
	// - coordinate grid
	// - default glyph (options: control points)
	// - transformed glyph (options: control points, arrows, per-tuple arrows)
	// - point loci
	// each layer can be on/off


	// default glyph


	// display the tvts

	glyph.tvts.forEach((tvt, t) => {

		let li = document.createElement("li");
		li.classList.add("tvt");

		// we mention some stuff about tvt id, then numpoints moved or something, then (aligning with axes in instance panel) an SVG graph for each axis
		li.style.display = "grid";
		li.style.gridTemplateColumns = `1.5em 100px 1.5em repeat(${GLOBAL.vf.axisCount}, 70px)`

		let tvtId = document.createElement("div");
		tvtId.innerText = t;

		let tvtDeltas = document.createElement("div");
		tvtDeltas.innerText = tvt.peak[0]; // JSON.stringify(tvt.deltas);

		let tvtBlank = document.createElement("div");
		tvtBlank.innerText = "x";

		li.appendChild(tvtId);
		li.appendChild(tvtDeltas);
		li.appendChild(tvtBlank);

		// add an svg graph for each axis
		for (let a=0; a<GLOBAL.vf.axisCount; a++) {
			let tvtGraphEl = document.createElement("div");
			let tvtGraph = SVG("svg");
			let svgg = SVG("g");

			tvtGraph.setAttributeNS(null, "width","50");
			tvtGraph.setAttributeNS(null, "height","30");
			svgg.setAttributeNS(null, "transform", `translate(25,25) scale(1,-1)`);


			// draw a graph through start, peak, end for each axis
			let Sx = 20, Sy = 20; // x and y scales

			// draw graph paper
			let pathG = SVG("path");
			//let pathD = pathD = `M ${Sx*-1},0 L ${Sx*tvt.start[a]},0 L ${Sx*tvt.peak[a]},${Sy} L ${Sx*tvt.end[a]},0`;
			pathG.setAttributeNS(null, "fill", "none");
			pathG.setAttributeNS(null, "stroke", "darkgrey");
			pathG.setAttributeNS(null, "stroke-width", "0.5");
			pathG.setAttributeNS(null, "d", `M ${Sx*-1},0 L ${Sx*1},0 M 0,0 L 0,${Sy*1}`);
			svgg.appendChild(pathG);

			// draw tuple start, peak, end data
			if (tvt.peak[a] != 0) { // “When a delta is provided for a region defined by n-tuples that have a peak value of 0 for some axis, then that axis does not factor into scalar calculations.”
				// typicaly graphs are shown at https://docs.microsoft.com/en-us/typography/opentype/spec/otvaroverview
				let path = SVG("path");
				let pathD = `M ${Sx*tvt.start[a]},0 L ${Sx*tvt.peak[a]},${Sy*1.0} L ${Sx*tvt.end[a]},0`;
				path.setAttributeNS(null, "fill", "none");
				path.setAttributeNS(null, "stroke", "black");
				path.setAttributeNS(null, "stroke-width", "2");
				path.setAttributeNS(null, "d", pathD);
				svgg.appendChild(path);
			}


			tvtGraph.appendChild(svgg);
			tvtGraphEl.appendChild(tvtGraph);

			tvtGraphEl.style.textAlign = "right";
			li.appendChild(tvtGraphEl);
		}
		


		//panel.innerHTML += JSON.stringify(tvt) + "<br>";

		panel.appendChild(li);

	});





}


function playGlyphs() {
	g = getActiveGlyph();
	setActiveGlyph ((g+1) % GLOBAL.vf.numGlyphs);
	GLOBAL.vf.timerGlyphPlayer = setTimeout (playGlyphs, 500);
}


// click handlers for all clicks
document.onclick = function (event) {

console.log(event.target);
	// about target
	// - via the method of assignment in the if(), target gets the desired element rather than a child (or grandchild) that in fact received the event
	// - the closest(x) method is great: we find whether event.target happened on something within something selected by x
	// - order matters! (e.g. an icon within an instance row must be handled before the instance row itself)
	let target;
	let font = GLOBAL.vf;

	//console.log(event.target.classList);


	if (event.target == document.querySelector("#font-file")) {
	//if (target = event.target.closest("#font-file")) {
		// debug hack to load MutatorSans easily
		Q("body").style.cursor = "wait";

		let vf = new SamsaVF({

			fontFamily: "FontNameShouldGoHere",
			url: "fonts/MutatorSans.ttf",
			callback: vfLoaded,
		});
	}

	else if (target = event.target.closest("#controls .panel .instantiate")) {

		// create and download the instance		
		let instanceEl = target.closest(".instance");
		let instance = instanceEl.data.instance;

		GLOBAL.vf.makeInstance(instance); // creates instance.static

		//window.open (`data:font/ttf;base64,${uint8ToBase64(instance.static)}`, "_blank"); // this method wasn’t great

		let fauxLink = document.createElement("a");
		fauxLink.download = GLOBAL.vf.filename;
		fauxLink.href = "data:font/ttf;base64," + uint8ToBase64(instance.static);

		//let str = btoa(instance.static)
		//console.log (typeof str);
		//console.log (str);
		//fauxLink.href = "data:font/ttf;base64," + str;
		document.body.appendChild(fauxLink); // needed for Firefox, not Chrome or Safari
		fauxLink.click();
		fauxLink.remove();

	}

	else if (target = event.target.closest(".instance")) {

		setActiveInstance(GLOBAL.vf, target);
	}

	//else if (target = event.target.closest(".ctrl-pt")) {
	else if (event.target.classList.contains("ctrl-pt")) {
		console.log("click pt", event.target);
		console.log(event.target.data.point);
	}

	else if (target = event.target.closest("#glyphs>h2") && event.target.classList.contains("icon")) { // ordering important

		let g;
		clearTimeout(GLOBAL.vf.timerGlyphPlayer);

		switch (event.target.id) {

			case "glyphs-stepforward":
				clearTimeout(GLOBAL.vf.timerGlyphPlayer);
				g = getActiveGlyph();
				setActiveGlyph ((g+1) % font.numGlyphs);
				break;
			case "glyphs-stepback":
				clearTimeout(GLOBAL.vf.timerGlyphPlayer);
				g = getActiveGlyph();
				setActiveGlyph ((g-1+font.numGlyphs) % font.numGlyphs);
				break;
			case "glyphs-play":
				playGlyphs();
				break;
			case "glyphs-stop":
				clearTimeout(GLOBAL.vf.timerGlyphPlayer);
				GLOBAL.vf.timerGlyphPlayer = undefined;
				break;
		}

	}

	else if (target = event.target.closest("#controls .panel>h2")) {
		// toggle display of panel when panel header is clicked
		let panelDiv = target.parentNode.querySelector("div");
		console.log (panelDiv);
		if (panelDiv) {
			if (panelDiv.style.display == "none") {
				panelDiv.style.display = "block";
			}
			else if (panelDiv.style.display = "block")
				panelDiv.style.display = "none";	
		}
	}

	else if (target = event.target.closest(".glyph-thumb")) {

		let comps = target.id.split("-");
		let g = comps[1];

		setActiveGlyph(g);

	}

	else if (target = event.target.closest("#font-list .font-file")) {

		// load font mutator

		let vf = new SamsaVF({

			fontFamily: "FontNameShouldGoHere",
			url: `fonts/${target.innerText}`,
			callback: vfLoaded,
		});

		return false;
	}
}

function dropHandler(ev) {

// https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/File_drag_and_drop
  // Prevent default behavior (Prevent file from being opened)
  //alert ('File(s) dropped');
  ev.preventDefault();

  if (ev.dataTransfer.items) {
    // Use DataTransferItemList interface to access the file(s)

    for (var i = 0; i < 1 /* ev.dataTransfer.items.length */ ; i++) { // limit to processing of first file dropped

      // If dropped items aren't files, reject them
      if (ev.dataTransfer.items[i].kind === 'file') {
        var file = ev.dataTransfer.items[i].getAsFile();
        let reader = new FileReader();
        reader.__file__ = file;
        reader.onload = function (event) {

			//console.log (event.target.result);
			//console.log (event.target);
			console.log(this.__file__.size)
			let vf = new SamsaVF({

				arrayBuffer: event.target.result,
				inFile: this.__file__.name,
				filesize: this.__file__.size,
				date: this.__file__.lastModified,  // doesn't retrieve the real file date
				callback: vfLoaded,
			});
		};
		reader.readAsArrayBuffer(file); // https://stackoverflow.com/questions/22659164/read-a-drag-and-dropped-file
      }
    }
  }
}

document.querySelector("#font-file").addEventListener("drop", dropHandler);
document.querySelector("#font-file").addEventListener("dragover",function(e){
	e = e || event;
	e.preventDefault();
},false);



function SVG(tag) {
    return document.createElementNS('http://www.w3.org/2000/svg', tag);
}



// load font list
// TODO: switch to modern fetch(url)
let oReq = new XMLHttpRequest();
oReq.open("GET", "fonts/_fontlist_.json", true);
oReq.responseType = "json";
oReq.onload = function(oEvent) {
	GLOBAL.fontList = this.response;
	// need to handle onreadystatechange to detect errors

	let panel = Q("#font-list>div");
	panel.innerHTML = "";
	//panel.innerHTML += "<ul>";
	GLOBAL.fontList.forEach(fontFilename => {
		panel.innerHTML += `<li class="font-file"><a href="">${fontFilename}</a></li>`;
	});

	//panel.innerHTML += "</ul>";
};
oReq.send();



</script>


</body>
</html>