<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="utf-8">
<title>Samsa: Variable Font Inspector</title>

<script src="samsa-core.js"></script>

<link rel = "stylesheet" type = "text/css" href = "samsa-gui.css" />
</head>

<body>

<div id="container">

<div id="title"><h1>Samsa</h1>
	<div class="subtitle">
		variable font inspector<br>
		<a href="https://github.com/Lorp/samsa" title="Samsa on GitHub"><img width="15" height="15" src="images/GitHub-Mark-64px.svg"></a>
	</div>
	<div class="subtitle"></div>
</div>

<div id="font-file" class="inactive">
	&lt;drop a variable font here&gt;
</div>

<div id="controls" style="overflow-y: scroll;">

	<div id="info" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Info</h2>
		<div></div>
	</div>

	<div id="axes" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Axes</h2>
		<div></div>
	</div>

	<div id="instances" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Instances
			<!--
			<span class="icon" id="instances-as-grid">&#xf00a;</span>
			<span class="icon" id="instances-as-list">&#xf0c9;</span>
			-->
		</h2>
		<div></div>
	</div>

	<div id="tvts" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Tuple Variations</h2>
		<div style="overflow-x: scroll;"></div>
	</div>

	<div id="designspace" class="panel open">
		<h2><span class="icon bold reveal">&#xf04b;</span> Designspace</h2>
		<div></div>
	</div>

<!--
	<div id="stat" class="panel">
		<h2>STAT</h2>
		<div></div>
	</div>
-->

	<div id="glyphs" class="panel open">
		<h2><span class="icon bold reveal open">&#xf04b;</span> Glyphs
			<!-- <span class="icon bold" id="glyphs-rewind">&#xf04a;</span> -->
			<span class="icon bold" id="glyphs-stepback" title="Step back">&#xf048;</span>
			<span class="icon bold" id="glyphs-stop" title="Stop playing">&#xf04d;</span>
			<span class="icon bold" id="glyphs-play" title="Play">&#xf04b;</span>
			<span class="icon bold" id="glyphs-stepforward" title="Step forward">&#xf051;</span>
			<!-- <span class="icon bold" id="glyphs-fastforward">&#xf04e;</span> -->
		</h2>
		<div></div>
	<br clear="all">

	</div>

	<div id="font-list" class="panel open">
		<h2><span class="icon bold reveal open">&#xf04b;</span> Fonts ready to load</h2>
		<div></div>
	</div>

</div>

<div id="drawing"></div>

</div>


<script>


let GLOBAL = {
	vf: null, // maybe allow an array of fonts... select them with a drop down in info panel
	currentGlyphId: null,
	fontList: [],
};


// shorthands
function Q (selector) {
	return document.querySelector(selector);
}

function Qall (selector) {
	return document.querySelectorAll(selector);
}


function getCurrentFvs() {

	// TODO: store the current values separately from the axes’ value to avoid conversions

	let fvs = {};
	Qall(".slider").forEach(slider => {
		let axis = slider.data.axis;
		fvs[axis.tag] = axis.min + slider.value * (axis.max - axis.min);
	});
	return fvs;
}


// TODO: this is needless duplication of what SamsaVF.addInstance() already does
// - we can assign the ui object in the options argument
function appendInstanceEl(instance, select) {

	let font = GLOBAL.vf;
	let panel = Q("#instances>div");

	// create the instance DOM element
	let li = document.createElement("div"); // not li?
	let icon = "-", title;

	// initialize instance if necessary
	if (instance === undefined) {
		instance = font.addInstance(getCurrentFvs(), { name: "Custom", ui: li }); // { name: "Custom", tuple: [] };
	}

	// list view
	// - items are: bookmark icon, name, n axis settings
	panel.style.minWidth = "100%";
	panel.style.overflowX = "scroll";


	li.classList.add("instance");
	li.style.display = "grid";
	li.style.gridTemplateColumns = `30px 30px 100px 30px 30px repeat(${GLOBAL.vf.axisCount}, 70px)`;

	// instance type
	switch (instance.type) {
		case "default": icon = "&#xf015;"; title = "Default"; break; // FontAwesome home
		case "named": icon = "&#xf02e;"; title = "Named instance"; break; // FontAwesome bookmark
		case "custom": icon = "&#xf1de;"; title = "Custom instance"; break; // FontAwesome sliders
	}
	let cell0 = document.createElement("div");
	cell0.style.cursor = "pointer";
	cell0.style.textAlign = "center";
	cell0.style.fontFamily = "FontAwesome";
	cell0.innerHTML = `<strong title="${title}">${icon}</strong>`;

	// SVG of the A glyph
	// - would current glyph be better? ... the image serves as a kind of visual label, but...
	let cell1 = document.createElement("div");
	let svg = SVG("svg");

	let glyph = font.glyphs[getDefaultGlyphId(font)];
	let iglyph = glyphApplyVariations(glyph, instance.tuple); // TODO: make composite-ready

	if (iglyph && iglyph.numContours > 0) {

		// simple glyph
		let svgPath = SVG("path");
		let svgg = SVG("g");
		let scale = 0.02 * 1000 / font.unitsPerEm;
		svg.setAttributeNS(null, "width","30");
		svg.setAttributeNS(null, "height","30");
		svgg.setAttributeNS(null, "transform", `translate(4,20) scale(${scale},-${scale})`);
		
		//svgMarker.attr({markerWidth:20,markerHeight:20);

 		svgPath.setAttributeNS(null, "d", getGlyphSVGpath(iglyph));

		svg.appendChild(svgg);

		// glyph
		svgg.appendChild(svgPath);

		// x and y axes

		//glyphThumb.appendChild(svg);

	}
	else if (glyph && glyph.numContours < 0) {


	}


	cell1.appendChild(svg);

	// instance name
	let cell2 = document.createElement("div");
	cell2.style.textAlign = "center";
	cell2.innerHTML = `<input value="${instance.name}" ${instance.default ? "readonly " : ""}style="width: 85px">`;

	// visibility
	let cell3 = document.createElement("div");
	cell3.setAttribute("title", "Visibility");
	cell3.style.textAlign = "center";
	cell3.style.fontFamily = "FontAwesome";
	cell3.style.cursor = "pointer";
	cell3.innerHTML = "&#xf06e"; // eye open f070 eye closed

	// instantiate button
	let cell4 = document.createElement("div");
	cell4.classList.add("instantiate");
	cell4.setAttribute("title", "Download TTF");
	cell4.style.textAlign = "center";
	cell4.style.fontFamily = "FontAwesome";
	cell4.style.cursor = "pointer";
	cell4.innerHTML = "&#xf358;"; //"&#xf56d;" // download

	// append all the elements so far
	li.appendChild(cell0);
	li.appendChild(cell1);
	li.appendChild(cell2);
	li.appendChild(cell3);
	li.appendChild(cell4);

	// all the axis settings
	GLOBAL.vf.axes.forEach((axis, a) => {
		let axisCell = document.createElement("div");
		axisCell.style.fontSize = "75%";
		axisCell.style.textAlign = "right";
		axisCell.innerText = instance.fvs[axis.tag];
		li.appendChild(axisCell);
	});

	// bind instance data to instance element
	li.data = { instance: instance };

	// append the instance DOM element
	panel.appendChild(li);

	// make it active
	if (select) {
		setActiveInstance (GLOBAL.vf, li);
	}
}


function vfLoaded (font) {

	GLOBAL.vf = font;
	GLOBAL.vf.config.visualization = true;
	console.log(GLOBAL.vf.config);
	let panel;

	///////////////////////////////////////////////////////
	// Info panel
	///////////////////////////////////////////////////////
	panel = Q("#info>div");
	panel.innerText = "";

	Q("#font-file").innerText = font.filename;

	panel.innerHTML += `${font.filename} (${font.filesize || "<em>n</em>"} bytes)<br>`;
	panel.innerHTML += `Full name: ${font.names[4]}<br>`;
	//panel.innerHTML += `Date: ${Date(font.date).toString()}<br>`;

	///////////////////////////////////////////////////////
	// Axes panel
	///////////////////////////////////////////////////////
	panel = Q("#axes>div");
	panel.innerText = "";

	Q("#font-file").innerText = font.filename; // or font.names[6];

	// add each axis
	font.axes.forEach((axis, a) => {

		let label =  document.createElement("label");
		//label.innerHTML = `<span style="font-weight: bold; font-family: monospace;">${axis.tag}</span> ${axis.name}`;
		label.innerHTML = `<tt>${axis.tag}</tt> ${axis.name}`;
		let docUrl = font.config.docs.axes[axis.tag.toLowerCase()];
		if (docUrl) {
			let docParts = docUrl.split(/:(.+)/)
			if (docUrl && docParts[0] == "regex") {
				docUrl = font.config.docs.regex[docParts[1]].replace("$1", axis.tag.toLowerCase()); // handles microsoft and typenetwork
			}
			label.innerHTML += ` <a href="${docUrl}" class="icon bold" title="‘${axis.tag}’ axis specification" target="_blank">&#xf02d;</a>`; // book icon, links to the specification of this axis
		}
		panel.appendChild(label);

		let slider = document.createElement("input");
		slider.classList.add("slider");
		slider.setAttribute("type", "range");
		slider.setAttribute("min", 0.0);
		slider.setAttribute("max", 1.0);
		slider.setAttribute("step", 0.001);

		slider.data = {axis: axis};

		//let boxes = document.createElement("label");

		panel.appendChild(slider);
		slider.addEventListener("input", axisInput);

	});

	// add button
	let addInstanceEl = document.createElement("button");
	addInstanceEl.innerText = "Add instance";
	addInstanceEl.id = "instance-add";
	panel.appendChild(addInstanceEl);
	//addInstanceEl.onclick = addInstance;

	addInstanceEl.addEventListener("click", ()=>{
		appendInstanceEl(undefined, true);
	});



	///////////////////////////////////////////////////////
	// Instances panel
	///////////////////////////////////////////////////////
	panel = Q("#instances>div");
	panel.innerText = "";
	panel.style.backgroundClip = "border-box";
	panel.style.padding = "1px 0"; // necessary so the padding of the contents uses the panel’s background-color 

	let li = Q("div");
	let fvsString = "";

	// add each instance
	font.instances.forEach((instance, i) => {
		appendInstanceEl(instance);
	});
	setActiveInstance(GLOBAL.vf); // without an instance parameter, it sets it to the default


	///////////////////////////////////////////////////////
	// Designspace panel
	///////////////////////////////////////////////////////
	panel = Q("#designspace>div");
	panel.innerText = "";
	panel.style.backgroundColor = "white";

	// build cartesian area
	let cartesian = document.createElement("div");
	cartesian.id = "ds-cartesian";
	cartesian.setAttribute("style", "width: 100%; height: 360px;");
	panel.appendChild(cartesian);

	// build dropdown select elements
	let htmlX = `<select id="xSelect" multiple>`;
	let htmlY = `<select id="ySelect" multiple>`;
	GLOBAL.vf.axes.forEach((axis,a) => {
		htmlX += `<option${a==0 ? " selected" : ""}>${axis.tag}</option>`;
		htmlY += `<option${a==1 ? " selected" : ""}>${axis.tag}</option>`;
	});
	htmlX += `</select>`;
	htmlY += `</select>`;
	panel.innerHTML += `<div class="cartesian-axis-row"><div>X</div>${htmlX}<div id="xValue"></div></div>`;
	panel.innerHTML += `<div class="cartesian-axis-row"><div>Y</div>${htmlY}<div id="yValue"></div></div>`;
	;
	/*let xSelect = document.createElement("select");
	let ySelect = document.createElement("select");
	xSelect.id = "xSelect";
	ySelect.id = "ySelect";
	xSelect.setAttribute("multiple", true);
	ySelect.setAttribute("multiple", true);
*/

	//let xTitle = document.createElement("option"); xTitle.innerText = "X";
	//let yTitle = document.createElement("option"); yTitle.innerText = "Y";
	//xSelect.appendChild(xTitle); xTitle.setAttribute("disabled", true);
	//ySelect.appendChild(yTitle); yTitle.setAttribute("disabled", true);


/*
	GLOBAL.vf.axes.forEach((axis,a) => {
		xEl = document.createElement("option"); xEl.innerText = axis.tag;
		yEl = document.createElement("option"); yEl.innerText = axis.tag;
		xSelect.appendChild(xEl);
		ySelect.appendChild(yEl);
		switch (a) {
			case 0: xEl.setAttribute("selected", true); break;
			case 1: yEl.setAttribute("selected", true); break;
		}
	});
	panel.appendChild(xSelect);
	panel.appendChild(ySelect);
*/

	// TODO: consider user/normalized option

	updateDesignspace();



/*
	// TODO: hmm, this doesn’t work
	//console.log(cbxMultiple)
	cbxMultiple.onchange = function (event) {
		alert ("click");
		if (cbxMultiple.checked) {
			xSelect.setAttribute("multiple", true);
			ySelect.setAttribute("multiple", true);
		}
		else {
			xSelect.removeAttribute("multiple");
			ySelect.removeAttribute("multiple");
		}
	};
*/


	// TODO: .designspace export - is this useful?
	if (false) {

		let exportEl = document.createElement("button");
		exportEl.innerText = "Export as .designspace";
		exportEl.id = "instance-add";
		panel.appendChild(exportEl);

		/*
		<designspace format="3">
			<axes>
				<!-- define axes here -->
				<axis../>
				</axes>
			<sources>
				<!-- define masters here -->
				<source../>
			</sources>
			<instances>
				<!-- define instances here -->
				<instance../>
			</instances>
		</designspace>
		*/

		let designspace = document.createElement("designspace");
		designspace.setAttribute("format", 3);
		let dsAxes = document.createElement("axes");
		let dsSources = document.createElement("sources");
		let dsInstances = document.createElement("instances");
		GLOBAL.vf.axes.forEach(axis => {
			let dsAxis = document.createElement("axis");
			dsAxis.setAttribute("name", axis.name);
			dsAxis.setAttribute("tag", axis.tag);
			dsAxis.setAttribute("minimum", axis.min);
			dsAxis.setAttribute("default", axis.default);
			dsAxis.setAttribute("maximum", axis.max);
			dsAxes.appendChild(dsAxis);
		})
		// what to do about sources?
		GLOBAL.vf.instances.forEach(instance => {
			let dsInst = document.createElement("instance");
			//dsInstances.appendChild(dsInst);
		})
		designspace.appendChild(dsAxes);
		designspace.appendChild(dsSources);
		designspace.appendChild(dsInstances);
		console.log ("<?xml version='1.0' encoding='utf-8'?>\n" + designspace.outerHTML);
	}





	if (!panel.parentNode.classList.contains("open"))
		panel.style.display = "none";


	///////////////////////////////////////////////////////
	// Glyphs panel
	///////////////////////////////////////////////////////
	GLOBAL.currentGlyphId = getDefaultGlyphId(font);
	updateGlyphsPanel (); // use default glyphs


	Q("body").style.cursor = "default";

	// designspace: handle mousemove
	Q("#ds-cartesian").addEventListener("mousemove", e => {
		// requires pointer-events:none on all grid lines

		//console.log(e.target.id);
		let rect = e.target.getBoundingClientRect();
		let x = e.clientX - rect.left;
		let y = e.clientY - rect.top;
		x = x/180-1;
		y = 1-y/180;

		// update the visual designspace location
		Q("#svgXVal").setAttributeNS(null, "d", `M${x} -1 L${x} 1`);
		Q("#svgYVal").setAttributeNS(null, "d", `M-1 ${y} L1 ${y}`);

		// initialize tuple
		let tuple = [];
		for (let a=0; a < GLOBAL.vf.axes.length; a++) {
			tuple.push(0); // default is 0 by definition
		}
			
		// what is current x axis?
		Qall("#xSelect option").forEach(option => {
			if (option.selected) {			
				let indices = GLOBAL.vf.axisIndices(option.value); // get axis indices for this axis tag
				indices.forEach(index => {
					tuple[index] = x;
				});
			}
		});

		// what is current y axis?
		Qall("#ySelect option").forEach(option => {
			if (option.selected) {			
				let indices = GLOBAL.vf.axisIndices(option.value); // get axis indices for this axis tag
				indices.forEach(index => {
					tuple[index] = y;
				});
			}
		});

		// update the text fields
		Q("#xValue").innerText = x;
		Q("#yValue").innerText = y;

		// set the axes in the Axes panel
		let fvs = GLOBAL.vf.tupleToFvs(tuple);
		setAxes (GLOBAL.vf, fvs);

		// now update the glyph in the drawing
		// - should we do this simply by setting the axes in the Axes panel
		let instance = font.addInstance(null, {tuple: tuple});
		let glyph = font.glyphs[GLOBAL.currentGlyphId];
		let iglyph = glyphApplyVariations(glyph, null, instance);
		setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG
		font.instances.pop();

	});

	Q("#xSelect").addEventListener("input", dsAxisSelectValidate);
	Q("#ySelect").addEventListener("input", dsAxisSelectValidate);

}


function dsAxisSelectValidate (e) {

	let xItems = [], yItems = [], valid = true;
	Qall("#xSelect>option:checked").forEach(option => {
		xItems.push(option.value);
	});
	Qall("#ySelect>option:checked").forEach(option => {
		yItems.push(option.value);
	});
	xItems.forEach(tag => {
		if (yItems.includes(tag))
			valid = false;
	});

	xSelect.style.backgroundColor = ySelect.style.backgroundColor = valid ? "inherit" : "red";

}


function axisInput() {

	let font = GLOBAL.vf;

	// create instance
	let instance = font.addInstance(getCurrentFvs()); // { name: "Custom", tuple: [] };
	console.log(instance);

	let glyph = font.glyphs[GLOBAL.currentGlyphId];
	let iglyph = glyphApplyVariations(glyph, null, instance);
	setActiveGlyph (GLOBAL.currentGlyphId, instance); // update the SVG

	// delete instance? definitely!
	font.instances.pop();
}

function updateDesignspace() {

	console.log("updateDesignspace");
	let cb = Q("#dsAxesMultiple");
	let xSelect = Q("#xSelect");
	let ySelect = Q("#ySelect");

	/*
	if (cb.checked) {
		xSelect.setAttribute("multiple", true);
		ySelect.setAttribute("multiple", true);
	}
	else {
		xSelect.removeAttribute("multiple");
		ySelect.removeAttribute("multiple");
	}
	*/

	// draw cartesian axes
	let cartesian = Q("#ds-cartesian");

	let svg = SVG("svg");
	let svgg = SVG("g"); // this transforms everything inside it
	let svgXYAxes, svgXVal, svgYVal;
	let scale = 360/2; // 360 is the width & height of the cartesian space in px, 2 is the width & height of the cartesian space in normalized units (-1 to +1)
	svg.setAttributeNS(null, "width","360");
	svg.setAttributeNS(null, "height","360");
	svgg.setAttributeNS(null, "transform", `translate(180,180) scale(${scale},-${scale})`);

	svgXYAxes = SVG("path");
	svgXYAxes.attrsSVG({
		//d: "M-10000,0 L10000,0 M0,-10000 L0,10000",
		d: "M-1 0 L1 0 M0 -1 L0 1",
		stroke: `lightblue`,
		"stroke-width": `${1/scale}px`,
		fill: "none",
		"pointer-events": "none",
	});

	svgXVal = SVG("path");
	svgXVal.id = "svgXVal";
	svgXVal.attrsSVG({
		d: "M0 -1 L0 1",
		stroke: `blue`,
		"stroke-width": `${1/scale}px`,
		fill: "none",
		"pointer-events": "none",
	});

	svgYVal = SVG("path");
	svgYVal.id = "svgYVal";
	svgYVal.attrsSVG({
		d: "M-1 0 L1 0",
		stroke: `lightgreen`,
		"stroke-width": `${1/scale}px`,
		fill: "none",
		"pointer-events": "none",
	});

	svgg.appendChild(svgXVal);
	svgg.appendChild(svgYVal);
	svgg.appendChild(svgXYAxes);
	svg.appendChild(svgg);

	cartesian.appendChild(svg);


	// draw some glyphs (at named instance locations)



	// capture mouse



	// consider 1d view

}

function updateGlyphsPanel(instance) {

	console.log("Updating glyphs panel");
	let font = GLOBAL.vf;

	///////////////////////////////////////////////////////
	// glyphs panel
	///////////////////////////////////////////////////////
	let panel = Q("#glyphs>div");
	panel.innerText = "";
	let scale = 0.05 * 1000 / font.unitsPerEm;

	for (let g=0; g < font.numGlyphs; g++) {

		let glyph = instance ? instance.glyphs[g] : font.glyphs[g];
		let glyphName;

		let glyphThumb = document.createElement("div");
		glyphThumb.classList.add("glyph-thumb");
		glyphThumb.setAttribute("id", `g-${g}`);


		//if (glyph && glyph.numContours > 0) {
		if (glyph) {

			// simple glyph
			let svg = SVG("svg");
			let svgg = SVG("g");

			svg.setAttributeNS(null, "width","90");
			svg.setAttributeNS(null, "height","90");
			svgg.setAttributeNS(null, "transform", `translate(20,60) scale(${scale},-${scale})`);
			
			let paths = getGlyphSVGpath(glyph);
			if (!Array.isArray(paths)) { // composite
				paths = [paths];
			}
			paths.forEach((path, p) => {
				let svgPath;
				let svgg3 = glyph.numContours == -1 ? SVG("g") : null; // wrap component paths in a g so they can be transformed
				svgPath = SVG("path"); // give this an id so we can detect clicks
				svgPath.attrsSVG({
					d: path,
					stroke: GLOBAL.vf.config.ui.glyphThumb.stroke,
					"stroke-width": `${GLOBAL.vf.config.ui.glyphThumb.strokeWidth}px`,
					fill: GLOBAL.vf.config.ui.glyphThumb.fill,
				});
				if (svgg3) {
					svgg3.setAttributeNS(null, "transform", `translate(${glyph.points[p][0]},${glyph.points[p][1]})`);
					svgg3.appendChild(svgPath);
					svgg.appendChild(svgg3);
				}
				else {
					svgg.id = `g${glyph.id}`;
					svgg.appendChild(svgPath);
				}
			});

			svg.appendChild(svgg);
			glyphThumb.appendChild(svg);

			glyphName = glyph.name;
		}
		else if (glyph && glyph.numContours < 0) {

			glyphName = glyph.name;

		}

		let selected = document.createElement("div");
		selected.classList.add("selected");
		glyphThumb.appendChild(selected);
		panel.appendChild(glyphThumb);


		let label = document.createElement("label");

		label.innerText = glyphName ? glyphName : `#${g}`; // TODO: implement a toggle so we see glyph id when we want to

		glyphThumb.appendChild(label);

	}

	setActiveGlyph(GLOBAL.currentGlyphId, instance);

}

function setAxes (font, fvs) {
	

	let sliders = Qall(".slider");
	font.axes.forEach((axis, a) => {

		if (axis.min > axis.max)
			return;

		let val = fvs[axis.tag];
		if (val < axis.min)
			val = axis.min;
		if (val > axis.max)
			val = axis.max;

		sliders[a].value = (val - axis.min) / (axis.max - axis.min);
	});
}

function getActiveInstance (font) {

	let instance = null;
	Qall(".instance").forEach(el => {
		console.log(`checking instance`)
		if (el.classList.contains("active")) {
			console.log(`got instance`, el.data.instance)
			instance = el.data.instance;
		}
	});
	return instance;
}

function setActiveInstance (font, target) {

	Qall(".instance").forEach((el, i) => {

		let instance = font.instances[i]; // font.instances[0] is the default "instance"

		// update instance ui
		if (el == target || (!target && instance.default)) { // allows for future reordering
			
			el.classList.add("active");
			setAxes (font, instance.fvs);
			instanceApplyVariations (font, instance);
			updateGlyphsPanel (instance);
		}
		else {
			el.classList.remove("active");
			//target.data.selected = true;
		}
	});
}


function getActiveGlyph () {

	let g = 0;
	Qall(".glyph-thumb .selected").forEach(el => {
		if (el.style.display == "block") {
			let comps = el.parentNode.id.split("-");
			g = 1 * comps[1];
		}
	});
	return g;
	// TODO: it would be simpler just to store the active glyph somewhere
	// return font.currentGlyphId;
}


function setActiveGlyph (g, instance) {

	// instance may be undefined

	let font = GLOBAL.vf;
	let ui = font.config.ui;
	if (g === undefined)
		g = 0;
	g *= 1;

	GLOBAL.currentGlyphId = g; // hmm, should be part of the font, not GLOBAL … TODO: check g < numGlyphs

	Qall(".glyph-thumb").forEach(el => {
		Q(`#${el.id} .selected`).style.display = "none";
	});
	
	Q(`#g-${g} .selected`).style.display = "block";
	// TODO: wouldn’t this be more elegant setting background-color with a class?


	let glyph = font.glyphs[g];
	

	//let iglyph = glyphApplyVariations(glyph, getCurrentFvs(), instance);
	let iglyph = glyphApplyVariations(glyph, null, instance);
	//setActiveGlyph(g);

	//event.target.classList.add("selected");

	//console.log ("Glyph " + g)
	// clear main window and tvts panel
	let drawing = Q("#drawing");
	drawing.innerHTML = "";
	let panel = Q("#tvts>div");
	panel.innerHTML = "";

	let layers = []; // layers are drawn from low values (bottom) to high values (top)


	let scale = 0.5 * 1000 / font.unitsPerEm;
	let opacity = 0.5;
	let svg = SVG("svg");
	let svgg = SVG("g"); // this transforms everything inside it
	let svgDefs = SVG("defs")
	let svgMarker = SVG("marker")
	let svgMarkerPath = SVG("path")
	svg.attrsSVG( {
		width: 1000,
		height: 1000,
		style: `background-color: ${ui.glyph.backgroundColor};`,
	});
	svgg.setAttributeNS(null, "transform", `translate(130,500) scale(${scale},-${scale})`);

	// define marker
	svgMarker.id = "arrow";
	svgMarker.attrsSVG({
		markerWidth: 20,
		markerHeight: 20,
		fill: ui.arrow.color,
		orient: "auto",
		refX: 10,
		refY: 5,
	});
	svgMarkerPath.setAttributeNS(null, "d", "M 10 5 L 3 2 L 3 8 z");
	svgMarker.appendChild(svgMarkerPath);
	svgDefs.appendChild(svgMarker);

	/*
	// filters to use... not yet :)
	// - https://developer.mozilla.org/en-US/docs/Web/SVG/Element/filter
	let svgFilter = SVG("filter");
	svgFilter.setAttributeNS(null, "id","blur");
	let svgFilterBlur = SVG("feGaussianBlur");
	svgFilterBlur.setAttributeNS(null, "stdDeviation","5");
	svgFilter.appendChild(svgFilterBlur);
	svgDefs.appendChild(svgFilter);
	*/

	svg.appendChild(svgDefs);


	// TODO: we're not yet using the layer idea, but I think it will be useful to allow us to make minimal updates
	[0,1,2,3,5,6].forEach(L => {
	//for (let L=0; L<7; L++) {
		let svgPath, svgg3, paths;
		let layer = layers[L] = {
			on: true,
			svg: null,
		};

		switch (L) {

			// cartesian axes, the grid
			case 0:
				layer.type = "grid";
				svgPath = SVG("path");
				svgPath.attrsSVG({
					d: "M-10000,0 L10000,0 M0,-10000 L0,10000",
					stroke: ui.cartesianAxes.stroke,
					"stroke-width": ui.cartesianAxes.strokeWidth + "px",
					fill: "none",
				});
				svgg.appendChild(svgPath);

				break;

			case 1:
				layer.type = "default";
				//svgPath = SVG("path");

				// draw glyph

				// we transform each component
				// - check each time we use getGlyphSVGpath()
				// - we take the translation from the glyph’s points property (which has been processed as usual by tvts)
				// - TODO: we’ll take the transformation matrix from the glyph’s components[p].transform
				// - must look up the order or processing: translate, transform or transform, translate (I recall that Apple and Microsoft differed on this)
				// - fonts using transforms are quite rare; Wingdings uses rotation and reflection in some ornaments
				// - https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform

				paths = getGlyphSVGpath(glyph);
				if (!Array.isArray(paths)) { // composite
					paths = [paths];
				}
				paths.forEach((path, p) => {
					svgg3 = glyph.numContours == -1 ? SVG("g") : null; // wrap component paths in a g
					svgPath = SVG("path"); // give this an id so we can detect clicks
					svgPath.attrsSVG({
						d: path,
						stroke: ui.glyph.stroke,
						"stroke-width": `${ui.glyph.strokeWidth}px`,
						fill: ui.glyph.fill,
					});
					if (svgg3) {
						//svgg3.setAttributeNS(null, "transform", `translate(${iglyph.points[p][0]} ${iglyph.points[p][1]})`);
						// glyph.points[0] is the xy offset of the first component,
						// glyph.points[1] is the xy offset of the second component, etc.
						svgg3.setAttributeNS(null, "transform", `translate(${glyph.points[p][0]} ${glyph.points[p][1]})`);
						svgg3.appendChild(svgPath);
						svgg.appendChild(svgg3);
					}
					else
						svgg.appendChild(svgPath);
				});

				break;

			case 2:
				layer.type = "instance";

				// draw glyph with variations taken from the current axis settings
				// - should we render all active instances in this "layer"?
				/*
				svgPath = SVG("path");
				svgPath.attrsSVG({
					"style": `opacity:${opacity}`,
					"d": getGlyphSVGpath(iglyph),
					"stroke": `black`, // make this take a value from the ui confi
					"stroke-width": `${GLOBAL.vf.config.ui.glyph.strokeWidth}px`,
					"fill": `#00f`,
					// "filter": "url(#blur)", not yet :)					
				});
				*/

				paths = getGlyphSVGpath(iglyph);
				if (!Array.isArray(paths)) { // composite
					paths = [paths];
				}
				let uiStyle = ui.instanceGlyph;
				paths.forEach((path, p) => {
					svgg3 = iglyph.numContours == -1 ? SVG("g") : null; // wrap component paths in a g
					svgPath = SVG("path"); // give this an id so we can detect clicks
					svgPath.attrsSVG({
						d: path,
						style: `opacity: ${uiStyle.opacity}`,
						stroke: "black",//`${uiStyle.stroke}`,
						"stroke-width": `${uiStyle.strokeWidth}px`,
						fill: `${uiStyle.fill}`,
						// "filter": "url(#blur)", not yet :)					
					});
					if (svgg3) {
						//svgPath.id = `g${iglyph.id}-c${p}`; // "g27-c2" means component #2 of glyph #27
						svgg3.setAttributeNS(null, "transform", `translate(${iglyph.points[p][0]} ${iglyph.points[p][1]})`);
						svgg3.appendChild(svgPath);
						svgg.appendChild(svgg3);
					}
					else {
						//svgg3.id = `g${iglyph.id}`; // "g27" means glyph 27
						svgg.appendChild(svgPath);
					}
				});

				break;

			case 3:
				// TODO: decide how to show "points" for composites… origin, so we see translations?
				layer.type = "instance-points";
				svgg2 = SVG("g");

				iglyph.points.forEach(function (pt, p) {
					let size = ui.point.size;
					let svgP;
					if (pt[2]) {
						svgP = SVG("rect"); // on-curve
						svgP.classList.add("ctrl-pt");
						svgP.attrsSVG({
							x: pt[0]-size, y: pt[1]-size,
							width: 2*size, height: 2*size,
						});
					}
					else {
						svgP = SVG("circle"); // off-curve
						svgP.classList.add("ctrl-pt");
						svgP.attrsSVG({ cx: pt[0], cy: pt[1], r: 4 });
					}
					svgP.data = { point: pt };
					svgg2.appendChild(svgP);
				});

				svgg.appendChild(svgg2);
				break;

			case 4:
				layer.type = "arrows";

				svgg2 = SVG("g");
				svgg2.attrsSVG({
					"stroke": `${ui.arrow.color}`,
					"stroke-width": `${ui.arrow.strokeWidth}`,
				});

				glyph.points.forEach((point1, pt) => {
					let point2 = iglyph.points[pt]; // transformed point
					let x1 = point1[0], y1 = point1[1], x2 = point2[0], y2 = point2[1];
					if (x1==x2 && y1==y2) {
						// same location so no line (now we can ignore divide-by-zero in the else{}
					}
					else {
						// truncate each line so that it ends in a nice point; this shortens the line so that the arrow is properly pointed
						// - ignore for now, because this of course moves where the arrow head sits…
						// - probably best to draw the whole line+arrow as a path
						// let hypot = Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));
						// let dx = 3 * (x2-x1)/hypot; 
						// let dy = 3 * (y2-y1)/hypot;

						let svgLine = SVG("line");
						svgLine.attrsSVG({ x1: x1, y1: y1, x2: x2, y2: y2, "marker-end": "url(#arrow)" });
						if (!iglyph.touched[pt]) {
							svgLine.attrsSVG({ "stroke-dasharray": "1 4" }); // IUP implicit movement
						}
						svgg2.appendChild(svgLine);
					}
				});										

				svgg.appendChild(svgg2);
				break;

			case 5:

				// draw control points, grouped in their own <g>
				layer.type = "points";
				svgg2 = SVG("g");
				svgg2.attrsSVG({
					"fill": "none",
					"stroke-width": "1px",
					"stroke": ui.arrow.color,
				});
				glyph.points.forEach(function (pt, p) {
					// TODO: use individual SVG elements for each point when we implement dragging of instance points
					let size = 4; //font.config.ui.point.size;
					svgPath = SVG("path");
					svgPath.attrsSVG({"d": `M${pt[0]-size},${pt[1]} L${pt[0]+size},${pt[1]} M${pt[0]},${pt[1]+size} L${pt[0]},${pt[1]-size}`});
					svgg2.appendChild(svgPath);
				});

				svgg.appendChild(svgg2);
				break;


			case 6:

				layer.type = "arrows-broken";
				svgg2 = SVG("g");
				svgg2.attrsSVG({
					"fill": "none",
					"stroke-width": "3px",
					"stroke": "green",
				});

				glyph.points.forEach((point1, pt) => {
					//let point2 = iglyph.points[pt]; // transformed point

					// TODO: handle movements for IUP points

					let x1 = point1[0], y1 = point1[1];
					let x2, y2;
					glyph.tvts.forEach((tvt, t) => {
						let sValue = iglyph.tvtsVisualization[t].S;
						let delta = tvt.deltas[pt];
						let lineColor = ui.tuple.colors[t % ui.tuple.colors.length];

						let svgLine = SVG("line");
						if (delta === null) { // IUP
							x2 = x1 + iglyph.tvtsVisualization[t].scaledDeltas[pt][0];
							y2 = y1 + iglyph.tvtsVisualization[t].scaledDeltas[pt][1];
							svgLine.attrsSVG({ "stroke-dasharray": "4" });
						}
						else {							
							x2 = x1 + delta[0] * sValue;
							y2 = y1 + delta[1] * sValue;
						}

						let svgArrowHead = SVG("path");
						let angle = Math.atan2(y2-y1, x2-x1);
						let len;
						let newX2=x2, newY2=y2;
						if (x2==x1 && y2==y1)
							len = 0;
						else {
							let tipWidth = ui.arrow.tipWidth * font.unitsPerEm/1000;
							let tipLength = ui.arrow.tipLength * font.unitsPerEm/1000;

							len = Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
							newX2 = x1 + (x2-x1) * (len-tipLength)/len; // 10 = arrowLength
							newY2 = y1 + (y2-y1) * (len-tipLength)/len; // 10 = arrowLength
							let arrowBackX = (y2-y1) * tipWidth/2/len;
							let arrowBackY = (x2-x1) * tipWidth/2/len;

							svgArrowHead.attrsSVG({
								//d: `M${x2} ${y2}l${newX2+arrowBackX} ${newY2+arrowBackY}l${newY2-arrowBackX} ${newY2-arrowBackY}Z`,
								d: `M${x2} ${y2}L${newX2+arrowBackX} ${newY2-arrowBackY}L${newX2-arrowBackX} ${newY2+arrowBackY}Z`,
								fill: lineColor,
								stroke: "none",
							})
						}

						svgLine.attrsSVG({
							//x1: x1, y1: y1, x2: x2, y2: y2,
							x1: x1, y1: y1, x2: newX2, y2: newY2,
							stroke: lineColor, // get the t’th colour in the array, wrapping round to the start when we run out of colours
							"stroke-width": ui.arrow.strokeWidth * font.unitsPerEm/1000,
						});
						svgg2.appendChild(svgLine);
						svgg2.appendChild(svgArrowHead);
						x1 = x2;
						y1 = y2;
					});
				});

				svgg.appendChild(svgg2);
				break;

		}



		// add layer to the view

		layer.svg = svg;

	//}
	});


	svg.appendChild(svgg);
	drawing.appendChild(svg);

	// drawing layers
	// - coordinate grid
	// - default glyph (options: control points)
	// - transformed glyph (options: control points, arrows, per-tuple arrows)
	// - point loci
	// each layer can be on/off


	// default glyph


	// display the tvts

	glyph.tvts.forEach((tvt, t) => {

		let li = document.createElement("li");
		li.classList.add("tvt");

		// we mention some stuff about tvt id, then numpoints moved or something, then (aligning with axes in instance panel) an SVG graph for each axis
		li.style.display = "grid";
		li.style.gridTemplateColumns = `1.5em 80px 45px repeat(${GLOBAL.vf.axisCount}, 45px)`
		li.style.backgroundColor = "lightgrey";
		li.style.height = "20px";

		let tvtId = document.createElement("div");
		tvtId.innerText = t;
		tvtId.style.backgroundColor = ui.tuple.colors[t % ui.tuple.colors.length];
		tvtId.style.color = "white";
		tvtId.style.fontWeight = "bold";
		tvtId.style.textAlign = "center";

		let tvtDeltas = document.createElement("div");
		let numDeltas = 0;
		for (let p=0; p<tvt.deltas.length; p++) {
			if (tvt.deltas[p] !== null)
				numDeltas++;
		}
		tvtDeltas.innerText = `${numDeltas}/${tvt.deltas.length}`;
		tvtDeltas.setAttribute("title", `This tuple variation moves ${numDeltas} out of ${tvt.deltas.length} points${ numDeltas==tvt.deltas.length ? " (no IUP)" : ""}`);

		// draw S value as bar graph
		let sValue = iglyph.tvtsVisualization[t].S;
		let tvtS = document.createElement("div");
		let vizWidth = Math.max(0.25, 40 * sValue); // minimum of 0.25px
		tvtS.setAttribute("title", sValue);
		if (sValue > 0) {
			tvtS.setAttribute("style", `width: ${vizWidth}px; height: 20px; background-color: ${ui.tupleScalar.fill};`);
			li.style.backgroundColor = "white";
		}

		li.appendChild(tvtId);
		li.appendChild(tvtDeltas);
		li.appendChild(tvtS);


		// add a graph for each axis
		// - each graph is a single SVG element with descendants
		// - each tuple contains <font.numAxes> graphs representing how this tuple responds to each axis
		for (let a=0; a<GLOBAL.vf.axisCount; a++) {
			let tvtGraphEl = document.createElement("div");
			let tvtGraph = SVG("svg");
			let svgg = SVG("g");

			tvtGraph.setAttributeNS(null, "width","50");
			tvtGraph.setAttributeNS(null, "height","21");
			svgg.setAttributeNS(null, "transform", `translate(20,20) scale(1,-1)`);


			// draw a graph through start, peak, end for each axis
			let Sx = 20, Sy = 20; // x and y scales

			// draw graph paper
			let pathG = SVG("path");
			//let pathD = pathD = `M ${Sx*-1},0 L ${Sx*tvt.start[a]},0 L ${Sx*tvt.peak[a]},${Sy} L ${Sx*tvt.end[a]},0`;
			pathG.setAttributeNS(null, "fill", "none");
			pathG.setAttributeNS(null, "stroke", "darkgrey");
			pathG.setAttributeNS(null, "stroke-width", "0.5");
			pathG.setAttributeNS(null, "d", `M ${Sx*-1} 0 L ${Sx*1} 0 M 0 0 L 0 ${Sy*1}`);
			svgg.appendChild(pathG);

			// draw tuple start, peak, end data
			if (tvt.peak[a] != 0) { // “When a delta is provided for a region defined by n-tuples that have a peak value of 0 for some axis, then that axis does not factor into scalar calculations.”
				// typicaly graphs are shown at https://docs.microsoft.com/en-us/typography/opentype/spec/otvaroverview
				let path = SVG("path");
				let pathD = `M ${Sx*tvt.start[a]},0 L ${Sx*tvt.peak[a]},${Sy*1.0} L ${Sx*tvt.end[a]},0`;
				path.setAttributeNS(null, "fill", "black");
				path.setAttributeNS(null, "stroke", "none");
				path.setAttributeNS(null, "d", pathD);
				svgg.appendChild(path);

				// draw current axis position
				if (iglyph.instance && iglyph.instance.tuple[a] > 0) {
					let needle = SVG("line");
					let needleColor = ui.tupleNeedle.stroke;
					needle.attrsSVG({fill: "none", stroke: needleColor, "stroke-width": "1px", x1: iglyph.instance.tuple[a]*20, y1: 0, x2: iglyph.instance.tuple[a]*20, y2: 20});
					svgg.appendChild(needle);
				}

			}


			tvtGraph.appendChild(svgg);
			tvtGraphEl.appendChild(tvtGraph);

			tvtGraphEl.style.textAlign = "right";
			li.appendChild(tvtGraphEl);
		}
		
		panel.appendChild(li);

		// display the actual deltas for this tuple
		tvtDeltas.addEventListener("click", function (event) {
			let str = "";
			tvt.deltas.forEach((delta, p) => {
				str += `${p}: `;
				if (delta === null)
					str += "—";
				else
					str += `${Math.round(sValue*delta[0])},${Math.round(sValue*delta[1])}`;
				str += "\n";
			});
			alert (str);
		});

	});

}


function playGlyphs() {
	g = getActiveGlyph();
	setActiveGlyph ((g+1) % GLOBAL.vf.numGlyphs, getActiveInstance(GLOBAL.vf));
	GLOBAL.vf.timerGlyphPlayer = setTimeout (playGlyphs, 500);
}


// click handlers for all clicks
document.onclick = function (event) {

	//console.log(event.target);
	// about target
	// - via the method of assignment in the if(), target gets the desired element rather than a child (or grandchild) that in fact received the event
	// - the closest(x) method is great: we find whether event.target happened on something within something selected by x
	// - order matters! (e.g. an icon within an instance row must be handled before the instance row itself)
	let target;
	let font = GLOBAL.vf;

	//console.log(event.target.classList);


	if (event.target == Q("#font-file")) {
	//if (target = event.target.closest("#font-file")) {
		// debug hack to load MutatorSans easily
		Q("body").style.cursor = "wait";

		let vf = new SamsaVF({

			fontFamily: "FontNameShouldGoHere",
			url: "fonts/MutatorSans.ttf",
			callback: vfLoaded,
		});
	}

	// else if (event.target.id == "dsAxesMultiple") {
	// 	updateDesignspace();
	// }

	else if (target = event.target.closest("#controls .panel .instantiate")) {

		// create and download the instance		
		let instanceEl = target.closest(".instance");
		let instance = instanceEl.data.instance;

		GLOBAL.vf.makeInstance(instance); // creates instance.static

		//window.open (`data:font/ttf;base64,${uint8ToBase64(instance.static)}`, "_blank"); // this method wasn’t great

		let fauxLink = document.createElement("a");
		fauxLink.download = GLOBAL.vf.filename;
		fauxLink.href = "data:font/ttf;base64," + uint8ToBase64(instance.static);

		//let str = btoa(instance.static)
		//console.log (typeof str);
		//console.log (str);
		//fauxLink.href = "data:font/ttf;base64," + str;
		document.body.appendChild(fauxLink); // needed for Firefox, not Chrome or Safari
		fauxLink.click();
		fauxLink.remove();

	}

	else if (target = event.target.closest(".instance")) {

		setActiveInstance(GLOBAL.vf, target);
	}

	else if (event.target.classList.contains("ctrl-pt")) {
		console.log("click pt", event.target);
		console.log(event.target.data.point);
	}

	else if (target = event.target.closest("#glyphs>h2") 
			&& event.target.classList.contains("icon")
			&& !event.target.classList.contains("reveal")) { // this test must be before the other h2 test

		let g;
		clearTimeout(GLOBAL.vf.timerGlyphPlayer);
		let instance = getActiveInstance(GLOBAL.vf);

		switch (event.target.id) {

			case "glyphs-stepforward":
				clearTimeout(GLOBAL.vf.timerGlyphPlayer);
				g = getActiveGlyph();
				setActiveGlyph ((g+1) % font.numGlyphs, instance);
				break;
			case "glyphs-stepback":
				clearTimeout(GLOBAL.vf.timerGlyphPlayer);
				g = getActiveGlyph();
				setActiveGlyph ((g-1+font.numGlyphs) % font.numGlyphs, instance);
				break;
			case "glyphs-play":
				playGlyphs();
				break;
			case "glyphs-stop":
				clearTimeout(GLOBAL.vf.timerGlyphPlayer);
				GLOBAL.vf.timerGlyphPlayer = undefined;
				break;
		}

	}

	else if (target = event.target.closest("#controls .panel>h2")) {
		// toggle display of panel when panel header is clicked
		let panelDiv = target.parentNode.querySelector("div");

		panelDiv.parentNode.classList.toggle("open");

		console.log (panelDiv);
		if (panelDiv) {
			if (panelDiv.style.display == "none") {
				panelDiv.style.display = "block";
			}
			else if (panelDiv.style.display = "block")
				panelDiv.style.display = "none";	
		}
	}

	else if (target = event.target.closest(".glyph-thumb")) {

		let comps = target.id.split("-");
		let g = comps[1];

		setActiveGlyph(g, getActiveInstance(GLOBAL.vf));

	}

	else if (target = event.target.closest("#font-list .font-file")) {

		// load font mutator

		let vf = new SamsaVF({

			fontFamily: "FontNameShouldGoHere",
			url: `fonts/${target.innerText}`,
			callback: vfLoaded,
		});

		return false;
	}

	//return false;

}

function dropHandler(ev) {

// https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/File_drag_and_drop
  // Prevent default behavior (Prevent file from being opened)
  //alert ('File(s) dropped');
  ev.preventDefault();

  if (ev.dataTransfer.items) {
    // Use DataTransferItemList interface to access the file(s)

    for (var i = 0; i < 1 /* ev.dataTransfer.items.length */ ; i++) { // limit to processing of first file dropped

      // If dropped items aren't files, reject them
      if (ev.dataTransfer.items[i].kind === 'file') {
        var file = ev.dataTransfer.items[i].getAsFile();
        let reader = new FileReader();
        reader.__file__ = file;
        reader.onload = function (event) {

			//console.log (event.target.result);
			//console.log (event.target);
			console.log(this.__file__.size)
			let vf = new SamsaVF({

				arrayBuffer: event.target.result,
				inFile: this.__file__.name,
				filesize: this.__file__.size,
				date: this.__file__.lastModified,  // doesn't retrieve the real file date
				callback: vfLoaded,
			});
		};
		reader.readAsArrayBuffer(file); // https://stackoverflow.com/questions/22659164/read-a-drag-and-dropped-file
      }
    }
  }
}

Q("#font-file").addEventListener("drop", dropHandler);
Q("#font-file").addEventListener("dragover",function(e){
	e = e || event;
	e.preventDefault();
},false);



function SVG(tag) {

    return document.createElementNS('http://www.w3.org/2000/svg', tag);
}




// method to attach multiple SVG attributes at once
// - example of attrs: { d: path, stroke: "black", "stroke-width": "2px", fill: "#eee" }
// - TODO: this is really nasty, we should only apply it to SVG objects

/*Object.prototype.attrsSVG = function (attrs) {
	for (const prop in attrs) {
		this.setAttributeNS(null, prop, attrs[prop]);
	}
}
*/

//let tempSVG = document.createElementNS('http://www.w3.org/2000/svg', "SVG");
/*
document.createElementNS.prototype.attrsSVG = function (attrs) {
	for (const prop in attrs) {
		this.setAttributeNS(null, prop, attrs[prop]);
	}
};
*/
SVGElement.prototype.attrsSVG = function (attrs) {
	for (const prop in attrs) {
		this.setAttributeNS(null, prop, attrs[prop]);
	}
};



function getArrowPathForLine(x1, y1, x2, y2, width, arrowLength, arrowWidth) {
	// returns a string suitable for use as the SVG path "d" attribute
	// it solves two problem of SVG lines when used with a pointed arrow:
	// 1. the line is printed on top of the arrow-head, making the tip blunt
	// 2. markers have colour in themselves, which is not useful when each line needs a custom colour

	// for a line pointing due east, we start at the bottom left corner and go anticlockwise
	// - Hmmm, this won’t work with dash-array for dotted lines

/*
	if (x1==x2 && y1==y2)
		return "M0 0Z";

	let path = `M${x1} ${y1}`;
	let angle = Math.atan2(y2-y1, x2-x1);
	let len = Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
	let anglePerp = angle - Math.PI;
	let xn = (x2-x1)/len;
	let yn = (y2-y1)/len;
	let c = y2-y1, x2-x1
	path += `l${yn*width/2} ${xn*width/2}`;
	path += `l${x2-x1-arrowLength*xn} ${y2-y1-arrowLength*yn}`;
	path += `l${yn*(arrowWidth-width)/2} ${xn*(arrowWidth-width)/2}`;
	path += `L${x1} ${y2}`; // now we are at the tip
	//path += `l${yn*(arrowWidth-width)/2} ${xn*(arrowWidth-width)/2}`;`;
	//path += `l`;
	//path += `l`;
	path += "z";
*/
	return path;
}



// load font list
// - only if we are in http: or https: (it’s not supported in file:)
// - TODO: switch to modern fetch(url)
if (["http:", "https:"].includes(window.location.protocol)) {

	let oReq = new XMLHttpRequest();
	oReq.open("GET", "fonts/_fontlist_.json", true);
	oReq.responseType = "json";
	oReq.onload = function(oEvent) {
		GLOBAL.fontList = this.response;
		// TODO: handle onreadystatechange to detect errors
		let panel = Q("#font-list>div");
		panel.innerHTML = "";
		GLOBAL.fontList.forEach(fontFilename => {
			panel.innerHTML += `<li class="font-file"><a href="">${fontFilename}</a></li>`;
		});
	};
	oReq.send();
}
else {
	let panel = Q("#font-list>div");
	panel.innerHTML = `<div>Remote file loading is not available for protocol “${window.location.protocol}”</div>`;
}


</script>


</body>
</html>